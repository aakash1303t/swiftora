import "./chunk-DC5AMYBS.js";

// node_modules/dm-howler/dist/index.esm.js
function spatial(HowlerGlobal2, Howler2, Howl2, Sound2) {
  HowlerGlobal2.prototype._pos = [0, 0, 0];
  HowlerGlobal2.prototype._orientation = [0, 0, -1, 0, 1, 0];
  HowlerGlobal2.prototype.stereo = function(pan) {
    var self2 = this;
    if (!self2.ctx || !self2.ctx.listener) {
      return self2;
    }
    for (var i2 = self2._howls.length - 1; i2 >= 0; i2--) {
      self2._howls[i2].stereo(pan);
    }
    return self2;
  };
  HowlerGlobal2.prototype.pos = function(x3, y3, z2) {
    var self2 = this;
    if (!self2.ctx || !self2.ctx.listener) {
      return self2;
    }
    y3 = typeof y3 !== "number" ? self2._pos[1] : y3;
    z2 = typeof z2 !== "number" ? self2._pos[2] : z2;
    if (typeof x3 === "number") {
      self2._pos = [x3, y3, z2];
      if (typeof self2.ctx.listener.positionX !== "undefined") {
        self2.ctx.listener.positionX.setTargetAtTime(self2._pos[0], Howler2.ctx.currentTime, 0.1);
        self2.ctx.listener.positionY.setTargetAtTime(self2._pos[1], Howler2.ctx.currentTime, 0.1);
        self2.ctx.listener.positionZ.setTargetAtTime(self2._pos[2], Howler2.ctx.currentTime, 0.1);
      } else {
        self2.ctx.listener.setPosition(self2._pos[0], self2._pos[1], self2._pos[2]);
      }
    } else {
      return self2._pos;
    }
    return self2;
  };
  HowlerGlobal2.prototype.orientation = function(x3, y3, z2, xUp, yUp, zUp) {
    var self2 = this;
    if (!self2.ctx || !self2.ctx.listener) {
      return self2;
    }
    var or = self2._orientation;
    y3 = typeof y3 !== "number" ? or[1] : y3;
    z2 = typeof z2 !== "number" ? or[2] : z2;
    xUp = typeof xUp !== "number" ? or[3] : xUp;
    yUp = typeof yUp !== "number" ? or[4] : yUp;
    zUp = typeof zUp !== "number" ? or[5] : zUp;
    if (typeof x3 === "number") {
      self2._orientation = [x3, y3, z2, xUp, yUp, zUp];
      if (typeof self2.ctx.listener.forwardX !== "undefined") {
        self2.ctx.listener.forwardX.setTargetAtTime(x3, Howler2.ctx.currentTime, 0.1);
        self2.ctx.listener.forwardY.setTargetAtTime(y3, Howler2.ctx.currentTime, 0.1);
        self2.ctx.listener.forwardZ.setTargetAtTime(z2, Howler2.ctx.currentTime, 0.1);
        self2.ctx.listener.upX.setTargetAtTime(xUp, Howler2.ctx.currentTime, 0.1);
        self2.ctx.listener.upY.setTargetAtTime(yUp, Howler2.ctx.currentTime, 0.1);
        self2.ctx.listener.upZ.setTargetAtTime(zUp, Howler2.ctx.currentTime, 0.1);
      } else {
        self2.ctx.listener.setOrientation(x3, y3, z2, xUp, yUp, zUp);
      }
    } else {
      return or;
    }
    return self2;
  };
  Howl2.prototype.init = /* @__PURE__ */ function(_super) {
    return function(o3) {
      var self2 = this;
      self2._orientation = o3.orientation || [1, 0, 0];
      self2._stereo = o3.stereo || null;
      self2._pos = o3.pos || null;
      self2._pannerAttr = {
        coneInnerAngle: typeof o3.coneInnerAngle !== "undefined" ? o3.coneInnerAngle : 360,
        coneOuterAngle: typeof o3.coneOuterAngle !== "undefined" ? o3.coneOuterAngle : 360,
        coneOuterGain: typeof o3.coneOuterGain !== "undefined" ? o3.coneOuterGain : 0,
        distanceModel: typeof o3.distanceModel !== "undefined" ? o3.distanceModel : "inverse",
        maxDistance: typeof o3.maxDistance !== "undefined" ? o3.maxDistance : 1e4,
        panningModel: typeof o3.panningModel !== "undefined" ? o3.panningModel : "HRTF",
        refDistance: typeof o3.refDistance !== "undefined" ? o3.refDistance : 1,
        rolloffFactor: typeof o3.rolloffFactor !== "undefined" ? o3.rolloffFactor : 1
      };
      self2._onstereo = o3.onstereo ? [{ fn: o3.onstereo }] : [];
      self2._onpos = o3.onpos ? [{ fn: o3.onpos }] : [];
      self2._onorientation = o3.onorientation ? [{ fn: o3.onorientation }] : [];
      return _super.call(this, o3);
    };
  }(Howl2.prototype.init);
  Howl2.prototype.stereo = function(pan, id) {
    var self2 = this;
    if (!self2._webAudio) {
      return self2;
    }
    if (self2._state !== "loaded") {
      self2._queue.push({
        event: "stereo",
        action: function() {
          self2.stereo(pan, id);
        }
      });
      return self2;
    }
    var pannerType = typeof Howler2.ctx.createStereoPanner === "undefined" ? "spatial" : "stereo";
    if (typeof id === "undefined") {
      if (typeof pan === "number") {
        self2._stereo = pan;
        self2._pos = [pan, 0, 0];
      } else {
        return self2._stereo;
      }
    }
    var ids = self2._getSoundIds(id);
    for (var i2 = 0; i2 < ids.length; i2++) {
      var sound = self2._soundById(ids[i2]);
      if (sound) {
        if (typeof pan === "number") {
          sound._stereo = pan;
          sound._pos = [pan, 0, 0];
          if (sound._node) {
            sound._pannerAttr.panningModel = "equalpower";
            if (!sound._panner || !sound._panner.pan) {
              setupPanner(sound, pannerType);
            }
            if (pannerType === "spatial") {
              if (typeof sound._panner.positionX !== "undefined") {
                sound._panner.positionX.setValueAtTime(pan, Howler2.ctx.currentTime);
                sound._panner.positionY.setValueAtTime(0, Howler2.ctx.currentTime);
                sound._panner.positionZ.setValueAtTime(0, Howler2.ctx.currentTime);
              } else {
                sound._panner.setPosition(pan, 0, 0);
              }
            } else {
              sound._panner.pan.setValueAtTime(pan, Howler2.ctx.currentTime);
            }
          }
          self2._emit("stereo", sound._id);
        } else {
          return sound._stereo;
        }
      }
    }
    return self2;
  };
  Howl2.prototype.pos = function(x3, y3, z2, id) {
    var self2 = this;
    if (!self2._webAudio) {
      return self2;
    }
    if (self2._state !== "loaded") {
      self2._queue.push({
        event: "pos",
        action: function() {
          self2.pos(x3, y3, z2, id);
        }
      });
      return self2;
    }
    y3 = typeof y3 !== "number" ? 0 : y3;
    z2 = typeof z2 !== "number" ? -0.5 : z2;
    if (typeof id === "undefined") {
      if (typeof x3 === "number") {
        self2._pos = [x3, y3, z2];
      } else {
        return self2._pos;
      }
    }
    var ids = self2._getSoundIds(id);
    for (var i2 = 0; i2 < ids.length; i2++) {
      var sound = self2._soundById(ids[i2]);
      if (sound) {
        if (typeof x3 === "number") {
          sound._pos = [x3, y3, z2];
          if (sound._node) {
            if (!sound._panner || sound._panner.pan) {
              setupPanner(sound, "spatial");
            }
            if (typeof sound._panner.positionX !== "undefined") {
              sound._panner.positionX.setValueAtTime(x3, Howler2.ctx.currentTime);
              sound._panner.positionY.setValueAtTime(y3, Howler2.ctx.currentTime);
              sound._panner.positionZ.setValueAtTime(z2, Howler2.ctx.currentTime);
            } else {
              sound._panner.setPosition(x3, y3, z2);
            }
          }
          self2._emit("pos", sound._id);
        } else {
          return sound._pos;
        }
      }
    }
    return self2;
  };
  Howl2.prototype.orientation = function(x3, y3, z2, id) {
    var self2 = this;
    if (!self2._webAudio) {
      return self2;
    }
    if (self2._state !== "loaded") {
      self2._queue.push({
        event: "orientation",
        action: function() {
          self2.orientation(x3, y3, z2, id);
        }
      });
      return self2;
    }
    y3 = typeof y3 !== "number" ? self2._orientation[1] : y3;
    z2 = typeof z2 !== "number" ? self2._orientation[2] : z2;
    if (typeof id === "undefined") {
      if (typeof x3 === "number") {
        self2._orientation = [x3, y3, z2];
      } else {
        return self2._orientation;
      }
    }
    var ids = self2._getSoundIds(id);
    for (var i2 = 0; i2 < ids.length; i2++) {
      var sound = self2._soundById(ids[i2]);
      if (sound) {
        if (typeof x3 === "number") {
          sound._orientation = [x3, y3, z2];
          if (sound._node) {
            if (!sound._panner) {
              if (!sound._pos) {
                sound._pos = self2._pos || [0, 0, -0.5];
              }
              setupPanner(sound, "spatial");
            }
            if (typeof sound._panner.orientationX !== "undefined") {
              sound._panner.orientationX.setValueAtTime(x3, Howler2.ctx.currentTime);
              sound._panner.orientationY.setValueAtTime(y3, Howler2.ctx.currentTime);
              sound._panner.orientationZ.setValueAtTime(z2, Howler2.ctx.currentTime);
            } else {
              sound._panner.setOrientation(x3, y3, z2);
            }
          }
          self2._emit("orientation", sound._id);
        } else {
          return sound._orientation;
        }
      }
    }
    return self2;
  };
  Howl2.prototype.pannerAttr = function() {
    var self2 = this;
    var args = arguments;
    var o3, id, sound;
    if (!self2._webAudio) {
      return self2;
    }
    if (args.length === 0) {
      return self2._pannerAttr;
    } else if (args.length === 1) {
      if (typeof args[0] === "object") {
        o3 = args[0];
        if (typeof id === "undefined") {
          if (!o3.pannerAttr) {
            o3.pannerAttr = {
              coneInnerAngle: o3.coneInnerAngle,
              coneOuterAngle: o3.coneOuterAngle,
              coneOuterGain: o3.coneOuterGain,
              distanceModel: o3.distanceModel,
              maxDistance: o3.maxDistance,
              refDistance: o3.refDistance,
              rolloffFactor: o3.rolloffFactor,
              panningModel: o3.panningModel
            };
          }
          self2._pannerAttr = {
            coneInnerAngle: typeof o3.pannerAttr.coneInnerAngle !== "undefined" ? o3.pannerAttr.coneInnerAngle : self2._coneInnerAngle,
            coneOuterAngle: typeof o3.pannerAttr.coneOuterAngle !== "undefined" ? o3.pannerAttr.coneOuterAngle : self2._coneOuterAngle,
            coneOuterGain: typeof o3.pannerAttr.coneOuterGain !== "undefined" ? o3.pannerAttr.coneOuterGain : self2._coneOuterGain,
            distanceModel: typeof o3.pannerAttr.distanceModel !== "undefined" ? o3.pannerAttr.distanceModel : self2._distanceModel,
            maxDistance: typeof o3.pannerAttr.maxDistance !== "undefined" ? o3.pannerAttr.maxDistance : self2._maxDistance,
            refDistance: typeof o3.pannerAttr.refDistance !== "undefined" ? o3.pannerAttr.refDistance : self2._refDistance,
            rolloffFactor: typeof o3.pannerAttr.rolloffFactor !== "undefined" ? o3.pannerAttr.rolloffFactor : self2._rolloffFactor,
            panningModel: typeof o3.pannerAttr.panningModel !== "undefined" ? o3.pannerAttr.panningModel : self2._panningModel
          };
        }
      } else {
        sound = self2._soundById(parseInt(args[0], 10));
        return sound ? sound._pannerAttr : self2._pannerAttr;
      }
    } else if (args.length === 2) {
      o3 = args[0];
      id = parseInt(args[1], 10);
    }
    var ids = self2._getSoundIds(id);
    for (var i2 = 0; i2 < ids.length; i2++) {
      sound = self2._soundById(ids[i2]);
      if (sound) {
        var pa = sound._pannerAttr;
        pa = {
          coneInnerAngle: typeof o3.coneInnerAngle !== "undefined" ? o3.coneInnerAngle : pa.coneInnerAngle,
          coneOuterAngle: typeof o3.coneOuterAngle !== "undefined" ? o3.coneOuterAngle : pa.coneOuterAngle,
          coneOuterGain: typeof o3.coneOuterGain !== "undefined" ? o3.coneOuterGain : pa.coneOuterGain,
          distanceModel: typeof o3.distanceModel !== "undefined" ? o3.distanceModel : pa.distanceModel,
          maxDistance: typeof o3.maxDistance !== "undefined" ? o3.maxDistance : pa.maxDistance,
          refDistance: typeof o3.refDistance !== "undefined" ? o3.refDistance : pa.refDistance,
          rolloffFactor: typeof o3.rolloffFactor !== "undefined" ? o3.rolloffFactor : pa.rolloffFactor,
          panningModel: typeof o3.panningModel !== "undefined" ? o3.panningModel : pa.panningModel
        };
        var panner = sound._panner;
        if (!panner) {
          if (!sound._pos) {
            sound._pos = self2._pos || [0, 0, -0.5];
          }
          setupPanner(sound, "spatial");
          panner = sound._panner;
        }
        panner.coneInnerAngle = pa.coneInnerAngle;
        panner.coneOuterAngle = pa.coneOuterAngle;
        panner.coneOuterGain = pa.coneOuterGain;
        panner.distanceModel = pa.distanceModel;
        panner.maxDistance = pa.maxDistance;
        panner.refDistance = pa.refDistance;
        panner.rolloffFactor = pa.rolloffFactor;
        panner.panningModel = pa.panningModel;
      }
    }
    return self2;
  };
  Sound2.prototype.init = /* @__PURE__ */ function(_super) {
    return function() {
      var self2 = this;
      var parent = self2._parent;
      self2._orientation = parent._orientation;
      self2._stereo = parent._stereo;
      self2._pos = parent._pos;
      self2._pannerAttr = parent._pannerAttr;
      _super.call(this);
      if (self2._stereo) {
        parent.stereo(self2._stereo);
      } else if (self2._pos) {
        parent.pos(self2._pos[0], self2._pos[1], self2._pos[2], self2._id);
      }
    };
  }(Sound2.prototype.init);
  Sound2.prototype.reset = /* @__PURE__ */ function(_super) {
    return function() {
      var self2 = this;
      var parent = self2._parent;
      self2._orientation = parent._orientation;
      self2._stereo = parent._stereo;
      self2._pos = parent._pos;
      self2._pannerAttr = parent._pannerAttr;
      if (self2._stereo) {
        parent.stereo(self2._stereo);
      } else if (self2._pos) {
        parent.pos(self2._pos[0], self2._pos[1], self2._pos[2], self2._id);
      } else if (self2._panner) {
        self2._panner.disconnect(0);
        self2._panner = void 0;
        parent._refreshBuffer(self2);
      }
      return _super.call(this);
    };
  }(Sound2.prototype.reset);
  var setupPanner = function(sound, type) {
    type = type || "spatial";
    if (type === "spatial") {
      sound._panner = Howler2.ctx.createPanner();
      sound._panner.coneInnerAngle = sound._pannerAttr.coneInnerAngle;
      sound._panner.coneOuterAngle = sound._pannerAttr.coneOuterAngle;
      sound._panner.coneOuterGain = sound._pannerAttr.coneOuterGain;
      sound._panner.distanceModel = sound._pannerAttr.distanceModel;
      sound._panner.maxDistance = sound._pannerAttr.maxDistance;
      sound._panner.refDistance = sound._pannerAttr.refDistance;
      sound._panner.rolloffFactor = sound._pannerAttr.rolloffFactor;
      sound._panner.panningModel = sound._pannerAttr.panningModel;
      if (typeof sound._panner.positionX !== "undefined") {
        sound._panner.positionX.setValueAtTime(sound._pos[0], Howler2.ctx.currentTime);
        sound._panner.positionY.setValueAtTime(sound._pos[1], Howler2.ctx.currentTime);
        sound._panner.positionZ.setValueAtTime(sound._pos[2], Howler2.ctx.currentTime);
      } else {
        sound._panner.setPosition(sound._pos[0], sound._pos[1], sound._pos[2]);
      }
      if (typeof sound._panner.orientationX !== "undefined") {
        sound._panner.orientationX.setValueAtTime(sound._orientation[0], Howler2.ctx.currentTime);
        sound._panner.orientationY.setValueAtTime(sound._orientation[1], Howler2.ctx.currentTime);
        sound._panner.orientationZ.setValueAtTime(sound._orientation[2], Howler2.ctx.currentTime);
      } else {
        sound._panner.setOrientation(sound._orientation[0], sound._orientation[1], sound._orientation[2]);
      }
    } else {
      sound._panner = Howler2.ctx.createStereoPanner();
      sound._panner.pan.setValueAtTime(sound._stereo, Howler2.ctx.currentTime);
    }
    sound._panner.connect(sound._node);
    if (!sound._paused) {
      sound._parent.pause(sound._id, true).play(sound._id, true);
    }
  };
}
var HowlerGlobal = function() {
  this.init();
};
HowlerGlobal.prototype = {
  /**
   * Initialize the global Howler object.
   * @return {Howler}
   */
  init: function() {
    var self2 = this || Howler;
    self2._counter = 1e3;
    self2._html5AudioPool = [];
    self2.html5PoolSize = 10;
    self2._codecs = {};
    self2._howls = [];
    self2._muted = false;
    self2._volume = 1;
    self2._canPlayEvent = "canplaythrough";
    self2._navigator = typeof window !== "undefined" && window.navigator ? window.navigator : null;
    self2.masterGain = null;
    self2.noAudio = false;
    self2.usingWebAudio = true;
    self2.autoSuspend = true;
    self2.ctx = null;
    self2.autoUnlock = true;
    self2._setup();
    return self2;
  },
  /**
   * Get/set the global volume for all sounds.
   * @param  {Float} vol Volume from 0.0 to 1.0.
   * @return {Howler/Float}     Returns self or current volume.
   */
  volume: function(vol) {
    var self2 = this || Howler;
    vol = parseFloat(vol);
    if (!self2.ctx) {
      setupAudioContext();
    }
    if (typeof vol !== "undefined" && vol >= 0 && vol <= 1) {
      self2._volume = vol;
      if (self2._muted) {
        return self2;
      }
      if (self2.usingWebAudio) {
        self2.masterGain.gain.setValueAtTime(vol, Howler.ctx.currentTime);
      }
      for (var i2 = 0; i2 < self2._howls.length; i2++) {
        if (!self2._howls[i2]._webAudio) {
          var ids = self2._howls[i2]._getSoundIds();
          for (var j2 = 0; j2 < ids.length; j2++) {
            var sound = self2._howls[i2]._soundById(ids[j2]);
            if (sound && sound._node) {
              sound._node.volume = sound._volume * vol;
            }
          }
        }
      }
      return self2;
    }
    return self2._volume;
  },
  /**
   * Handle muting and unmuting globally.
   * @param  {Boolean} muted Is muted or not.
   */
  mute: function(muted) {
    var self2 = this || Howler;
    if (!self2.ctx) {
      setupAudioContext();
    }
    self2._muted = muted;
    if (self2.usingWebAudio) {
      self2.masterGain.gain.setValueAtTime(muted ? 0 : self2._volume, Howler.ctx.currentTime);
    }
    for (var i2 = 0; i2 < self2._howls.length; i2++) {
      if (!self2._howls[i2]._webAudio) {
        var ids = self2._howls[i2]._getSoundIds();
        for (var j2 = 0; j2 < ids.length; j2++) {
          var sound = self2._howls[i2]._soundById(ids[j2]);
          if (sound && sound._node) {
            sound._node.muted = muted ? true : sound._muted;
          }
        }
      }
    }
    return self2;
  },
  /**
   * Handle stopping all sounds globally.
   */
  stop: function() {
    var self2 = this || Howler;
    for (var i2 = 0; i2 < self2._howls.length; i2++) {
      self2._howls[i2].stop();
    }
    return self2;
  },
  /**
   * Unload and destroy all currently loaded Howl objects.
   * @return {Howler}
   */
  unload: function() {
    var self2 = this || Howler;
    for (var i2 = self2._howls.length - 1; i2 >= 0; i2--) {
      self2._howls[i2].unload();
    }
    if (self2.usingWebAudio && self2.ctx && typeof self2.ctx.close !== "undefined") {
      self2.ctx.close();
      self2.ctx = null;
      setupAudioContext();
    }
    return self2;
  },
  /**
   * Check for codec support of specific extension.
   * @param  {String} ext Audio file extention.
   * @return {Boolean}
   */
  codecs: function(ext) {
    return (this || Howler)._codecs[ext.replace(/^x-/, "")];
  },
  /**
   * Setup various state values for global tracking.
   * @return {Howler}
   */
  _setup: function() {
    var self2 = this || Howler;
    self2.state = self2.ctx ? self2.ctx.state || "suspended" : "suspended";
    self2._autoSuspend();
    if (!self2.usingWebAudio) {
      if (typeof Audio !== "undefined") {
        try {
          var test = new Audio();
          if (typeof test.oncanplaythrough === "undefined") {
            self2._canPlayEvent = "canplay";
          }
        } catch (e2) {
          self2.noAudio = true;
        }
      } else {
        self2.noAudio = true;
      }
    }
    try {
      var test = new Audio();
      if (test.muted) {
        self2.noAudio = true;
      }
    } catch (e2) {
    }
    if (!self2.noAudio) {
      self2._setupCodecs();
    }
    return self2;
  },
  /**
   * Check for browser support for various codecs and cache the results.
   * @return {Howler}
   */
  _setupCodecs: function() {
    var self2 = this || Howler;
    var audioTest = null;
    try {
      audioTest = typeof Audio !== "undefined" ? new Audio() : null;
    } catch (err) {
      return self2;
    }
    if (!audioTest || typeof audioTest.canPlayType !== "function") {
      return self2;
    }
    var mpegTest = audioTest.canPlayType("audio/mpeg;").replace(/^no$/, "");
    var ua = self2._navigator ? self2._navigator.userAgent : "";
    var checkOpera = ua.match(/OPR\/([0-6].)/g);
    var isOldOpera = checkOpera && parseInt(checkOpera[0].split("/")[1], 10) < 33;
    var checkSafari = ua.indexOf("Safari") !== -1 && ua.indexOf("Chrome") === -1;
    var safariVersion = ua.match(/Version\/(.*?) /);
    var isOldSafari = checkSafari && safariVersion && parseInt(safariVersion[1], 10) < 15;
    self2._codecs = {
      mp3: !!(!isOldOpera && (mpegTest || audioTest.canPlayType("audio/mp3;").replace(/^no$/, ""))),
      mpeg: !!mpegTest,
      opus: !!audioTest.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""),
      ogg: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
      oga: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
      wav: !!(audioTest.canPlayType('audio/wav; codecs="1"') || audioTest.canPlayType("audio/wav")).replace(/^no$/, ""),
      aac: !!audioTest.canPlayType("audio/aac;").replace(/^no$/, ""),
      caf: !!audioTest.canPlayType("audio/x-caf;").replace(/^no$/, ""),
      m4a: !!(audioTest.canPlayType("audio/x-m4a;") || audioTest.canPlayType("audio/m4a;") || audioTest.canPlayType("audio/aac;")).replace(/^no$/, ""),
      m4b: !!(audioTest.canPlayType("audio/x-m4b;") || audioTest.canPlayType("audio/m4b;") || audioTest.canPlayType("audio/aac;")).replace(/^no$/, ""),
      mp4: !!(audioTest.canPlayType("audio/x-mp4;") || audioTest.canPlayType("audio/mp4;") || audioTest.canPlayType("audio/aac;")).replace(/^no$/, ""),
      weba: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
      webm: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
      dolby: !!audioTest.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ""),
      flac: !!(audioTest.canPlayType("audio/x-flac;") || audioTest.canPlayType("audio/flac;")).replace(/^no$/, "")
    };
    return self2;
  },
  /**
   * Some browsers/devices will only allow audio to be played after a user interaction.
   * Attempt to automatically unlock audio on the first user interaction.
   * Concept from: http://paulbakaus.com/tutorials/html5/web-audio-on-ios/
   * @return {Howler}
   */
  _unlockAudio: function() {
    var self2 = this || Howler;
    if (self2._audioUnlocked || !self2.ctx) {
      return;
    }
    self2._audioUnlocked = false;
    self2.autoUnlock = false;
    if (!self2._mobileUnloaded && self2.ctx.sampleRate !== 44100) {
      self2._mobileUnloaded = true;
      self2.unload();
    }
    self2._scratchBuffer = self2.ctx.createBuffer(1, 1, 22050);
    var unlock = function(e2) {
      while (self2._html5AudioPool.length < self2.html5PoolSize) {
        try {
          var audioNode = new Audio();
          audioNode._unlocked = true;
          self2._releaseHtml5Audio(audioNode);
        } catch (e3) {
          self2.noAudio = true;
          break;
        }
      }
      for (var i2 = 0; i2 < self2._howls.length; i2++) {
        if (!self2._howls[i2]._webAudio) {
          var ids = self2._howls[i2]._getSoundIds();
          for (var j2 = 0; j2 < ids.length; j2++) {
            var sound = self2._howls[i2]._soundById(ids[j2]);
            if (sound && sound._node && !sound._node._unlocked) {
              sound._node._unlocked = true;
              sound._node.load();
            }
          }
        }
      }
      self2._autoResume();
      var source = self2.ctx.createBufferSource();
      source.buffer = self2._scratchBuffer;
      source.connect(self2.ctx.destination);
      if (typeof source.start === "undefined") {
        source.noteOn(0);
      } else {
        source.start(0);
      }
      if (typeof self2.ctx.resume === "function") {
        self2.ctx.resume();
      }
      source.onended = function() {
        source.disconnect(0);
        self2._audioUnlocked = true;
        document.removeEventListener("touchstart", unlock, true);
        document.removeEventListener("touchend", unlock, true);
        document.removeEventListener("click", unlock, true);
        document.removeEventListener("keydown", unlock, true);
        for (var i3 = 0; i3 < self2._howls.length; i3++) {
          self2._howls[i3]._emit("unlock");
        }
      };
    };
    document.addEventListener("touchstart", unlock, true);
    document.addEventListener("touchend", unlock, true);
    document.addEventListener("click", unlock, true);
    document.addEventListener("keydown", unlock, true);
    return self2;
  },
  /**
   * Get an unlocked HTML5 Audio object from the pool. If none are left,
   * return a new Audio object and throw a warning.
   * @return {Audio} HTML5 Audio object.
   */
  _obtainHtml5Audio: function() {
    var self2 = this || Howler;
    if (self2._html5AudioPool.length) {
      return self2._html5AudioPool.pop();
    }
    var testPlay = new Audio().play();
    if (testPlay && typeof Promise !== "undefined" && (testPlay instanceof Promise || typeof testPlay.then === "function")) {
      testPlay.catch(function() {
        console.warn("HTML5 Audio pool exhausted, returning potentially locked audio object.");
      });
    }
    return new Audio();
  },
  /**
   * Return an activated HTML5 Audio object to the pool.
   * @return {Howler}
   */
  _releaseHtml5Audio: function(audio) {
    var self2 = this || Howler;
    if (audio._unlocked) {
      self2._html5AudioPool.push(audio);
    }
    return self2;
  },
  /**
   * Automatically suspend the Web Audio AudioContext after no sound has played for 30 seconds.
   * This saves processing/energy and fixes various browser-specific bugs with audio getting stuck.
   * @return {Howler}
   */
  _autoSuspend: function() {
    var self2 = this;
    if (!self2.autoSuspend || !self2.ctx || typeof self2.ctx.suspend === "undefined" || !Howler.usingWebAudio) {
      return;
    }
    for (var i2 = 0; i2 < self2._howls.length; i2++) {
      if (self2._howls[i2]._webAudio) {
        for (var j2 = 0; j2 < self2._howls[i2]._sounds.length; j2++) {
          if (!self2._howls[i2]._sounds[j2]._paused) {
            return self2;
          }
        }
      }
    }
    if (self2._suspendTimer) {
      clearTimeout(self2._suspendTimer);
    }
    self2._suspendTimer = setTimeout(function() {
      if (!self2.autoSuspend) {
        return;
      }
      self2._suspendTimer = null;
      self2.state = "suspending";
      var handleSuspension = function() {
        self2.state = "suspended";
        if (self2._resumeAfterSuspend) {
          delete self2._resumeAfterSuspend;
          self2._autoResume();
        }
      };
      self2.ctx.suspend().then(handleSuspension, handleSuspension);
    }, 3e4);
    return self2;
  },
  /**
   * Automatically resume the Web Audio AudioContext when a new sound is played.
   * @return {Howler}
   */
  _autoResume: function() {
    var self2 = this;
    if (!self2.ctx || typeof self2.ctx.resume === "undefined" || !Howler.usingWebAudio) {
      return;
    }
    if (self2.state === "running" && self2.ctx.state !== "interrupted" && self2._suspendTimer) {
      clearTimeout(self2._suspendTimer);
      self2._suspendTimer = null;
    } else if (self2.state === "suspended" || self2.state === "running" && self2.ctx.state === "interrupted") {
      self2.ctx.resume().then(function() {
        self2.state = "running";
        for (var i2 = 0; i2 < self2._howls.length; i2++) {
          self2._howls[i2]._emit("resume");
        }
      });
      if (self2._suspendTimer) {
        clearTimeout(self2._suspendTimer);
        self2._suspendTimer = null;
      }
    } else if (self2.state === "suspending") {
      self2._resumeAfterSuspend = true;
    }
    return self2;
  }
};
var Howler = new HowlerGlobal();
var Howl = function(o3) {
  var self2 = this;
  if (!o3.src || o3.src.length === 0) {
    console.error("An array of source files must be passed with any new Howl.");
    return;
  }
  self2.init(o3);
};
Howl.prototype = {
  /**
   * Initialize a new Howl group object.
   * @param  {Object} o Passed in properties for this group.
   * @return {Howl}
   */
  init: function(o3) {
    var self2 = this;
    if (!Howler.ctx) {
      setupAudioContext();
    }
    self2._autoplay = o3.autoplay || false;
    self2._format = typeof o3.format !== "string" ? o3.format : [o3.format];
    self2._html5 = o3.html5 || false;
    self2._muted = o3.mute || false;
    self2._loop = o3.loop || false;
    self2._pool = o3.pool || 5;
    self2._preload = typeof o3.preload === "boolean" || o3.preload === "metadata" ? o3.preload : true;
    self2._rate = o3.rate || 1;
    self2._sprite = o3.sprite || {};
    self2._src = typeof o3.src !== "string" ? o3.src : [o3.src];
    self2._volume = o3.volume !== void 0 ? o3.volume : 1;
    self2._xhr = {
      method: o3.xhr && o3.xhr.method ? o3.xhr.method : "GET",
      headers: o3.xhr && o3.xhr.headers ? o3.xhr.headers : null,
      withCredentials: o3.xhr && o3.xhr.withCredentials ? o3.xhr.withCredentials : false
    };
    self2._duration = 0;
    self2._state = "unloaded";
    self2._sounds = [];
    self2._endTimers = {};
    self2._queue = [];
    self2._playLock = false;
    self2._onend = o3.onend ? [{ fn: o3.onend }] : [];
    self2._onfade = o3.onfade ? [{ fn: o3.onfade }] : [];
    self2._onload = o3.onload ? [{ fn: o3.onload }] : [];
    self2._onloaderror = o3.onloaderror ? [{ fn: o3.onloaderror }] : [];
    self2._onplayerror = o3.onplayerror ? [{ fn: o3.onplayerror }] : [];
    self2._onpause = o3.onpause ? [{ fn: o3.onpause }] : [];
    self2._onplay = o3.onplay ? [{ fn: o3.onplay }] : [];
    self2._onstop = o3.onstop ? [{ fn: o3.onstop }] : [];
    self2._onmute = o3.onmute ? [{ fn: o3.onmute }] : [];
    self2._onvolume = o3.onvolume ? [{ fn: o3.onvolume }] : [];
    self2._onrate = o3.onrate ? [{ fn: o3.onrate }] : [];
    self2._onseek = o3.onseek ? [{ fn: o3.onseek }] : [];
    self2._onunlock = o3.onunlock ? [{ fn: o3.onunlock }] : [];
    self2._onresume = [];
    self2._webAudio = Howler.usingWebAudio && !self2._html5;
    if (typeof Howler.ctx !== "undefined" && Howler.ctx && Howler.autoUnlock) {
      Howler._unlockAudio();
    }
    Howler._howls.push(self2);
    if (self2._autoplay) {
      self2._queue.push({
        event: "play",
        action: function() {
          self2.play();
        }
      });
    }
    if (self2._preload && self2._preload !== "none") {
      self2.load();
    }
    return self2;
  },
  /**
   * Load the audio file.
   * @return {Howler}
   */
  load: function() {
    var self2 = this;
    var url = null;
    if (Howler.noAudio) {
      self2._emit("loaderror", null, "No audio support.");
      return;
    }
    if (typeof self2._src === "string") {
      self2._src = [self2._src];
    }
    for (var i2 = 0; i2 < self2._src.length; i2++) {
      var ext, str;
      if (self2._format && self2._format[i2]) {
        ext = self2._format[i2];
      } else {
        str = self2._src[i2];
        if (typeof str !== "string") {
          self2._emit("loaderror", null, "Non-string found in selected audio sources - ignoring.");
          continue;
        }
        ext = /^data:audio\/([^;,]+);/i.exec(str);
        if (!ext) {
          ext = /\.([^.]+)$/.exec(str.split("?", 1)[0]);
        }
        if (ext) {
          ext = ext[1].toLowerCase();
        }
      }
      if (!ext) {
        console.warn('No file extension was found. Consider using the "format" property or specify an extension.');
      }
      if (ext && Howler.codecs(ext)) {
        url = self2._src[i2];
        break;
      }
    }
    if (!url) {
      self2._emit("loaderror", null, "No codec support for selected audio sources.");
      return;
    }
    self2._src = url;
    self2._state = "loading";
    if (window.location.protocol === "https:" && url.slice(0, 5) === "http:") {
      self2._html5 = true;
      self2._webAudio = false;
    }
    new Sound(self2);
    if (self2._webAudio) {
      loadBuffer(self2);
    }
    return self2;
  },
  /**
   * Play a sound or resume previous playback.
   * @param  {String/Number} sprite   Sprite name for sprite playback or sound id to continue previous.
   * @param  {Boolean} internal Internal Use: true prevents event firing.
   * @return {Number}          Sound ID.
   */
  play: function(sprite, internal) {
    var self2 = this;
    var id = null;
    if (typeof sprite === "number") {
      id = sprite;
      sprite = null;
    } else if (typeof sprite === "string" && self2._state === "loaded" && !self2._sprite[sprite]) {
      return null;
    } else if (typeof sprite === "undefined") {
      sprite = "__default";
      if (!self2._playLock) {
        var num = 0;
        for (var i2 = 0; i2 < self2._sounds.length; i2++) {
          if (self2._sounds[i2]._paused && !self2._sounds[i2]._ended) {
            num++;
            id = self2._sounds[i2]._id;
          }
        }
        if (num === 1) {
          sprite = null;
        } else {
          id = null;
        }
      }
    }
    var sound = id ? self2._soundById(id) : self2._inactiveSound();
    if (!sound) {
      return null;
    }
    if (id && !sprite) {
      sprite = sound._sprite || "__default";
    }
    if (self2._state !== "loaded") {
      sound._sprite = sprite;
      sound._ended = false;
      var soundId = sound._id;
      self2._queue.push({
        event: "play",
        action: function() {
          self2.play(soundId);
        }
      });
      return soundId;
    }
    if (id && !sound._paused) {
      if (!internal) {
        self2._loadQueue("play");
      }
      return sound._id;
    }
    if (self2._webAudio) {
      Howler._autoResume();
    }
    var seek = Math.max(0, sound._seek > 0 ? sound._seek : self2._sprite[sprite][0] / 1e3);
    var duration = Math.max(0, (self2._sprite[sprite][0] + self2._sprite[sprite][1]) / 1e3 - seek);
    var timeout = duration * 1e3 / Math.abs(sound._rate);
    var start = self2._sprite[sprite][0] / 1e3;
    var stop = (self2._sprite[sprite][0] + self2._sprite[sprite][1]) / 1e3;
    sound._sprite = sprite;
    sound._ended = false;
    var setParams = function() {
      sound._paused = false;
      sound._seek = seek;
      sound._start = start;
      sound._stop = stop;
      sound._loop = !!(sound._loop || self2._sprite[sprite][2]);
    };
    if (seek >= stop) {
      self2._ended(sound);
      return;
    }
    var node = sound._node;
    if (self2._webAudio) {
      var playWebAudio = function() {
        self2._playLock = false;
        setParams();
        self2._refreshBuffer(sound);
        var vol = sound._muted || self2._muted ? 0 : sound._volume;
        node.gain.setValueAtTime(vol, Howler.ctx.currentTime);
        sound._playStart = Howler.ctx.currentTime;
        if (typeof node.bufferSource.start === "undefined") {
          sound._loop ? node.bufferSource.noteGrainOn(0, seek, 86400) : node.bufferSource.noteGrainOn(0, seek, duration);
        } else {
          sound._loop ? node.bufferSource.start(0, seek, 86400) : node.bufferSource.start(0, seek, duration);
        }
        if (timeout !== Infinity) {
          self2._endTimers[sound._id] = setTimeout(self2._ended.bind(self2, sound), timeout);
        }
        if (!internal) {
          setTimeout(function() {
            self2._emit("play", sound._id);
            self2._loadQueue();
          }, 0);
        }
      };
      if (Howler.state === "running" && Howler.ctx.state !== "interrupted") {
        playWebAudio();
      } else {
        self2._playLock = true;
        self2.once("resume", playWebAudio);
        self2._clearTimer(sound._id);
      }
    } else {
      var playHtml5 = function() {
        node.currentTime = seek;
        node.muted = sound._muted || self2._muted || Howler._muted || node.muted;
        node.volume = sound._volume * Howler.volume();
        node.playbackRate = sound._rate;
        try {
          var play = node.play();
          if (play && typeof Promise !== "undefined" && (play instanceof Promise || typeof play.then === "function")) {
            self2._playLock = true;
            setParams();
            play.then(function() {
              self2._playLock = false;
              node._unlocked = true;
              if (!internal) {
                self2._emit("play", sound._id);
              } else {
                self2._loadQueue();
              }
            }).catch(function() {
              self2._playLock = false;
              self2._emit("playerror", sound._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
              sound._ended = true;
              sound._paused = true;
            });
          } else if (!internal) {
            self2._playLock = false;
            setParams();
            self2._emit("play", sound._id);
          }
          node.playbackRate = sound._rate;
          if (node.paused) {
            self2._emit("playerror", sound._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
            return;
          }
          if (sprite !== "__default" || sound._loop) {
            self2._endTimers[sound._id] = setTimeout(self2._ended.bind(self2, sound), timeout);
          } else {
            self2._endTimers[sound._id] = function() {
              self2._ended(sound);
              node.removeEventListener("ended", self2._endTimers[sound._id], false);
            };
            node.addEventListener("ended", self2._endTimers[sound._id], false);
          }
        } catch (err) {
          self2._emit("playerror", sound._id, err);
        }
      };
      if (node.src === "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA") {
        node.src = self2._src;
        node.load();
      }
      var loadedNoReadyState = window && window.ejecta || !node.readyState && Howler._navigator.isCocoonJS;
      if (node.readyState >= 3 || loadedNoReadyState) {
        playHtml5();
      } else {
        self2._playLock = true;
        self2._state = "loading";
        var listener = function() {
          self2._state = "loaded";
          playHtml5();
          node.removeEventListener(Howler._canPlayEvent, listener, false);
        };
        node.addEventListener(Howler._canPlayEvent, listener, false);
        self2._clearTimer(sound._id);
      }
    }
    return sound._id;
  },
  /**
   * Pause playback and save current position.
   * @param  {Number} id The sound ID (empty to pause all in group).
   * @return {Howl}
   */
  pause: function(id) {
    var self2 = this;
    if (self2._state !== "loaded" || self2._playLock) {
      self2._queue.push({
        event: "pause",
        action: function() {
          self2.pause(id);
        }
      });
      return self2;
    }
    var ids = self2._getSoundIds(id);
    for (var i2 = 0; i2 < ids.length; i2++) {
      self2._clearTimer(ids[i2]);
      var sound = self2._soundById(ids[i2]);
      if (sound && !sound._paused) {
        sound._seek = self2.seek(ids[i2]);
        sound._rateSeek = 0;
        sound._paused = true;
        self2._stopFade(ids[i2]);
        if (sound._node) {
          if (self2._webAudio) {
            if (!sound._node.bufferSource) {
              continue;
            }
            if (typeof sound._node.bufferSource.stop === "undefined") {
              sound._node.bufferSource.noteOff(0);
            } else {
              sound._node.bufferSource.stop(0);
            }
            self2._cleanBuffer(sound._node);
          } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
            sound._node.pause();
          }
        }
      }
      if (!arguments[1]) {
        self2._emit("pause", sound ? sound._id : null);
      }
    }
    return self2;
  },
  /**
   * Stop playback and reset to start.
   * @param  {Number} id The sound ID (empty to stop all in group).
   * @param  {Boolean} internal Internal Use: true prevents event firing.
   * @return {Howl}
   */
  stop: function(id, internal) {
    var self2 = this;
    if (self2._state !== "loaded" || self2._playLock) {
      self2._queue.push({
        event: "stop",
        action: function() {
          self2.stop(id);
        }
      });
      return self2;
    }
    var ids = self2._getSoundIds(id);
    for (var i2 = 0; i2 < ids.length; i2++) {
      self2._clearTimer(ids[i2]);
      var sound = self2._soundById(ids[i2]);
      if (sound) {
        sound._seek = sound._start || 0;
        sound._rateSeek = 0;
        sound._paused = true;
        sound._ended = true;
        self2._stopFade(ids[i2]);
        if (sound._node) {
          if (self2._webAudio) {
            if (sound._node.bufferSource) {
              if (typeof sound._node.bufferSource.stop === "undefined") {
                sound._node.bufferSource.noteOff(0);
              } else {
                sound._node.bufferSource.stop(0);
              }
              self2._cleanBuffer(sound._node);
            }
          } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
            sound._node.currentTime = sound._start || 0;
            sound._node.pause();
            if (sound._node.duration === Infinity) {
              self2._clearSound(sound._node);
            }
          }
        }
        if (!internal) {
          self2._emit("stop", sound._id);
        }
      }
    }
    return self2;
  },
  /**
   * Mute/unmute a single sound or all sounds in this Howl group.
   * @param  {Boolean} muted Set to true to mute and false to unmute.
   * @param  {Number} id    The sound ID to update (omit to mute/unmute all).
   * @return {Howl}
   */
  mute: function(muted, id) {
    var self2 = this;
    if (self2._state !== "loaded" || self2._playLock) {
      self2._queue.push({
        event: "mute",
        action: function() {
          self2.mute(muted, id);
        }
      });
      return self2;
    }
    if (typeof id === "undefined") {
      if (typeof muted === "boolean") {
        self2._muted = muted;
      } else {
        return self2._muted;
      }
    }
    var ids = self2._getSoundIds(id);
    for (var i2 = 0; i2 < ids.length; i2++) {
      var sound = self2._soundById(ids[i2]);
      if (sound) {
        sound._muted = muted;
        if (sound._interval) {
          self2._stopFade(sound._id);
        }
        if (self2._webAudio && sound._node) {
          sound._node.gain.setValueAtTime(muted ? 0 : sound._volume, Howler.ctx.currentTime);
        } else if (sound._node) {
          sound._node.muted = Howler._muted ? true : muted;
        }
        self2._emit("mute", sound._id);
      }
    }
    return self2;
  },
  /**
   * Get/set the volume of this sound or of the Howl group. This method can optionally take 0, 1 or 2 arguments.
   *   volume() -> Returns the group's volume value.
   *   volume(id) -> Returns the sound id's current volume.
   *   volume(vol) -> Sets the volume of all sounds in this Howl group.
   *   volume(vol, id) -> Sets the volume of passed sound id.
   * @return {Howl/Number} Returns self or current volume.
   */
  volume: function() {
    var self2 = this;
    var args = arguments;
    var vol, id;
    if (args.length === 0) {
      return self2._volume;
    } else if (args.length === 1 || args.length === 2 && typeof args[1] === "undefined") {
      var ids = self2._getSoundIds();
      var index = ids.indexOf(args[0]);
      if (index >= 0) {
        id = parseInt(args[0], 10);
      } else {
        vol = parseFloat(args[0]);
      }
    } else if (args.length >= 2) {
      vol = parseFloat(args[0]);
      id = parseInt(args[1], 10);
    }
    var sound;
    if (typeof vol !== "undefined" && vol >= 0 && vol <= 1) {
      if (self2._state !== "loaded" || self2._playLock) {
        self2._queue.push({
          event: "volume",
          action: function() {
            self2.volume.apply(self2, args);
          }
        });
        return self2;
      }
      if (typeof id === "undefined") {
        self2._volume = vol;
      }
      id = self2._getSoundIds(id);
      for (var i2 = 0; i2 < id.length; i2++) {
        sound = self2._soundById(id[i2]);
        if (sound) {
          sound._volume = vol;
          if (!args[2]) {
            self2._stopFade(id[i2]);
          }
          if (self2._webAudio && sound._node && !sound._muted) {
            sound._node.gain.setValueAtTime(vol, Howler.ctx.currentTime);
          } else if (sound._node && !sound._muted) {
            sound._node.volume = vol * Howler.volume();
          }
          self2._emit("volume", sound._id);
        }
      }
    } else {
      sound = id ? self2._soundById(id) : self2._sounds[0];
      return sound ? sound._volume : 0;
    }
    return self2;
  },
  /**
   * Fade a currently playing sound between two volumes (if no id is passed, all sounds will fade).
   * @param  {Number} from The value to fade from (0.0 to 1.0).
   * @param  {Number} to   The volume to fade to (0.0 to 1.0).
   * @param  {Number} len  Time in milliseconds to fade.
   * @param  {Number} id   The sound id (omit to fade all sounds).
   * @return {Howl}
   */
  fade: function(from, to, len, id) {
    var self2 = this;
    if (self2._state !== "loaded" || self2._playLock) {
      self2._queue.push({
        event: "fade",
        action: function() {
          self2.fade(from, to, len, id);
        }
      });
      return self2;
    }
    from = Math.min(Math.max(0, parseFloat(from)), 1);
    to = Math.min(Math.max(0, parseFloat(to)), 1);
    len = parseFloat(len);
    self2.volume(from, id);
    var ids = self2._getSoundIds(id);
    for (var i2 = 0; i2 < ids.length; i2++) {
      var sound = self2._soundById(ids[i2]);
      if (sound) {
        if (!id) {
          self2._stopFade(ids[i2]);
        }
        if (self2._webAudio && !sound._muted) {
          var currentTime = Howler.ctx.currentTime;
          var end = currentTime + len / 1e3;
          sound._volume = from;
          sound._node.gain.setValueAtTime(from, currentTime);
          sound._node.gain.linearRampToValueAtTime(to, end);
        }
        self2._startFadeInterval(sound, from, to, len, ids[i2], typeof id === "undefined");
      }
    }
    return self2;
  },
  /**
   * Starts the internal interval to fade a sound.
   * @param  {Object} sound Reference to sound to fade.
   * @param  {Number} from The value to fade from (0.0 to 1.0).
   * @param  {Number} to   The volume to fade to (0.0 to 1.0).
   * @param  {Number} len  Time in milliseconds to fade.
   * @param  {Number} id   The sound id to fade.
   * @param  {Boolean} isGroup   If true, set the volume on the group.
   */
  _startFadeInterval: function(sound, from, to, len, id, isGroup) {
    var self2 = this;
    var vol = from;
    var diff = to - from;
    var steps = Math.abs(diff / 0.01);
    var stepLen = Math.max(4, steps > 0 ? len / steps : len);
    var lastTick = Date.now();
    sound._fadeTo = to;
    sound._interval = setInterval(function() {
      var tick = (Date.now() - lastTick) / len;
      lastTick = Date.now();
      vol += diff * tick;
      vol = Math.round(vol * 100) / 100;
      if (diff < 0) {
        vol = Math.max(to, vol);
      } else {
        vol = Math.min(to, vol);
      }
      if (self2._webAudio) {
        sound._volume = vol;
      } else {
        self2.volume(vol, sound._id, true);
      }
      if (isGroup) {
        self2._volume = vol;
      }
      if (to < from && vol <= to || to > from && vol >= to) {
        clearInterval(sound._interval);
        sound._interval = null;
        sound._fadeTo = null;
        self2.volume(to, sound._id);
        self2._emit("fade", sound._id);
      }
    }, stepLen);
  },
  /**
   * Internal method that stops the currently playing fade when
   * a new fade starts, volume is changed or the sound is stopped.
   * @param  {Number} id The sound id.
   * @return {Howl}
   */
  _stopFade: function(id) {
    var self2 = this;
    var sound = self2._soundById(id);
    if (sound && sound._interval) {
      if (self2._webAudio) {
        sound._node.gain.cancelScheduledValues(Howler.ctx.currentTime);
      }
      clearInterval(sound._interval);
      sound._interval = null;
      self2.volume(sound._fadeTo, id);
      sound._fadeTo = null;
      self2._emit("fade", id);
    }
    return self2;
  },
  /**
   * Get/set the loop parameter on a sound. This method can optionally take 0, 1 or 2 arguments.
   *   loop() -> Returns the group's loop value.
   *   loop(id) -> Returns the sound id's loop value.
   *   loop(loop) -> Sets the loop value for all sounds in this Howl group.
   *   loop(loop, id) -> Sets the loop value of passed sound id.
   * @return {Howl/Boolean} Returns self or current loop value.
   */
  loop: function() {
    var self2 = this;
    var args = arguments;
    var loop, id, sound;
    if (args.length === 0) {
      return self2._loop;
    } else if (args.length === 1) {
      if (typeof args[0] === "boolean") {
        loop = args[0];
        self2._loop = loop;
      } else {
        sound = self2._soundById(parseInt(args[0], 10));
        return sound ? sound._loop : false;
      }
    } else if (args.length === 2) {
      loop = args[0];
      id = parseInt(args[1], 10);
    }
    var ids = self2._getSoundIds(id);
    for (var i2 = 0; i2 < ids.length; i2++) {
      sound = self2._soundById(ids[i2]);
      if (sound) {
        sound._loop = loop;
        if (self2._webAudio && sound._node && sound._node.bufferSource) {
          sound._node.bufferSource.loop = loop;
          if (loop) {
            sound._node.bufferSource.loopStart = sound._start || 0;
            sound._node.bufferSource.loopEnd = sound._stop;
            if (self2.playing(ids[i2])) {
              self2.pause(ids[i2], true);
              self2.play(ids[i2], true);
            }
          }
        }
      }
    }
    return self2;
  },
  /**
   * Get/set the playback rate of a sound. This method can optionally take 0, 1 or 2 arguments.
   *   rate() -> Returns the first sound node's current playback rate.
   *   rate(id) -> Returns the sound id's current playback rate.
   *   rate(rate) -> Sets the playback rate of all sounds in this Howl group.
   *   rate(rate, id) -> Sets the playback rate of passed sound id.
   * @return {Howl/Number} Returns self or the current playback rate.
   */
  rate: function() {
    var self2 = this;
    var args = arguments;
    var rate, id;
    if (args.length === 0) {
      id = self2._sounds[0]._id;
    } else if (args.length === 1) {
      var ids = self2._getSoundIds();
      var index = ids.indexOf(args[0]);
      if (index >= 0) {
        id = parseInt(args[0], 10);
      } else {
        rate = parseFloat(args[0]);
      }
    } else if (args.length === 2) {
      rate = parseFloat(args[0]);
      id = parseInt(args[1], 10);
    }
    var sound;
    if (typeof rate === "number") {
      if (self2._state !== "loaded" || self2._playLock) {
        self2._queue.push({
          event: "rate",
          action: function() {
            self2.rate.apply(self2, args);
          }
        });
        return self2;
      }
      if (typeof id === "undefined") {
        self2._rate = rate;
      }
      id = self2._getSoundIds(id);
      for (var i2 = 0; i2 < id.length; i2++) {
        sound = self2._soundById(id[i2]);
        if (sound) {
          if (self2.playing(id[i2])) {
            sound._rateSeek = self2.seek(id[i2]);
            sound._playStart = self2._webAudio ? Howler.ctx.currentTime : sound._playStart;
          }
          sound._rate = rate;
          if (self2._webAudio && sound._node && sound._node.bufferSource) {
            sound._node.bufferSource.playbackRate.setValueAtTime(rate, Howler.ctx.currentTime);
          } else if (sound._node) {
            sound._node.playbackRate = rate;
          }
          var seek = self2.seek(id[i2]);
          var duration = (self2._sprite[sound._sprite][0] + self2._sprite[sound._sprite][1]) / 1e3 - seek;
          var timeout = duration * 1e3 / Math.abs(sound._rate);
          if (self2._endTimers[id[i2]] || !sound._paused) {
            self2._clearTimer(id[i2]);
            self2._endTimers[id[i2]] = setTimeout(self2._ended.bind(self2, sound), timeout);
          }
          self2._emit("rate", sound._id);
        }
      }
    } else {
      sound = self2._soundById(id);
      return sound ? sound._rate : self2._rate;
    }
    return self2;
  },
  /**
   * Get/set the seek position of a sound. This method can optionally take 0, 1 or 2 arguments.
   *   seek() -> Returns the first sound node's current seek position.
   *   seek(id) -> Returns the sound id's current seek position.
   *   seek(seek) -> Sets the seek position of the first sound node.
   *   seek(seek, id) -> Sets the seek position of passed sound id.
   * @return {Howl/Number} Returns self or the current seek position.
   */
  seek: function() {
    var self2 = this;
    var args = arguments;
    var seek, id;
    if (args.length === 0) {
      if (self2._sounds.length) {
        id = self2._sounds[0]._id;
      }
    } else if (args.length === 1) {
      var ids = self2._getSoundIds();
      var index = ids.indexOf(args[0]);
      if (index >= 0) {
        id = parseInt(args[0], 10);
      } else if (self2._sounds.length) {
        id = self2._sounds[0]._id;
        seek = parseFloat(args[0]);
      }
    } else if (args.length === 2) {
      seek = parseFloat(args[0]);
      id = parseInt(args[1], 10);
    }
    if (typeof id === "undefined") {
      return 0;
    }
    if (typeof seek === "number" && (self2._state !== "loaded" || self2._playLock)) {
      self2._queue.push({
        event: "seek",
        action: function() {
          self2.seek.apply(self2, args);
        }
      });
      return self2;
    }
    var sound = self2._soundById(id);
    if (sound) {
      if (typeof seek === "number" && seek >= 0) {
        var playing = self2.playing(id);
        if (playing) {
          self2.pause(id, true);
        }
        sound._seek = seek;
        sound._ended = false;
        self2._clearTimer(id);
        if (!self2._webAudio && sound._node && !isNaN(sound._node.duration)) {
          sound._node.currentTime = seek;
        }
        var seekAndEmit = function() {
          if (playing) {
            self2.play(id, true);
          }
          self2._emit("seek", id);
        };
        if (playing && !self2._webAudio) {
          var emitSeek = function() {
            if (!self2._playLock) {
              seekAndEmit();
            } else {
              setTimeout(emitSeek, 0);
            }
          };
          setTimeout(emitSeek, 0);
        } else {
          seekAndEmit();
        }
      } else {
        if (self2._webAudio) {
          var realTime = self2.playing(id) ? Howler.ctx.currentTime - sound._playStart : 0;
          var rateSeek = sound._rateSeek ? sound._rateSeek - sound._seek : 0;
          return sound._seek + (rateSeek + realTime * Math.abs(sound._rate));
        } else {
          return sound._node.currentTime;
        }
      }
    }
    return self2;
  },
  /**
   * Check if a specific sound is currently playing or not (if id is provided), or check if at least one of the sounds in the group is playing or not.
   * @param  {Number}  id The sound id to check. If none is passed, the whole sound group is checked.
   * @return {Boolean} True if playing and false if not.
   */
  playing: function(id) {
    var self2 = this;
    if (typeof id === "number") {
      var sound = self2._soundById(id);
      return sound ? !sound._paused : false;
    }
    for (var i2 = 0; i2 < self2._sounds.length; i2++) {
      if (!self2._sounds[i2]._paused) {
        return true;
      }
    }
    return false;
  },
  /**
   * Get the duration of this sound. Passing a sound id will return the sprite duration.
   * @param  {Number} id The sound id to check. If none is passed, return full source duration.
   * @return {Number} Audio duration in seconds.
   */
  duration: function(id) {
    var self2 = this;
    var duration = self2._duration;
    var sound = self2._soundById(id);
    if (sound) {
      duration = self2._sprite[sound._sprite][1] / 1e3;
    }
    return duration;
  },
  /**
   * Returns the current loaded state of this Howl.
   * @return {String} 'unloaded', 'loading', 'loaded'
   */
  state: function() {
    return this._state;
  },
  /**
   * Unload and destroy the current Howl object.
   * This will immediately stop all sound instances attached to this group.
   */
  unload: function() {
    var self2 = this;
    var sounds = self2._sounds;
    for (var i2 = 0; i2 < sounds.length; i2++) {
      if (!sounds[i2]._paused) {
        self2.stop(sounds[i2]._id);
      }
      if (!self2._webAudio) {
        self2._clearSound(sounds[i2]._node);
        sounds[i2]._node.removeEventListener("error", sounds[i2]._errorFn, false);
        sounds[i2]._node.removeEventListener(Howler._canPlayEvent, sounds[i2]._loadFn, false);
        sounds[i2]._node.removeEventListener("ended", sounds[i2]._endFn, false);
        Howler._releaseHtml5Audio(sounds[i2]._node);
      }
      delete sounds[i2]._node;
      self2._clearTimer(sounds[i2]._id);
    }
    var index = Howler._howls.indexOf(self2);
    if (index >= 0) {
      Howler._howls.splice(index, 1);
    }
    var remCache = true;
    for (i2 = 0; i2 < Howler._howls.length; i2++) {
      if (Howler._howls[i2]._src === self2._src || self2._src.indexOf(Howler._howls[i2]._src) >= 0) {
        remCache = false;
        break;
      }
    }
    if (cache && remCache) {
      delete cache[self2._src];
    }
    Howler.noAudio = false;
    self2._state = "unloaded";
    self2._sounds = [];
    self2 = null;
    return null;
  },
  /**
   * Listen to a custom event.
   * @param  {String}   event Event name.
   * @param  {Function} fn    Listener to call.
   * @param  {Number}   id    (optional) Only listen to events for this sound.
   * @param  {Number}   once  (INTERNAL) Marks event to fire only once.
   * @return {Howl}
   */
  on: function(event, fn, id, once) {
    var self2 = this;
    var events = self2["_on" + event];
    if (typeof fn === "function") {
      events.push(once ? { id, fn, once } : { id, fn });
    }
    return self2;
  },
  /**
   * Remove a custom event. Call without parameters to remove all events.
   * @param  {String}   event Event name.
   * @param  {Function} fn    Listener to remove. Leave empty to remove all.
   * @param  {Number}   id    (optional) Only remove events for this sound.
   * @return {Howl}
   */
  off: function(event, fn, id) {
    var self2 = this;
    var events = self2["_on" + event];
    var i2 = 0;
    if (typeof fn === "number") {
      id = fn;
      fn = null;
    }
    if (fn || id) {
      for (i2 = 0; i2 < events.length; i2++) {
        var isId = id === events[i2].id;
        if (fn === events[i2].fn && isId || !fn && isId) {
          events.splice(i2, 1);
          break;
        }
      }
    } else if (event) {
      self2["_on" + event] = [];
    } else {
      var keys = Object.keys(self2);
      for (i2 = 0; i2 < keys.length; i2++) {
        if (keys[i2].indexOf("_on") === 0 && Array.isArray(self2[keys[i2]])) {
          self2[keys[i2]] = [];
        }
      }
    }
    return self2;
  },
  /**
   * Listen to a custom event and remove it once fired.
   * @param  {String}   event Event name.
   * @param  {Function} fn    Listener to call.
   * @param  {Number}   id    (optional) Only listen to events for this sound.
   * @return {Howl}
   */
  once: function(event, fn, id) {
    var self2 = this;
    self2.on(event, fn, id, 1);
    return self2;
  },
  /**
   * Emit all events of a specific type and pass the sound id.
   * @param  {String} event Event name.
   * @param  {Number} id    Sound ID.
   * @param  {Number} msg   Message to go with event.
   * @return {Howl}
   */
  _emit: function(event, id, msg) {
    var self2 = this;
    var events = self2["_on" + event];
    for (var i2 = events.length - 1; i2 >= 0; i2--) {
      if (!events[i2].id || events[i2].id === id || event === "load") {
        setTimeout((function(fn) {
          fn.call(this, id, msg);
        }).bind(self2, events[i2].fn), 0);
        if (events[i2].once) {
          self2.off(event, events[i2].fn, events[i2].id);
        }
      }
    }
    self2._loadQueue(event);
    return self2;
  },
  /**
   * Queue of actions initiated before the sound has loaded.
   * These will be called in sequence, with the next only firing
   * after the previous has finished executing (even if async like play).
   * @return {Howl}
   */
  _loadQueue: function(event) {
    var self2 = this;
    if (self2._queue.length > 0) {
      var task = self2._queue[0];
      if (task.event === event) {
        self2._queue.shift();
        self2._loadQueue();
      }
      if (!event) {
        task.action();
      }
    }
    return self2;
  },
  /**
   * Fired when playback ends at the end of the duration.
   * @param  {Sound} sound The sound object to work with.
   * @return {Howl}
   */
  _ended: function(sound) {
    var self2 = this;
    var sprite = sound._sprite;
    if (!self2._webAudio && sound._node && !sound._node.paused && !sound._node.ended && sound._node.currentTime < sound._stop) {
      setTimeout(self2._ended.bind(self2, sound), 100);
      return self2;
    }
    var loop = !!(sound._loop || self2._sprite[sprite][2]);
    self2._emit("end", sound._id);
    if (!self2._webAudio && loop) {
      self2.stop(sound._id, true).play(sound._id);
    }
    if (self2._webAudio && loop) {
      self2._emit("play", sound._id);
      sound._seek = sound._start || 0;
      sound._rateSeek = 0;
      sound._playStart = Howler.ctx.currentTime;
      var timeout = (sound._stop - sound._start) * 1e3 / Math.abs(sound._rate);
      self2._endTimers[sound._id] = setTimeout(self2._ended.bind(self2, sound), timeout);
    }
    if (self2._webAudio && !loop) {
      sound._paused = true;
      sound._ended = true;
      sound._seek = sound._start || 0;
      sound._rateSeek = 0;
      self2._clearTimer(sound._id);
      self2._cleanBuffer(sound._node);
      Howler._autoSuspend();
    }
    if (!self2._webAudio && !loop) {
      self2.stop(sound._id, true);
    }
    return self2;
  },
  /**
   * Clear the end timer for a sound playback.
   * @param  {Number} id The sound ID.
   * @return {Howl}
   */
  _clearTimer: function(id) {
    var self2 = this;
    if (self2._endTimers[id]) {
      if (typeof self2._endTimers[id] !== "function") {
        clearTimeout(self2._endTimers[id]);
      } else {
        var sound = self2._soundById(id);
        if (sound && sound._node) {
          sound._node.removeEventListener("ended", self2._endTimers[id], false);
        }
      }
      delete self2._endTimers[id];
    }
    return self2;
  },
  /**
   * Return the sound identified by this ID, or return null.
   * @param  {Number} id Sound ID
   * @return {Object}    Sound object or null.
   */
  _soundById: function(id) {
    var self2 = this;
    for (var i2 = 0; i2 < self2._sounds.length; i2++) {
      if (id === self2._sounds[i2]._id) {
        return self2._sounds[i2];
      }
    }
    return null;
  },
  /**
   * Return an inactive sound from the pool or create a new one.
   * @return {Sound} Sound playback object.
   */
  _inactiveSound: function() {
    var self2 = this;
    self2._drain();
    for (var i2 = 0; i2 < self2._sounds.length; i2++) {
      if (self2._sounds[i2]._ended) {
        return self2._sounds[i2].reset();
      }
    }
    return new Sound(self2);
  },
  /**
   * Drain excess inactive sounds from the pool.
   */
  _drain: function() {
    var self2 = this;
    var limit = self2._pool;
    var cnt = 0;
    var i2 = 0;
    if (self2._sounds.length < limit) {
      return;
    }
    for (i2 = 0; i2 < self2._sounds.length; i2++) {
      if (self2._sounds[i2]._ended) {
        cnt++;
      }
    }
    for (i2 = self2._sounds.length - 1; i2 >= 0; i2--) {
      if (cnt <= limit) {
        return;
      }
      if (self2._sounds[i2]._ended) {
        if (self2._webAudio && self2._sounds[i2]._node) {
          self2._sounds[i2]._node.disconnect(0);
        }
        self2._sounds.splice(i2, 1);
        cnt--;
      }
    }
  },
  /**
   * Get all ID's from the sounds pool.
   * @param  {Number} id Only return one ID if one is passed.
   * @return {Array}    Array of IDs.
   */
  _getSoundIds: function(id) {
    var self2 = this;
    if (typeof id === "undefined") {
      var ids = [];
      for (var i2 = 0; i2 < self2._sounds.length; i2++) {
        ids.push(self2._sounds[i2]._id);
      }
      return ids;
    } else {
      return [id];
    }
  },
  /**
   * Load the sound back into the buffer source.
   * @param  {Sound} sound The sound object to work with.
   * @return {Howl}
   */
  _refreshBuffer: function(sound) {
    var self2 = this;
    sound._node.bufferSource = Howler.ctx.createBufferSource();
    sound._node.bufferSource.buffer = cache[self2._src];
    if (sound._panner) {
      sound._node.bufferSource.connect(sound._panner);
    } else {
      sound._node.bufferSource.connect(sound._node);
    }
    sound._node.bufferSource.loop = sound._loop;
    if (sound._loop) {
      sound._node.bufferSource.loopStart = sound._start || 0;
      sound._node.bufferSource.loopEnd = sound._stop || 0;
    }
    sound._node.bufferSource.playbackRate.setValueAtTime(sound._rate, Howler.ctx.currentTime);
    return self2;
  },
  /**
   * Prevent memory leaks by cleaning up the buffer source after playback.
   * @param  {Object} node Sound's audio node containing the buffer source.
   * @return {Howl}
   */
  _cleanBuffer: function(node) {
    var self2 = this;
    var isIOS = Howler._navigator && Howler._navigator.vendor.indexOf("Apple") >= 0;
    if (!node.bufferSource) {
      return self2;
    }
    if (Howler._scratchBuffer && node.bufferSource) {
      node.bufferSource.onended = null;
      node.bufferSource.disconnect(0);
      if (isIOS) {
        try {
          node.bufferSource.buffer = Howler._scratchBuffer;
        } catch (e2) {
        }
      }
    }
    node.bufferSource = null;
    return self2;
  },
  /**
   * Set the source to a 0-second silence to stop any downloading (except in IE).
   * @param  {Object} node Audio node to clear.
   */
  _clearSound: function(node) {
    var checkIE = /MSIE |Trident\//.test(Howler._navigator && Howler._navigator.userAgent);
    if (!checkIE) {
      node.src = "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA";
    }
  }
};
var Sound = function(howl) {
  this._parent = howl;
  this.init();
};
Sound.prototype = {
  /**
   * Initialize a new Sound object.
   * @return {Sound}
   */
  init: function() {
    var self2 = this;
    var parent = self2._parent;
    self2._muted = parent._muted;
    self2._loop = parent._loop;
    self2._volume = parent._volume;
    self2._rate = parent._rate;
    self2._seek = 0;
    self2._paused = true;
    self2._ended = true;
    self2._sprite = "__default";
    self2._id = ++Howler._counter;
    parent._sounds.push(self2);
    self2.create();
    return self2;
  },
  /**
   * Create and setup a new sound object, whether HTML5 Audio or Web Audio.
   * @return {Sound}
   */
  create: function() {
    var self2 = this;
    var parent = self2._parent;
    var volume = Howler._muted || self2._muted || self2._parent._muted ? 0 : self2._volume;
    if (parent._webAudio) {
      self2._node = typeof Howler.ctx.createGain === "undefined" ? Howler.ctx.createGainNode() : Howler.ctx.createGain();
      self2._node.gain.setValueAtTime(volume, Howler.ctx.currentTime);
      self2._node.paused = true;
      self2._node.connect(Howler.masterGain);
    } else if (!Howler.noAudio) {
      self2._node = Howler._obtainHtml5Audio();
      self2._errorFn = self2._errorListener.bind(self2);
      self2._node.addEventListener("error", self2._errorFn, false);
      self2._loadFn = self2._loadListener.bind(self2);
      self2._node.addEventListener(Howler._canPlayEvent, self2._loadFn, false);
      self2._endFn = self2._endListener.bind(self2);
      self2._node.addEventListener("ended", self2._endFn, false);
      self2._node.src = parent._src;
      self2._node.preload = parent._preload === true ? "auto" : parent._preload;
      self2._node.volume = volume * Howler.volume();
      self2._node.load();
    }
    return self2;
  },
  /**
   * Reset the parameters of this sound to the original state (for recycle).
   * @return {Sound}
   */
  reset: function() {
    var self2 = this;
    var parent = self2._parent;
    self2._muted = parent._muted;
    self2._loop = parent._loop;
    self2._volume = parent._volume;
    self2._rate = parent._rate;
    self2._seek = 0;
    self2._rateSeek = 0;
    self2._paused = true;
    self2._ended = true;
    self2._sprite = "__default";
    self2._id = ++Howler._counter;
    return self2;
  },
  /**
   * HTML5 Audio error listener callback.
   */
  _errorListener: function() {
    var self2 = this;
    self2._parent._emit("loaderror", self2._id, self2._node.error ? self2._node.error.code : 0);
    self2._node.removeEventListener("error", self2._errorFn, false);
  },
  /**
   * HTML5 Audio canplaythrough listener callback.
   */
  _loadListener: function() {
    var self2 = this;
    var parent = self2._parent;
    parent._duration = Math.ceil(self2._node.duration * 10) / 10;
    if (Object.keys(parent._sprite).length === 0) {
      parent._sprite = { __default: [0, parent._duration * 1e3] };
    }
    if (parent._state !== "loaded") {
      parent._state = "loaded";
      parent._emit("load");
      parent._loadQueue();
    }
    self2._node.removeEventListener(Howler._canPlayEvent, self2._loadFn, false);
  },
  /**
   * HTML5 Audio ended listener callback.
   */
  _endListener: function() {
    var self2 = this;
    var parent = self2._parent;
    if (parent._duration === Infinity) {
      parent._duration = Math.ceil(self2._node.duration * 10) / 10;
      if (parent._sprite.__default[1] === Infinity) {
        parent._sprite.__default[1] = parent._duration * 1e3;
      }
      parent._ended(self2);
    }
    self2._node.removeEventListener("ended", self2._endFn, false);
  }
};
var cache = {};
var loadBuffer = function(self2) {
  var url = self2._src;
  if (cache[url]) {
    self2._duration = cache[url].duration;
    loadSound(self2);
    return;
  }
  if (/^data:[^;]+;base64,/.test(url)) {
    var data = atob(url.split(",")[1]);
    var dataView = new Uint8Array(data.length);
    for (var i2 = 0; i2 < data.length; ++i2) {
      dataView[i2] = data.charCodeAt(i2);
    }
    decodeAudioData(dataView.buffer, self2);
  } else {
    var xhr = new XMLHttpRequest();
    xhr.open(self2._xhr.method, url, true);
    xhr.withCredentials = self2._xhr.withCredentials;
    xhr.responseType = "arraybuffer";
    if (self2._xhr.headers) {
      Object.keys(self2._xhr.headers).forEach(function(key) {
        xhr.setRequestHeader(key, self2._xhr.headers[key]);
      });
    }
    xhr.onload = function() {
      var code = (xhr.status + "")[0];
      if (code !== "0" && code !== "2" && code !== "3") {
        self2._emit("loaderror", null, "Failed loading audio file with status: " + xhr.status + ".");
        return;
      }
      decodeAudioData(xhr.response, self2);
    };
    xhr.onerror = function() {
      if (self2._webAudio) {
        self2._html5 = true;
        self2._webAudio = false;
        self2._sounds = [];
        delete cache[url];
        self2.load();
      }
    };
    safeXhrSend(xhr);
  }
};
var safeXhrSend = function(xhr) {
  try {
    xhr.send();
  } catch (e2) {
    xhr.onerror();
  }
};
var decodeAudioData = function(arraybuffer, self2) {
  var error = function() {
    self2._emit("loaderror", null, "Decoding audio data failed.");
  };
  var success = function(buffer) {
    if (buffer && self2._sounds.length > 0) {
      cache[self2._src] = buffer;
      loadSound(self2, buffer);
    } else {
      error();
    }
  };
  if (typeof Promise !== "undefined" && Howler.ctx.decodeAudioData.length === 1) {
    Howler.ctx.decodeAudioData(arraybuffer).then(success).catch(error);
  } else {
    Howler.ctx.decodeAudioData(arraybuffer, success, error);
  }
};
var loadSound = function(self2, buffer) {
  if (buffer && !self2._duration) {
    self2._duration = buffer.duration;
  }
  if (Object.keys(self2._sprite).length === 0) {
    self2._sprite = { __default: [0, self2._duration * 1e3] };
  }
  if (self2._state !== "loaded") {
    self2._state = "loaded";
    self2._emit("load");
    self2._loadQueue();
  }
};
var setupAudioContext = function() {
  if (!Howler.usingWebAudio) {
    return;
  }
  try {
    if (typeof AudioContext !== "undefined") {
      Howler.ctx = new AudioContext();
    } else if (typeof webkitAudioContext !== "undefined") {
      Howler.ctx = new webkitAudioContext();
    } else {
      Howler.usingWebAudio = false;
    }
  } catch (e2) {
    Howler.usingWebAudio = false;
  }
  if (!Howler.ctx) {
    Howler.usingWebAudio = false;
  }
  var iOS = /iP(hone|od|ad)/.test(Howler._navigator && Howler._navigator.platform);
  var appVersion = Howler._navigator && Howler._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/);
  var version = appVersion ? parseInt(appVersion[1], 10) : null;
  if (iOS && version && version < 9) {
    var safari = /safari/.test(Howler._navigator && Howler._navigator.userAgent.toLowerCase());
    if (Howler._navigator && !safari) {
      Howler.usingWebAudio = false;
    }
  }
  if (Howler.usingWebAudio) {
    Howler.masterGain = typeof Howler.ctx.createGain === "undefined" ? Howler.ctx.createGainNode() : Howler.ctx.createGain();
    Howler.masterGain.gain.setValueAtTime(Howler._muted ? 0 : Howler._volume, Howler.ctx.currentTime);
    Howler.masterGain.connect(Howler.ctx.destination);
  }
  Howler._setup();
};
spatial(HowlerGlobal, Howler, Howl, Sound);

// node_modules/dynamsoft-camera-enhancer/dist/dce.esm.js
var t = "undefined" == typeof self;
var e;
var i;
var r;
var n;
var s;
if ("undefined" != typeof navigator && (e = navigator, i = e.userAgent, r = e.platform, n = e.mediaDevices), !t) {
  const t2 = { Edge: { search: "Edg", verSearch: "Edg" }, OPR: null, Chrome: null, Safari: { str: e.vendor, search: "Apple", verSearch: ["Version", "iPhone OS", "CPU OS"] }, Firefox: null, Explorer: { search: "MSIE", verSearch: "MSIE" } }, n3 = { HarmonyOS: null, Android: null, iPhone: null, iPad: null, Windows: { str: r, search: "Win" }, Mac: { str: r }, Linux: { str: r } };
  let o3 = "unknownBrowser", a3 = 0, h3 = "unknownOS";
  for (let e2 in t2) {
    const r3 = t2[e2] || {};
    let n4 = r3.str || i, s3 = r3.search || e2, h4 = r3.verStr || i, l3 = r3.verSearch || e2;
    if (l3 instanceof Array || (l3 = [l3]), -1 != n4.indexOf(s3)) {
      o3 = e2;
      for (let t3 of l3) {
        let e3 = h4.indexOf(t3);
        if (-1 != e3) {
          a3 = parseFloat(h4.substring(e3 + t3.length + 1));
          break;
        }
      }
      break;
    }
  }
  for (let t3 in n3) {
    const e2 = n3[t3] || {};
    let r3 = e2.str || i, s3 = e2.search || t3;
    if (-1 != r3.indexOf(s3)) {
      h3 = t3;
      break;
    }
  }
  "Linux" == h3 && -1 != i.indexOf("Windows NT") && (h3 = "HarmonyOS"), s = { browser: o3, version: a3, OS: h3 };
}
t && (s = { browser: "ssr", version: 0, OS: "ssr" });
var o = "undefined" != typeof WebAssembly && i && !(/Safari/.test(i) && !/Chrome/.test(i) && /\(.+\s11_2_([2-6]).*\)/.test(i));
var a = !("undefined" == typeof Worker);
var h = !(!n || !n.getUserMedia);
var l = async () => {
  let t2 = false;
  if (h) try {
    (await n.getUserMedia({ video: true })).getTracks().forEach((t3) => {
      t3.stop();
    }), t2 = true;
  } catch (t3) {
  }
  return t2;
};
"Chrome" === s.browser && s.version > 66 || "Safari" === s.browser && s.version > 13 || "OPR" === s.browser && s.version > 43 || "Edge" === s.browser && s.version;
var c = (() => {
  if (!t && document.currentScript) {
    let t2 = document.currentScript.src, e2 = t2.indexOf("?");
    if (-1 != e2) t2 = t2.substring(0, e2);
    else {
      let e3 = t2.indexOf("#");
      -1 != e3 && (t2 = t2.substring(0, e3));
    }
    return t2.substring(0, t2.lastIndexOf("/") + 1);
  }
  return "./";
})();
var u = { 653: (t2, e2, i2) => {
  var r3, n3, s3, o3, a3, h3, l3, c3, u3, d3, f3, g3, p3, m3, v3, _3, y3, b3, w3, C3, S3, x3 = x3 || { version: "5.2.1" };
  if (e2.fabric = x3, "undefined" != typeof document && "undefined" != typeof window) document instanceof ("undefined" != typeof HTMLDocument ? HTMLDocument : Document) ? x3.document = document : x3.document = document.implementation.createHTMLDocument(""), x3.window = window;
  else {
    var T3 = new (i2(192)).JSDOM(decodeURIComponent("%3C!DOCTYPE%20html%3E%3Chtml%3E%3Chead%3E%3C%2Fhead%3E%3Cbody%3E%3C%2Fbody%3E%3C%2Fhtml%3E"), { features: { FetchExternalResources: ["img"] }, resources: "usable" }).window;
    x3.document = T3.document, x3.jsdomImplForWrapper = i2(898).implForWrapper, x3.nodeCanvas = i2(245).Canvas, x3.window = T3, DOMParser = x3.window.DOMParser;
  }
  function O3(t3, e3) {
    var i3 = t3.canvas, r4 = e3.targetCanvas, n4 = r4.getContext("2d");
    n4.translate(0, r4.height), n4.scale(1, -1);
    var s4 = i3.height - r4.height;
    n4.drawImage(i3, 0, s4, r4.width, r4.height, 0, 0, r4.width, r4.height);
  }
  function E3(t3, e3) {
    var i3 = e3.targetCanvas.getContext("2d"), r4 = e3.destinationWidth, n4 = e3.destinationHeight, s4 = r4 * n4 * 4, o4 = new Uint8Array(this.imageBuffer, 0, s4), a4 = new Uint8ClampedArray(this.imageBuffer, 0, s4);
    t3.readPixels(0, 0, r4, n4, t3.RGBA, t3.UNSIGNED_BYTE, o4);
    var h4 = new ImageData(a4, r4, n4);
    i3.putImageData(h4, 0, 0);
  }
  x3.isTouchSupported = "ontouchstart" in x3.window || "ontouchstart" in x3.document || x3.window && x3.window.navigator && x3.window.navigator.maxTouchPoints > 0, x3.isLikelyNode = "undefined" != typeof Buffer && "undefined" == typeof window, x3.SHARED_ATTRIBUTES = ["display", "transform", "fill", "fill-opacity", "fill-rule", "opacity", "stroke", "stroke-dasharray", "stroke-linecap", "stroke-dashoffset", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "id", "paint-order", "vector-effect", "instantiated_by_use", "clip-path"], x3.DPI = 96, x3.reNum = "(?:[-+]?(?:\\d+|\\d*\\.\\d+)(?:[eE][-+]?\\d+)?)", x3.commaWsp = "(?:\\s+,?\\s*|,\\s*)", x3.rePathCommand = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:[eE][-+]?\d+)?)/gi, x3.reNonWord = /[ \n\.,;!\?\-]/, x3.fontPaths = {}, x3.iMatrix = [1, 0, 0, 1, 0, 0], x3.svgNS = "http://www.w3.org/2000/svg", x3.perfLimitSizeTotal = 2097152, x3.maxCacheSideLimit = 4096, x3.minCacheSideLimit = 256, x3.charWidthsCache = {}, x3.textureSize = 2048, x3.disableStyleCopyPaste = false, x3.enableGLFiltering = true, x3.devicePixelRatio = x3.window.devicePixelRatio || x3.window.webkitDevicePixelRatio || x3.window.mozDevicePixelRatio || 1, x3.browserShadowBlurConstant = 1, x3.arcToSegmentsCache = {}, x3.boundsOfCurveCache = {}, x3.cachesBoundsOfCurve = true, x3.forceGLPutImageData = false, x3.initFilterBackend = function() {
    return x3.enableGLFiltering && x3.isWebglSupported && x3.isWebglSupported(x3.textureSize) ? (console.log("max texture size: " + x3.maxTextureSize), new x3.WebglFilterBackend({ tileSize: x3.textureSize })) : x3.Canvas2dFilterBackend ? new x3.Canvas2dFilterBackend() : void 0;
  }, "undefined" != typeof document && "undefined" != typeof window && (window.fabric = x3), function() {
    function t3(t4, e4) {
      if (this.__eventListeners[t4]) {
        var i3 = this.__eventListeners[t4];
        e4 ? i3[i3.indexOf(e4)] = false : x3.util.array.fill(i3, false);
      }
    }
    function e3(t4, e4) {
      var i3 = (function() {
        e4.apply(this, arguments), this.off(t4, i3);
      }).bind(this);
      this.on(t4, i3);
    }
    x3.Observable = { fire: function(t4, e4) {
      if (!this.__eventListeners) return this;
      var i3 = this.__eventListeners[t4];
      if (!i3) return this;
      for (var r4 = 0, n4 = i3.length; r4 < n4; r4++) i3[r4] && i3[r4].call(this, e4 || {});
      return this.__eventListeners[t4] = i3.filter(function(t5) {
        return false !== t5;
      }), this;
    }, on: function(t4, e4) {
      if (this.__eventListeners || (this.__eventListeners = {}), 1 === arguments.length) for (var i3 in t4) this.on(i3, t4[i3]);
      else this.__eventListeners[t4] || (this.__eventListeners[t4] = []), this.__eventListeners[t4].push(e4);
      return this;
    }, once: function(t4, i3) {
      if (1 === arguments.length) for (var r4 in t4) e3.call(this, r4, t4[r4]);
      else e3.call(this, t4, i3);
      return this;
    }, off: function(e4, i3) {
      if (!this.__eventListeners) return this;
      if (0 === arguments.length) for (e4 in this.__eventListeners) t3.call(this, e4);
      else if (1 === arguments.length && "object" == typeof arguments[0]) for (var r4 in e4) t3.call(this, r4, e4[r4]);
      else t3.call(this, e4, i3);
      return this;
    } };
  }(), x3.Collection = { _objects: [], add: function() {
    if (this._objects.push.apply(this._objects, arguments), this._onObjectAdded) for (var t3 = 0, e3 = arguments.length; t3 < e3; t3++) this._onObjectAdded(arguments[t3]);
    return this.renderOnAddRemove && this.requestRenderAll(), this;
  }, insertAt: function(t3, e3, i3) {
    var r4 = this._objects;
    return i3 ? r4[e3] = t3 : r4.splice(e3, 0, t3), this._onObjectAdded && this._onObjectAdded(t3), this.renderOnAddRemove && this.requestRenderAll(), this;
  }, remove: function() {
    for (var t3, e3 = this._objects, i3 = false, r4 = 0, n4 = arguments.length; r4 < n4; r4++) -1 !== (t3 = e3.indexOf(arguments[r4])) && (i3 = true, e3.splice(t3, 1), this._onObjectRemoved && this._onObjectRemoved(arguments[r4]));
    return this.renderOnAddRemove && i3 && this.requestRenderAll(), this;
  }, forEachObject: function(t3, e3) {
    for (var i3 = this.getObjects(), r4 = 0, n4 = i3.length; r4 < n4; r4++) t3.call(e3, i3[r4], r4, i3);
    return this;
  }, getObjects: function(t3) {
    return void 0 === t3 ? this._objects.concat() : this._objects.filter(function(e3) {
      return e3.type === t3;
    });
  }, item: function(t3) {
    return this._objects[t3];
  }, isEmpty: function() {
    return 0 === this._objects.length;
  }, size: function() {
    return this._objects.length;
  }, contains: function(t3, e3) {
    return this._objects.indexOf(t3) > -1 || !!e3 && this._objects.some(function(e4) {
      return "function" == typeof e4.contains && e4.contains(t3, true);
    });
  }, complexity: function() {
    return this._objects.reduce(function(t3, e3) {
      return t3 + (e3.complexity ? e3.complexity() : 0);
    }, 0);
  } }, x3.CommonMethods = { _setOptions: function(t3) {
    for (var e3 in t3) this.set(e3, t3[e3]);
  }, _initGradient: function(t3, e3) {
    !t3 || !t3.colorStops || t3 instanceof x3.Gradient || this.set(e3, new x3.Gradient(t3));
  }, _initPattern: function(t3, e3, i3) {
    !t3 || !t3.source || t3 instanceof x3.Pattern ? i3 && i3() : this.set(e3, new x3.Pattern(t3, i3));
  }, _setObject: function(t3) {
    for (var e3 in t3) this._set(e3, t3[e3]);
  }, set: function(t3, e3) {
    return "object" == typeof t3 ? this._setObject(t3) : this._set(t3, e3), this;
  }, _set: function(t3, e3) {
    this[t3] = e3;
  }, toggle: function(t3) {
    var e3 = this.get(t3);
    return "boolean" == typeof e3 && this.set(t3, !e3), this;
  }, get: function(t3) {
    return this[t3];
  } }, r3 = e2, n3 = Math.sqrt, s3 = Math.atan2, o3 = Math.pow, a3 = Math.PI / 180, h3 = Math.PI / 2, x3.util = { cos: function(t3) {
    if (0 === t3) return 1;
    switch (t3 < 0 && (t3 = -t3), t3 / h3) {
      case 1:
      case 3:
        return 0;
      case 2:
        return -1;
    }
    return Math.cos(t3);
  }, sin: function(t3) {
    if (0 === t3) return 0;
    var e3 = 1;
    switch (t3 < 0 && (e3 = -1), t3 / h3) {
      case 1:
        return e3;
      case 2:
        return 0;
      case 3:
        return -e3;
    }
    return Math.sin(t3);
  }, removeFromArray: function(t3, e3) {
    var i3 = t3.indexOf(e3);
    return -1 !== i3 && t3.splice(i3, 1), t3;
  }, getRandomInt: function(t3, e3) {
    return Math.floor(Math.random() * (e3 - t3 + 1)) + t3;
  }, degreesToRadians: function(t3) {
    return t3 * a3;
  }, radiansToDegrees: function(t3) {
    return t3 / a3;
  }, rotatePoint: function(t3, e3, i3) {
    var r4 = new x3.Point(t3.x - e3.x, t3.y - e3.y), n4 = x3.util.rotateVector(r4, i3);
    return new x3.Point(n4.x, n4.y).addEquals(e3);
  }, rotateVector: function(t3, e3) {
    var i3 = x3.util.sin(e3), r4 = x3.util.cos(e3);
    return { x: t3.x * r4 - t3.y * i3, y: t3.x * i3 + t3.y * r4 };
  }, createVector: function(t3, e3) {
    return new x3.Point(e3.x - t3.x, e3.y - t3.y);
  }, calcAngleBetweenVectors: function(t3, e3) {
    return Math.acos((t3.x * e3.x + t3.y * e3.y) / (Math.hypot(t3.x, t3.y) * Math.hypot(e3.x, e3.y)));
  }, getHatVector: function(t3) {
    return new x3.Point(t3.x, t3.y).multiply(1 / Math.hypot(t3.x, t3.y));
  }, getBisector: function(t3, e3, i3) {
    var r4 = x3.util.createVector(t3, e3), n4 = x3.util.createVector(t3, i3), s4 = x3.util.calcAngleBetweenVectors(r4, n4), o4 = s4 * (0 === x3.util.calcAngleBetweenVectors(x3.util.rotateVector(r4, s4), n4) ? 1 : -1) / 2;
    return { vector: x3.util.getHatVector(x3.util.rotateVector(r4, o4)), angle: s4 };
  }, projectStrokeOnPoints: function(t3, e3, i3) {
    var r4 = [], n4 = e3.strokeWidth / 2, s4 = e3.strokeUniform ? new x3.Point(1 / e3.scaleX, 1 / e3.scaleY) : new x3.Point(1, 1), o4 = function(t4) {
      var e4 = n4 / Math.hypot(t4.x, t4.y);
      return new x3.Point(t4.x * e4 * s4.x, t4.y * e4 * s4.y);
    };
    return t3.length <= 1 || t3.forEach(function(a4, h4) {
      var l4, c4, u4 = new x3.Point(a4.x, a4.y);
      0 === h4 ? (c4 = t3[h4 + 1], l4 = i3 ? o4(x3.util.createVector(c4, u4)).addEquals(u4) : t3[t3.length - 1]) : h4 === t3.length - 1 ? (l4 = t3[h4 - 1], c4 = i3 ? o4(x3.util.createVector(l4, u4)).addEquals(u4) : t3[0]) : (l4 = t3[h4 - 1], c4 = t3[h4 + 1]);
      var d4, f4, g4 = x3.util.getBisector(u4, l4, c4), p4 = g4.vector, m4 = g4.angle;
      if ("miter" === e3.strokeLineJoin && (d4 = -n4 / Math.sin(m4 / 2), f4 = new x3.Point(p4.x * d4 * s4.x, p4.y * d4 * s4.y), Math.hypot(f4.x, f4.y) / n4 <= e3.strokeMiterLimit)) return r4.push(u4.add(f4)), void r4.push(u4.subtract(f4));
      d4 = -n4 * Math.SQRT2, f4 = new x3.Point(p4.x * d4 * s4.x, p4.y * d4 * s4.y), r4.push(u4.add(f4)), r4.push(u4.subtract(f4));
    }), r4;
  }, transformPoint: function(t3, e3, i3) {
    return i3 ? new x3.Point(e3[0] * t3.x + e3[2] * t3.y, e3[1] * t3.x + e3[3] * t3.y) : new x3.Point(e3[0] * t3.x + e3[2] * t3.y + e3[4], e3[1] * t3.x + e3[3] * t3.y + e3[5]);
  }, makeBoundingBoxFromPoints: function(t3, e3) {
    if (e3) for (var i3 = 0; i3 < t3.length; i3++) t3[i3] = x3.util.transformPoint(t3[i3], e3);
    var r4 = [t3[0].x, t3[1].x, t3[2].x, t3[3].x], n4 = x3.util.array.min(r4), s4 = x3.util.array.max(r4) - n4, o4 = [t3[0].y, t3[1].y, t3[2].y, t3[3].y], a4 = x3.util.array.min(o4);
    return { left: n4, top: a4, width: s4, height: x3.util.array.max(o4) - a4 };
  }, invertTransform: function(t3) {
    var e3 = 1 / (t3[0] * t3[3] - t3[1] * t3[2]), i3 = [e3 * t3[3], -e3 * t3[1], -e3 * t3[2], e3 * t3[0]], r4 = x3.util.transformPoint({ x: t3[4], y: t3[5] }, i3, true);
    return i3[4] = -r4.x, i3[5] = -r4.y, i3;
  }, toFixed: function(t3, e3) {
    return parseFloat(Number(t3).toFixed(e3));
  }, parseUnit: function(t3, e3) {
    var i3 = /\D{0,2}$/.exec(t3), r4 = parseFloat(t3);
    switch (e3 || (e3 = x3.Text.DEFAULT_SVG_FONT_SIZE), i3[0]) {
      case "mm":
        return r4 * x3.DPI / 25.4;
      case "cm":
        return r4 * x3.DPI / 2.54;
      case "in":
        return r4 * x3.DPI;
      case "pt":
        return r4 * x3.DPI / 72;
      case "pc":
        return r4 * x3.DPI / 72 * 12;
      case "em":
        return r4 * e3;
      default:
        return r4;
    }
  }, falseFunction: function() {
    return false;
  }, getKlass: function(t3, e3) {
    return t3 = x3.util.string.camelize(t3.charAt(0).toUpperCase() + t3.slice(1)), x3.util.resolveNamespace(e3)[t3];
  }, getSvgAttributes: function(t3) {
    var e3 = ["instantiated_by_use", "style", "id", "class"];
    switch (t3) {
      case "linearGradient":
        e3 = e3.concat(["x1", "y1", "x2", "y2", "gradientUnits", "gradientTransform"]);
        break;
      case "radialGradient":
        e3 = e3.concat(["gradientUnits", "gradientTransform", "cx", "cy", "r", "fx", "fy", "fr"]);
        break;
      case "stop":
        e3 = e3.concat(["offset", "stop-color", "stop-opacity"]);
    }
    return e3;
  }, resolveNamespace: function(t3) {
    if (!t3) return x3;
    var e3, i3 = t3.split("."), n4 = i3.length, s4 = r3 || x3.window;
    for (e3 = 0; e3 < n4; ++e3) s4 = s4[i3[e3]];
    return s4;
  }, loadImage: function(t3, e3, i3, r4) {
    if (t3) {
      var n4 = x3.util.createImage(), s4 = function() {
        e3 && e3.call(i3, n4, false), n4 = n4.onload = n4.onerror = null;
      };
      n4.onload = s4, n4.onerror = function() {
        x3.log("Error loading " + n4.src), e3 && e3.call(i3, null, true), n4 = n4.onload = n4.onerror = null;
      }, 0 !== t3.indexOf("data") && null != r4 && (n4.crossOrigin = r4), "data:image/svg" === t3.substring(0, 14) && (n4.onload = null, x3.util.loadImageInDom(n4, s4)), n4.src = t3;
    } else e3 && e3.call(i3, t3);
  }, loadImageInDom: function(t3, e3) {
    var i3 = x3.document.createElement("div");
    i3.style.width = i3.style.height = "1px", i3.style.left = i3.style.top = "-100%", i3.style.position = "absolute", i3.appendChild(t3), x3.document.querySelector("body").appendChild(i3), t3.onload = function() {
      e3(), i3.parentNode.removeChild(i3), i3 = null;
    };
  }, enlivenObjects: function(t3, e3, i3, r4) {
    var n4 = [], s4 = 0, o4 = (t3 = t3 || []).length;
    function a4() {
      ++s4 === o4 && e3 && e3(n4.filter(function(t4) {
        return t4;
      }));
    }
    o4 ? t3.forEach(function(t4, e4) {
      t4 && t4.type ? x3.util.getKlass(t4.type, i3).fromObject(t4, function(i4, s5) {
        s5 || (n4[e4] = i4), r4 && r4(t4, i4, s5), a4();
      }) : a4();
    }) : e3 && e3(n4);
  }, enlivenObjectEnlivables: function(t3, e3, i3) {
    var r4 = x3.Object.ENLIVEN_PROPS.filter(function(e4) {
      return !!t3[e4];
    });
    x3.util.enlivenObjects(r4.map(function(e4) {
      return t3[e4];
    }), function(t4) {
      var n4 = {};
      r4.forEach(function(i4, r5) {
        n4[i4] = t4[r5], e3 && (e3[i4] = t4[r5]);
      }), i3 && i3(n4);
    });
  }, enlivenPatterns: function(t3, e3) {
    function i3() {
      ++n4 === s4 && e3 && e3(r4);
    }
    var r4 = [], n4 = 0, s4 = (t3 = t3 || []).length;
    s4 ? t3.forEach(function(t4, e4) {
      t4 && t4.source ? new x3.Pattern(t4, function(t5) {
        r4[e4] = t5, i3();
      }) : (r4[e4] = t4, i3());
    }) : e3 && e3(r4);
  }, groupSVGElements: function(t3, e3, i3) {
    var r4;
    return t3 && 1 === t3.length ? t3[0] : (e3 && (e3.width && e3.height ? e3.centerPoint = { x: e3.width / 2, y: e3.height / 2 } : (delete e3.width, delete e3.height)), r4 = new x3.Group(t3, e3), void 0 !== i3 && (r4.sourcePath = i3), r4);
  }, populateWithProperties: function(t3, e3, i3) {
    if (i3 && Array.isArray(i3)) for (var r4 = 0, n4 = i3.length; r4 < n4; r4++) i3[r4] in t3 && (e3[i3[r4]] = t3[i3[r4]]);
  }, createCanvasElement: function() {
    return x3.document.createElement("canvas");
  }, copyCanvasElement: function(t3) {
    var e3 = x3.util.createCanvasElement();
    return e3.width = t3.width, e3.height = t3.height, e3.getContext("2d").drawImage(t3, 0, 0), e3;
  }, toDataURL: function(t3, e3, i3) {
    return t3.toDataURL("image/" + e3, i3);
  }, createImage: function() {
    return x3.document.createElement("img");
  }, multiplyTransformMatrices: function(t3, e3, i3) {
    return [t3[0] * e3[0] + t3[2] * e3[1], t3[1] * e3[0] + t3[3] * e3[1], t3[0] * e3[2] + t3[2] * e3[3], t3[1] * e3[2] + t3[3] * e3[3], i3 ? 0 : t3[0] * e3[4] + t3[2] * e3[5] + t3[4], i3 ? 0 : t3[1] * e3[4] + t3[3] * e3[5] + t3[5]];
  }, qrDecompose: function(t3) {
    var e3 = s3(t3[1], t3[0]), i3 = o3(t3[0], 2) + o3(t3[1], 2), r4 = n3(i3), h4 = (t3[0] * t3[3] - t3[2] * t3[1]) / r4, l4 = s3(t3[0] * t3[2] + t3[1] * t3[3], i3);
    return { angle: e3 / a3, scaleX: r4, scaleY: h4, skewX: l4 / a3, skewY: 0, translateX: t3[4], translateY: t3[5] };
  }, calcRotateMatrix: function(t3) {
    if (!t3.angle) return x3.iMatrix.concat();
    var e3 = x3.util.degreesToRadians(t3.angle), i3 = x3.util.cos(e3), r4 = x3.util.sin(e3);
    return [i3, r4, -r4, i3, 0, 0];
  }, calcDimensionsMatrix: function(t3) {
    var e3 = void 0 === t3.scaleX ? 1 : t3.scaleX, i3 = void 0 === t3.scaleY ? 1 : t3.scaleY, r4 = [t3.flipX ? -e3 : e3, 0, 0, t3.flipY ? -i3 : i3, 0, 0], n4 = x3.util.multiplyTransformMatrices, s4 = x3.util.degreesToRadians;
    return t3.skewX && (r4 = n4(r4, [1, 0, Math.tan(s4(t3.skewX)), 1], true)), t3.skewY && (r4 = n4(r4, [1, Math.tan(s4(t3.skewY)), 0, 1], true)), r4;
  }, composeMatrix: function(t3) {
    var e3 = [1, 0, 0, 1, t3.translateX || 0, t3.translateY || 0], i3 = x3.util.multiplyTransformMatrices;
    return t3.angle && (e3 = i3(e3, x3.util.calcRotateMatrix(t3))), (1 !== t3.scaleX || 1 !== t3.scaleY || t3.skewX || t3.skewY || t3.flipX || t3.flipY) && (e3 = i3(e3, x3.util.calcDimensionsMatrix(t3))), e3;
  }, resetObjectTransform: function(t3) {
    t3.scaleX = 1, t3.scaleY = 1, t3.skewX = 0, t3.skewY = 0, t3.flipX = false, t3.flipY = false, t3.rotate(0);
  }, saveObjectTransform: function(t3) {
    return { scaleX: t3.scaleX, scaleY: t3.scaleY, skewX: t3.skewX, skewY: t3.skewY, angle: t3.angle, left: t3.left, flipX: t3.flipX, flipY: t3.flipY, top: t3.top };
  }, isTransparent: function(t3, e3, i3, r4) {
    r4 > 0 && (e3 > r4 ? e3 -= r4 : e3 = 0, i3 > r4 ? i3 -= r4 : i3 = 0);
    var n4, s4 = true, o4 = t3.getImageData(e3, i3, 2 * r4 || 1, 2 * r4 || 1), a4 = o4.data.length;
    for (n4 = 3; n4 < a4 && 0 != (s4 = o4.data[n4] <= 0); n4 += 4) ;
    return o4 = null, s4;
  }, parsePreserveAspectRatioAttribute: function(t3) {
    var e3, i3 = "meet", r4 = t3.split(" ");
    return r4 && r4.length && ("meet" !== (i3 = r4.pop()) && "slice" !== i3 ? (e3 = i3, i3 = "meet") : r4.length && (e3 = r4.pop())), { meetOrSlice: i3, alignX: "none" !== e3 ? e3.slice(1, 4) : "none", alignY: "none" !== e3 ? e3.slice(5, 8) : "none" };
  }, clearFabricFontCache: function(t3) {
    (t3 = (t3 || "").toLowerCase()) ? x3.charWidthsCache[t3] && delete x3.charWidthsCache[t3] : x3.charWidthsCache = {};
  }, limitDimsByArea: function(t3, e3) {
    var i3 = Math.sqrt(e3 * t3), r4 = Math.floor(e3 / i3);
    return { x: Math.floor(i3), y: r4 };
  }, capValue: function(t3, e3, i3) {
    return Math.max(t3, Math.min(e3, i3));
  }, findScaleToFit: function(t3, e3) {
    return Math.min(e3.width / t3.width, e3.height / t3.height);
  }, findScaleToCover: function(t3, e3) {
    return Math.max(e3.width / t3.width, e3.height / t3.height);
  }, matrixToSVG: function(t3) {
    return "matrix(" + t3.map(function(t4) {
      return x3.util.toFixed(t4, x3.Object.NUM_FRACTION_DIGITS);
    }).join(" ") + ")";
  }, removeTransformFromObject: function(t3, e3) {
    var i3 = x3.util.invertTransform(e3), r4 = x3.util.multiplyTransformMatrices(i3, t3.calcOwnMatrix());
    x3.util.applyTransformToObject(t3, r4);
  }, addTransformToObject: function(t3, e3) {
    x3.util.applyTransformToObject(t3, x3.util.multiplyTransformMatrices(e3, t3.calcOwnMatrix()));
  }, applyTransformToObject: function(t3, e3) {
    var i3 = x3.util.qrDecompose(e3), r4 = new x3.Point(i3.translateX, i3.translateY);
    t3.flipX = false, t3.flipY = false, t3.set("scaleX", i3.scaleX), t3.set("scaleY", i3.scaleY), t3.skewX = i3.skewX, t3.skewY = i3.skewY, t3.angle = i3.angle, t3.setPositionByOrigin(r4, "center", "center");
  }, sizeAfterTransform: function(t3, e3, i3) {
    var r4 = t3 / 2, n4 = e3 / 2, s4 = [{ x: -r4, y: -n4 }, { x: r4, y: -n4 }, { x: -r4, y: n4 }, { x: r4, y: n4 }], o4 = x3.util.calcDimensionsMatrix(i3), a4 = x3.util.makeBoundingBoxFromPoints(s4, o4);
    return { x: a4.width, y: a4.height };
  }, mergeClipPaths: function(t3, e3) {
    var i3 = t3, r4 = e3;
    i3.inverted && !r4.inverted && (i3 = e3, r4 = t3), x3.util.applyTransformToObject(r4, x3.util.multiplyTransformMatrices(x3.util.invertTransform(i3.calcTransformMatrix()), r4.calcTransformMatrix()));
    var n4 = i3.inverted && r4.inverted;
    return n4 && (i3.inverted = r4.inverted = false), new x3.Group([i3], { clipPath: r4, inverted: n4 });
  } }, function() {
    var t3 = Array.prototype.join, e3 = { m: 2, l: 2, h: 1, v: 1, c: 6, s: 4, q: 4, t: 2, a: 7 }, i3 = { m: "l", M: "L" };
    function r4(t4, e4, i4, r5, n5, s5, o5, a5, h5, l5, c5) {
      var u5 = x3.util.cos(t4), d5 = x3.util.sin(t4), f4 = x3.util.cos(e4), g4 = x3.util.sin(e4), p4 = i4 * n5 * f4 - r5 * s5 * g4 + o5, m4 = r5 * n5 * f4 + i4 * s5 * g4 + a5;
      return ["C", l5 + h5 * (-i4 * n5 * d5 - r5 * s5 * u5), c5 + h5 * (-r5 * n5 * d5 + i4 * s5 * u5), p4 + h5 * (i4 * n5 * g4 + r5 * s5 * f4), m4 + h5 * (r5 * n5 * g4 - i4 * s5 * f4), p4, m4];
    }
    function n4(t4, e4, i4, r5) {
      var n5 = Math.atan2(e4, t4), s5 = Math.atan2(r5, i4);
      return s5 >= n5 ? s5 - n5 : 2 * Math.PI - (n5 - s5);
    }
    function s4(t4, e4, i4) {
      for (var s5 = i4[1], o5 = i4[2], a5 = i4[3], h5 = i4[4], l5 = i4[5], c5 = function(t5, e5, i5, s6, o6, a6, h6) {
        var l6 = Math.PI, c6 = h6 * l6 / 180, u6 = x3.util.sin(c6), d6 = x3.util.cos(c6), f4 = 0, g4 = 0, p4 = -d6 * t5 * 0.5 - u6 * e5 * 0.5, m4 = -d6 * e5 * 0.5 + u6 * t5 * 0.5, v4 = (i5 = Math.abs(i5)) * i5, _4 = (s6 = Math.abs(s6)) * s6, y4 = m4 * m4, b4 = p4 * p4, w4 = v4 * _4 - v4 * y4 - _4 * b4, C4 = 0;
        if (w4 < 0) {
          var S4 = Math.sqrt(1 - w4 / (v4 * _4));
          i5 *= S4, s6 *= S4;
        } else C4 = (o6 === a6 ? -1 : 1) * Math.sqrt(w4 / (v4 * y4 + _4 * b4));
        var T4 = C4 * i5 * m4 / s6, O4 = -C4 * s6 * p4 / i5, E4 = d6 * T4 - u6 * O4 + 0.5 * t5, D3 = u6 * T4 + d6 * O4 + 0.5 * e5, M3 = n4(1, 0, (p4 - T4) / i5, (m4 - O4) / s6), I3 = n4((p4 - T4) / i5, (m4 - O4) / s6, (-p4 - T4) / i5, (-m4 - O4) / s6);
        0 === a6 && I3 > 0 ? I3 -= 2 * l6 : 1 === a6 && I3 < 0 && (I3 += 2 * l6);
        for (var L3 = Math.ceil(Math.abs(I3 / l6 * 2)), F2 = [], k2 = I3 / L3, P2 = 8 / 3 * Math.sin(k2 / 4) * Math.sin(k2 / 4) / Math.sin(k2 / 2), A2 = M3 + k2, R2 = 0; R2 < L3; R2++) F2[R2] = r4(M3, A2, d6, u6, i5, s6, E4, D3, P2, f4, g4), f4 = F2[R2][5], g4 = F2[R2][6], M3 = A2, A2 += k2;
        return F2;
      }(i4[6] - t4, i4[7] - e4, s5, o5, h5, l5, a5), u5 = 0, d5 = c5.length; u5 < d5; u5++) c5[u5][1] += t4, c5[u5][2] += e4, c5[u5][3] += t4, c5[u5][4] += e4, c5[u5][5] += t4, c5[u5][6] += e4;
      return c5;
    }
    function o4(t4, e4, i4, r5) {
      return Math.sqrt((i4 - t4) * (i4 - t4) + (r5 - e4) * (r5 - e4));
    }
    function a4(t4, e4, i4, r5, n5, s5, o5, a5) {
      return function(h5) {
        var l5, c5 = (l5 = h5) * l5 * l5, u5 = function(t5) {
          return 3 * t5 * t5 * (1 - t5);
        }(h5), d5 = function(t5) {
          return 3 * t5 * (1 - t5) * (1 - t5);
        }(h5), f4 = function(t5) {
          return (1 - t5) * (1 - t5) * (1 - t5);
        }(h5);
        return { x: o5 * c5 + n5 * u5 + i4 * d5 + t4 * f4, y: a5 * c5 + s5 * u5 + r5 * d5 + e4 * f4 };
      };
    }
    function h4(t4, e4, i4, r5, n5, s5, o5, a5) {
      return function(h5) {
        var l5 = 1 - h5, c5 = 3 * l5 * l5 * (i4 - t4) + 6 * l5 * h5 * (n5 - i4) + 3 * h5 * h5 * (o5 - n5), u5 = 3 * l5 * l5 * (r5 - e4) + 6 * l5 * h5 * (s5 - r5) + 3 * h5 * h5 * (a5 - s5);
        return Math.atan2(u5, c5);
      };
    }
    function l4(t4, e4, i4, r5, n5, s5) {
      return function(o5) {
        var a5, h5 = (a5 = o5) * a5, l5 = function(t5) {
          return 2 * t5 * (1 - t5);
        }(o5), c5 = function(t5) {
          return (1 - t5) * (1 - t5);
        }(o5);
        return { x: n5 * h5 + i4 * l5 + t4 * c5, y: s5 * h5 + r5 * l5 + e4 * c5 };
      };
    }
    function c4(t4, e4, i4, r5, n5, s5) {
      return function(o5) {
        var a5 = 1 - o5, h5 = 2 * a5 * (i4 - t4) + 2 * o5 * (n5 - i4), l5 = 2 * a5 * (r5 - e4) + 2 * o5 * (s5 - r5);
        return Math.atan2(l5, h5);
      };
    }
    function u4(t4, e4, i4) {
      var r5, n5, s5 = { x: e4, y: i4 }, a5 = 0;
      for (n5 = 1; n5 <= 100; n5 += 1) r5 = t4(n5 / 100), a5 += o4(s5.x, s5.y, r5.x, r5.y), s5 = r5;
      return a5;
    }
    function d4(t4) {
      for (var e4, i4, r5, n5, s5 = 0, d5 = t4.length, f4 = 0, g4 = 0, p4 = 0, m4 = 0, v4 = [], _4 = 0; _4 < d5; _4++) {
        switch (r5 = { x: f4, y: g4, command: (e4 = t4[_4])[0] }, e4[0]) {
          case "M":
            r5.length = 0, p4 = f4 = e4[1], m4 = g4 = e4[2];
            break;
          case "L":
            r5.length = o4(f4, g4, e4[1], e4[2]), f4 = e4[1], g4 = e4[2];
            break;
          case "C":
            i4 = a4(f4, g4, e4[1], e4[2], e4[3], e4[4], e4[5], e4[6]), n5 = h4(f4, g4, e4[1], e4[2], e4[3], e4[4], e4[5], e4[6]), r5.iterator = i4, r5.angleFinder = n5, r5.length = u4(i4, f4, g4), f4 = e4[5], g4 = e4[6];
            break;
          case "Q":
            i4 = l4(f4, g4, e4[1], e4[2], e4[3], e4[4]), n5 = c4(f4, g4, e4[1], e4[2], e4[3], e4[4]), r5.iterator = i4, r5.angleFinder = n5, r5.length = u4(i4, f4, g4), f4 = e4[3], g4 = e4[4];
            break;
          case "Z":
          case "z":
            r5.destX = p4, r5.destY = m4, r5.length = o4(f4, g4, p4, m4), f4 = p4, g4 = m4;
        }
        s5 += r5.length, v4.push(r5);
      }
      return v4.push({ length: s5, x: f4, y: g4 }), v4;
    }
    x3.util.joinPath = function(t4) {
      return t4.map(function(t5) {
        return t5.join(" ");
      }).join(" ");
    }, x3.util.parsePath = function(t4) {
      var r5, n5, s5, o5, a5, h5 = [], l5 = [], c5 = x3.rePathCommand, u5 = "[-+]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?\\s*", d5 = "(" + u5 + ")" + x3.commaWsp, f4 = "([01])" + x3.commaWsp + "?", g4 = new RegExp(d5 + "?" + d5 + "?" + d5 + f4 + f4 + d5 + "?(" + u5 + ")", "g");
      if (!t4 || !t4.match) return h5;
      for (var p4, m4 = 0, v4 = (a5 = t4.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi)).length; m4 < v4; m4++) {
        o5 = (r5 = a5[m4]).slice(1).trim(), l5.length = 0;
        var _4 = r5.charAt(0);
        if (p4 = [_4], "a" === _4.toLowerCase()) for (var y4; y4 = g4.exec(o5); ) for (var b4 = 1; b4 < y4.length; b4++) l5.push(y4[b4]);
        else for (; s5 = c5.exec(o5); ) l5.push(s5[0]);
        b4 = 0;
        for (var w4 = l5.length; b4 < w4; b4++) n5 = parseFloat(l5[b4]), isNaN(n5) || p4.push(n5);
        var C4 = e3[_4.toLowerCase()], S4 = i3[_4] || _4;
        if (p4.length - 1 > C4) for (var T4 = 1, O4 = p4.length; T4 < O4; T4 += C4) h5.push([_4].concat(p4.slice(T4, T4 + C4))), _4 = S4;
        else h5.push(p4);
      }
      return h5;
    }, x3.util.makePathSimpler = function(t4) {
      var e4, i4, r5, n5, o5, a5, h5 = 0, l5 = 0, c5 = t4.length, u5 = 0, d5 = 0, f4 = [];
      for (i4 = 0; i4 < c5; ++i4) {
        switch (r5 = false, (e4 = t4[i4].slice(0))[0]) {
          case "l":
            e4[0] = "L", e4[1] += h5, e4[2] += l5;
          case "L":
            h5 = e4[1], l5 = e4[2];
            break;
          case "h":
            e4[1] += h5;
          case "H":
            e4[0] = "L", e4[2] = l5, h5 = e4[1];
            break;
          case "v":
            e4[1] += l5;
          case "V":
            e4[0] = "L", l5 = e4[1], e4[1] = h5, e4[2] = l5;
            break;
          case "m":
            e4[0] = "M", e4[1] += h5, e4[2] += l5;
          case "M":
            h5 = e4[1], l5 = e4[2], u5 = e4[1], d5 = e4[2];
            break;
          case "c":
            e4[0] = "C", e4[1] += h5, e4[2] += l5, e4[3] += h5, e4[4] += l5, e4[5] += h5, e4[6] += l5;
          case "C":
            o5 = e4[3], a5 = e4[4], h5 = e4[5], l5 = e4[6];
            break;
          case "s":
            e4[0] = "S", e4[1] += h5, e4[2] += l5, e4[3] += h5, e4[4] += l5;
          case "S":
            "C" === n5 ? (o5 = 2 * h5 - o5, a5 = 2 * l5 - a5) : (o5 = h5, a5 = l5), h5 = e4[3], l5 = e4[4], e4[0] = "C", e4[5] = e4[3], e4[6] = e4[4], e4[3] = e4[1], e4[4] = e4[2], e4[1] = o5, e4[2] = a5, o5 = e4[3], a5 = e4[4];
            break;
          case "q":
            e4[0] = "Q", e4[1] += h5, e4[2] += l5, e4[3] += h5, e4[4] += l5;
          case "Q":
            o5 = e4[1], a5 = e4[2], h5 = e4[3], l5 = e4[4];
            break;
          case "t":
            e4[0] = "T", e4[1] += h5, e4[2] += l5;
          case "T":
            "Q" === n5 ? (o5 = 2 * h5 - o5, a5 = 2 * l5 - a5) : (o5 = h5, a5 = l5), e4[0] = "Q", h5 = e4[1], l5 = e4[2], e4[1] = o5, e4[2] = a5, e4[3] = h5, e4[4] = l5;
            break;
          case "a":
            e4[0] = "A", e4[6] += h5, e4[7] += l5;
          case "A":
            r5 = true, f4 = f4.concat(s4(h5, l5, e4)), h5 = e4[6], l5 = e4[7];
            break;
          case "z":
          case "Z":
            h5 = u5, l5 = d5;
        }
        r5 || f4.push(e4), n5 = e4[0];
      }
      return f4;
    }, x3.util.getSmoothPathFromPoints = function(t4, e4) {
      var i4, r5 = [], n5 = new x3.Point(t4[0].x, t4[0].y), s5 = new x3.Point(t4[1].x, t4[1].y), o5 = t4.length, a5 = 1, h5 = 0, l5 = o5 > 2;
      for (e4 = e4 || 0, l5 && (a5 = t4[2].x < s5.x ? -1 : t4[2].x === s5.x ? 0 : 1, h5 = t4[2].y < s5.y ? -1 : t4[2].y === s5.y ? 0 : 1), r5.push(["M", n5.x - a5 * e4, n5.y - h5 * e4]), i4 = 1; i4 < o5; i4++) {
        if (!n5.eq(s5)) {
          var c5 = n5.midPointFrom(s5);
          r5.push(["Q", n5.x, n5.y, c5.x, c5.y]);
        }
        n5 = t4[i4], i4 + 1 < t4.length && (s5 = t4[i4 + 1]);
      }
      return l5 && (a5 = n5.x > t4[i4 - 2].x ? 1 : n5.x === t4[i4 - 2].x ? 0 : -1, h5 = n5.y > t4[i4 - 2].y ? 1 : n5.y === t4[i4 - 2].y ? 0 : -1), r5.push(["L", n5.x + a5 * e4, n5.y + h5 * e4]), r5;
    }, x3.util.getPathSegmentsInfo = d4, x3.util.getBoundsOfCurve = function(e4, i4, r5, n5, s5, o5, a5, h5) {
      var l5;
      if (x3.cachesBoundsOfCurve && (l5 = t3.call(arguments), x3.boundsOfCurveCache[l5])) return x3.boundsOfCurveCache[l5];
      var c5, u5, d5, f4, g4, p4, m4, v4, _4 = Math.sqrt, y4 = Math.min, b4 = Math.max, w4 = Math.abs, C4 = [], S4 = [[], []];
      u5 = 6 * e4 - 12 * r5 + 6 * s5, c5 = -3 * e4 + 9 * r5 - 9 * s5 + 3 * a5, d5 = 3 * r5 - 3 * e4;
      for (var T4 = 0; T4 < 2; ++T4) if (T4 > 0 && (u5 = 6 * i4 - 12 * n5 + 6 * o5, c5 = -3 * i4 + 9 * n5 - 9 * o5 + 3 * h5, d5 = 3 * n5 - 3 * i4), w4(c5) < 1e-12) {
        if (w4(u5) < 1e-12) continue;
        0 < (f4 = -d5 / u5) && f4 < 1 && C4.push(f4);
      } else (m4 = u5 * u5 - 4 * d5 * c5) < 0 || (0 < (g4 = (-u5 + (v4 = _4(m4))) / (2 * c5)) && g4 < 1 && C4.push(g4), 0 < (p4 = (-u5 - v4) / (2 * c5)) && p4 < 1 && C4.push(p4));
      for (var O4, E4, D3, M3 = C4.length, I3 = M3; M3--; ) O4 = (D3 = 1 - (f4 = C4[M3])) * D3 * D3 * e4 + 3 * D3 * D3 * f4 * r5 + 3 * D3 * f4 * f4 * s5 + f4 * f4 * f4 * a5, S4[0][M3] = O4, E4 = D3 * D3 * D3 * i4 + 3 * D3 * D3 * f4 * n5 + 3 * D3 * f4 * f4 * o5 + f4 * f4 * f4 * h5, S4[1][M3] = E4;
      S4[0][I3] = e4, S4[1][I3] = i4, S4[0][I3 + 1] = a5, S4[1][I3 + 1] = h5;
      var L3 = [{ x: y4.apply(null, S4[0]), y: y4.apply(null, S4[1]) }, { x: b4.apply(null, S4[0]), y: b4.apply(null, S4[1]) }];
      return x3.cachesBoundsOfCurve && (x3.boundsOfCurveCache[l5] = L3), L3;
    }, x3.util.getPointOnPath = function(t4, e4, i4) {
      i4 || (i4 = d4(t4));
      for (var r5 = 0; e4 - i4[r5].length > 0 && r5 < i4.length - 2; ) e4 -= i4[r5].length, r5++;
      var n5, s5 = i4[r5], a5 = e4 / s5.length, h5 = s5.command, l5 = t4[r5];
      switch (h5) {
        case "M":
          return { x: s5.x, y: s5.y, angle: 0 };
        case "Z":
        case "z":
          return (n5 = new x3.Point(s5.x, s5.y).lerp(new x3.Point(s5.destX, s5.destY), a5)).angle = Math.atan2(s5.destY - s5.y, s5.destX - s5.x), n5;
        case "L":
          return (n5 = new x3.Point(s5.x, s5.y).lerp(new x3.Point(l5[1], l5[2]), a5)).angle = Math.atan2(l5[2] - s5.y, l5[1] - s5.x), n5;
        case "C":
        case "Q":
          return function(t5, e5) {
            for (var i5, r6, n6, s6 = 0, a6 = 0, h6 = t5.iterator, l6 = { x: t5.x, y: t5.y }, c5 = 0.01, u5 = t5.angleFinder; a6 < e5 && c5 > 1e-4; ) i5 = h6(s6), n6 = s6, (r6 = o4(l6.x, l6.y, i5.x, i5.y)) + a6 > e5 ? (s6 -= c5, c5 /= 2) : (l6 = i5, s6 += c5, a6 += r6);
            return i5.angle = u5(n6), i5;
          }(s5, e4);
      }
    }, x3.util.transformPath = function(t4, e4, i4) {
      return i4 && (e4 = x3.util.multiplyTransformMatrices(e4, [1, 0, 0, 1, -i4.x, -i4.y])), t4.map(function(t5) {
        for (var i5 = t5.slice(0), r5 = {}, n5 = 1; n5 < t5.length - 1; n5 += 2) r5.x = t5[n5], r5.y = t5[n5 + 1], r5 = x3.util.transformPoint(r5, e4), i5[n5] = r5.x, i5[n5 + 1] = r5.y;
        return i5;
      });
    };
  }(), function() {
    var t3 = Array.prototype.slice;
    function e3(t4, e4, i3) {
      if (t4 && 0 !== t4.length) {
        var r4 = t4.length - 1, n4 = e4 ? t4[r4][e4] : t4[r4];
        if (e4) for (; r4--; ) i3(t4[r4][e4], n4) && (n4 = t4[r4][e4]);
        else for (; r4--; ) i3(t4[r4], n4) && (n4 = t4[r4]);
        return n4;
      }
    }
    x3.util.array = { fill: function(t4, e4) {
      for (var i3 = t4.length; i3--; ) t4[i3] = e4;
      return t4;
    }, invoke: function(e4, i3) {
      for (var r4 = t3.call(arguments, 2), n4 = [], s4 = 0, o4 = e4.length; s4 < o4; s4++) n4[s4] = r4.length ? e4[s4][i3].apply(e4[s4], r4) : e4[s4][i3].call(e4[s4]);
      return n4;
    }, min: function(t4, i3) {
      return e3(t4, i3, function(t5, e4) {
        return t5 < e4;
      });
    }, max: function(t4, i3) {
      return e3(t4, i3, function(t5, e4) {
        return t5 >= e4;
      });
    } };
  }(), function() {
    function t3(e3, i3, r4) {
      if (r4) if (!x3.isLikelyNode && i3 instanceof Element) e3 = i3;
      else if (i3 instanceof Array) {
        e3 = [];
        for (var n4 = 0, s4 = i3.length; n4 < s4; n4++) e3[n4] = t3({}, i3[n4], r4);
      } else if (i3 && "object" == typeof i3) for (var o4 in i3) "canvas" === o4 || "group" === o4 ? e3[o4] = null : i3.hasOwnProperty(o4) && (e3[o4] = t3({}, i3[o4], r4));
      else e3 = i3;
      else for (var o4 in i3) e3[o4] = i3[o4];
      return e3;
    }
    x3.util.object = { extend: t3, clone: function(e3, i3) {
      return t3({}, e3, i3);
    } }, x3.util.object.extend(x3.util, x3.Observable);
  }(), function() {
    function t3(t4, e3) {
      var i3 = t4.charCodeAt(e3);
      if (isNaN(i3)) return "";
      if (i3 < 55296 || i3 > 57343) return t4.charAt(e3);
      if (55296 <= i3 && i3 <= 56319) {
        if (t4.length <= e3 + 1) throw "High surrogate without following low surrogate";
        var r4 = t4.charCodeAt(e3 + 1);
        if (56320 > r4 || r4 > 57343) throw "High surrogate without following low surrogate";
        return t4.charAt(e3) + t4.charAt(e3 + 1);
      }
      if (0 === e3) throw "Low surrogate without preceding high surrogate";
      var n4 = t4.charCodeAt(e3 - 1);
      if (55296 > n4 || n4 > 56319) throw "Low surrogate without preceding high surrogate";
      return false;
    }
    x3.util.string = { camelize: function(t4) {
      return t4.replace(/-+(.)?/g, function(t5, e3) {
        return e3 ? e3.toUpperCase() : "";
      });
    }, capitalize: function(t4, e3) {
      return t4.charAt(0).toUpperCase() + (e3 ? t4.slice(1) : t4.slice(1).toLowerCase());
    }, escapeXml: function(t4) {
      return t4.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&apos;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }, graphemeSplit: function(e3) {
      var i3, r4 = 0, n4 = [];
      for (r4 = 0; r4 < e3.length; r4++) false !== (i3 = t3(e3, r4)) && n4.push(i3);
      return n4;
    } };
  }(), function() {
    var t3 = Array.prototype.slice, e3 = function() {
    }, i3 = function() {
      for (var t4 in { toString: 1 }) if ("toString" === t4) return false;
      return true;
    }(), r4 = function(t4, e4, r5) {
      for (var n5 in e4) n5 in t4.prototype && "function" == typeof t4.prototype[n5] && (e4[n5] + "").indexOf("callSuper") > -1 ? t4.prototype[n5] = /* @__PURE__ */ function(t5) {
        return function() {
          var i4 = this.constructor.superclass;
          this.constructor.superclass = r5;
          var n6 = e4[t5].apply(this, arguments);
          if (this.constructor.superclass = i4, "initialize" !== t5) return n6;
        };
      }(n5) : t4.prototype[n5] = e4[n5], i3 && (e4.toString !== Object.prototype.toString && (t4.prototype.toString = e4.toString), e4.valueOf !== Object.prototype.valueOf && (t4.prototype.valueOf = e4.valueOf));
    };
    function n4() {
    }
    function s4(e4) {
      for (var i4 = null, r5 = this; r5.constructor.superclass; ) {
        var n5 = r5.constructor.superclass.prototype[e4];
        if (r5[e4] !== n5) {
          i4 = n5;
          break;
        }
        r5 = r5.constructor.superclass.prototype;
      }
      return i4 ? arguments.length > 1 ? i4.apply(this, t3.call(arguments, 1)) : i4.call(this) : console.log("tried to callSuper " + e4 + ", method not found in prototype chain", this);
    }
    x3.util.createClass = function() {
      var i4 = null, o4 = t3.call(arguments, 0);
      function a4() {
        this.initialize.apply(this, arguments);
      }
      "function" == typeof o4[0] && (i4 = o4.shift()), a4.superclass = i4, a4.subclasses = [], i4 && (n4.prototype = i4.prototype, a4.prototype = new n4(), i4.subclasses.push(a4));
      for (var h4 = 0, l4 = o4.length; h4 < l4; h4++) r4(a4, o4[h4], i4);
      return a4.prototype.initialize || (a4.prototype.initialize = e3), a4.prototype.constructor = a4, a4.prototype.callSuper = s4, a4;
    };
  }(), l3 = !!x3.document.createElement("div").attachEvent, c3 = ["touchstart", "touchmove", "touchend"], x3.util.addListener = function(t3, e3, i3, r4) {
    t3 && t3.addEventListener(e3, i3, !l3 && r4);
  }, x3.util.removeListener = function(t3, e3, i3, r4) {
    t3 && t3.removeEventListener(e3, i3, !l3 && r4);
  }, x3.util.getPointer = function(t3) {
    var e3 = t3.target, i3 = x3.util.getScrollLeftTop(e3), r4 = function(t4) {
      var e4 = t4.changedTouches;
      return e4 && e4[0] ? e4[0] : t4;
    }(t3);
    return { x: r4.clientX + i3.left, y: r4.clientY + i3.top };
  }, x3.util.isTouchEvent = function(t3) {
    return c3.indexOf(t3.type) > -1 || "touch" === t3.pointerType;
  }, d3 = "string" == typeof (u3 = x3.document.createElement("div")).style.opacity, f3 = "string" == typeof u3.style.filter, g3 = /alpha\s*\(\s*opacity\s*=\s*([^\)]+)\)/, p3 = function(t3) {
    return t3;
  }, d3 ? p3 = function(t3, e3) {
    return t3.style.opacity = e3, t3;
  } : f3 && (p3 = function(t3, e3) {
    var i3 = t3.style;
    return t3.currentStyle && !t3.currentStyle.hasLayout && (i3.zoom = 1), g3.test(i3.filter) ? (e3 = e3 >= 0.9999 ? "" : "alpha(opacity=" + 100 * e3 + ")", i3.filter = i3.filter.replace(g3, e3)) : i3.filter += " alpha(opacity=" + 100 * e3 + ")", t3;
  }), x3.util.setStyle = function(t3, e3) {
    var i3 = t3.style;
    if (!i3) return t3;
    if ("string" == typeof e3) return t3.style.cssText += ";" + e3, e3.indexOf("opacity") > -1 ? p3(t3, e3.match(/opacity:\s*(\d?\.?\d*)/)[1]) : t3;
    for (var r4 in e3) "opacity" === r4 ? p3(t3, e3[r4]) : i3["float" === r4 || "cssFloat" === r4 ? void 0 === i3.styleFloat ? "cssFloat" : "styleFloat" : r4] = e3[r4];
    return t3;
  }, function() {
    var t3, e3, i3, r4, n4 = Array.prototype.slice, s4 = function(t4) {
      return n4.call(t4, 0);
    };
    try {
      t3 = s4(x3.document.childNodes) instanceof Array;
    } catch (t4) {
    }
    function o4(t4, e4) {
      var i4 = x3.document.createElement(t4);
      for (var r5 in e4) "class" === r5 ? i4.className = e4[r5] : "for" === r5 ? i4.htmlFor = e4[r5] : i4.setAttribute(r5, e4[r5]);
      return i4;
    }
    function a4(t4) {
      for (var e4 = 0, i4 = 0, r5 = x3.document.documentElement, n5 = x3.document.body || { scrollLeft: 0, scrollTop: 0 }; t4 && (t4.parentNode || t4.host) && ((t4 = t4.parentNode || t4.host) === x3.document ? (e4 = n5.scrollLeft || r5.scrollLeft || 0, i4 = n5.scrollTop || r5.scrollTop || 0) : (e4 += t4.scrollLeft || 0, i4 += t4.scrollTop || 0), 1 !== t4.nodeType || "fixed" !== t4.style.position); ) ;
      return { left: e4, top: i4 };
    }
    t3 || (s4 = function(t4) {
      for (var e4 = new Array(t4.length), i4 = t4.length; i4--; ) e4[i4] = t4[i4];
      return e4;
    }), e3 = x3.document.defaultView && x3.document.defaultView.getComputedStyle ? function(t4, e4) {
      var i4 = x3.document.defaultView.getComputedStyle(t4, null);
      return i4 ? i4[e4] : void 0;
    } : function(t4, e4) {
      var i4 = t4.style[e4];
      return !i4 && t4.currentStyle && (i4 = t4.currentStyle[e4]), i4;
    }, i3 = x3.document.documentElement.style, r4 = "userSelect" in i3 ? "userSelect" : "MozUserSelect" in i3 ? "MozUserSelect" : "WebkitUserSelect" in i3 ? "WebkitUserSelect" : "KhtmlUserSelect" in i3 ? "KhtmlUserSelect" : "", x3.util.makeElementUnselectable = function(t4) {
      return void 0 !== t4.onselectstart && (t4.onselectstart = x3.util.falseFunction), r4 ? t4.style[r4] = "none" : "string" == typeof t4.unselectable && (t4.unselectable = "on"), t4;
    }, x3.util.makeElementSelectable = function(t4) {
      return void 0 !== t4.onselectstart && (t4.onselectstart = null), r4 ? t4.style[r4] = "" : "string" == typeof t4.unselectable && (t4.unselectable = ""), t4;
    }, x3.util.setImageSmoothing = function(t4, e4) {
      t4.imageSmoothingEnabled = t4.imageSmoothingEnabled || t4.webkitImageSmoothingEnabled || t4.mozImageSmoothingEnabled || t4.msImageSmoothingEnabled || t4.oImageSmoothingEnabled, t4.imageSmoothingEnabled = e4;
    }, x3.util.getById = function(t4) {
      return "string" == typeof t4 ? x3.document.getElementById(t4) : t4;
    }, x3.util.toArray = s4, x3.util.addClass = function(t4, e4) {
      t4 && -1 === (" " + t4.className + " ").indexOf(" " + e4 + " ") && (t4.className += (t4.className ? " " : "") + e4);
    }, x3.util.makeElement = o4, x3.util.wrapElement = function(t4, e4, i4) {
      return "string" == typeof e4 && (e4 = o4(e4, i4)), t4.parentNode && t4.parentNode.replaceChild(e4, t4), e4.appendChild(t4), e4;
    }, x3.util.getScrollLeftTop = a4, x3.util.getElementOffset = function(t4) {
      var i4, r5, n5 = t4 && t4.ownerDocument, s5 = { left: 0, top: 0 }, o5 = { left: 0, top: 0 }, h4 = { borderLeftWidth: "left", borderTopWidth: "top", paddingLeft: "left", paddingTop: "top" };
      if (!n5) return o5;
      for (var l4 in h4) o5[h4[l4]] += parseInt(e3(t4, l4), 10) || 0;
      return i4 = n5.documentElement, void 0 !== t4.getBoundingClientRect && (s5 = t4.getBoundingClientRect()), r5 = a4(t4), { left: s5.left + r5.left - (i4.clientLeft || 0) + o5.left, top: s5.top + r5.top - (i4.clientTop || 0) + o5.top };
    }, x3.util.getNodeCanvas = function(t4) {
      var e4 = x3.jsdomImplForWrapper(t4);
      return e4._canvas || e4._image;
    }, x3.util.cleanUpJsdomNode = function(t4) {
      if (x3.isLikelyNode) {
        var e4 = x3.jsdomImplForWrapper(t4);
        e4 && (e4._image = null, e4._canvas = null, e4._currentSrc = null, e4._attributes = null, e4._classList = null);
      }
    };
  }(), function() {
    function t3() {
    }
    x3.util.request = function(e3, i3) {
      i3 || (i3 = {});
      var r4 = i3.method ? i3.method.toUpperCase() : "GET", n4 = i3.onComplete || function() {
      }, s4 = new x3.window.XMLHttpRequest(), o4 = i3.body || i3.parameters;
      return s4.onreadystatechange = function() {
        4 === s4.readyState && (n4(s4), s4.onreadystatechange = t3);
      }, "GET" === r4 && (o4 = null, "string" == typeof i3.parameters && (e3 = function(t4, e4) {
        return t4 + (/\?/.test(t4) ? "&" : "?") + e4;
      }(e3, i3.parameters))), s4.open(r4, e3, true), "POST" !== r4 && "PUT" !== r4 || s4.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"), s4.send(o4), s4;
    };
  }(), x3.log = console.log, x3.warn = console.warn, function() {
    var t3 = x3.util.object.extend, e3 = x3.util.object.clone, i3 = [];
    function r4() {
      return false;
    }
    function n4(t4, e4, i4, r5) {
      return -i4 * Math.cos(t4 / r5 * (Math.PI / 2)) + i4 + e4;
    }
    x3.util.object.extend(i3, { cancelAll: function() {
      var t4 = this.splice(0);
      return t4.forEach(function(t5) {
        t5.cancel();
      }), t4;
    }, cancelByCanvas: function(t4) {
      if (!t4) return [];
      var e4 = this.filter(function(e5) {
        return "object" == typeof e5.target && e5.target.canvas === t4;
      });
      return e4.forEach(function(t5) {
        t5.cancel();
      }), e4;
    }, cancelByTarget: function(t4) {
      var e4 = this.findAnimationsByTarget(t4);
      return e4.forEach(function(t5) {
        t5.cancel();
      }), e4;
    }, findAnimationIndex: function(t4) {
      return this.indexOf(this.findAnimation(t4));
    }, findAnimation: function(t4) {
      return this.find(function(e4) {
        return e4.cancel === t4;
      });
    }, findAnimationsByTarget: function(t4) {
      return t4 ? this.filter(function(e4) {
        return e4.target === t4;
      }) : [];
    } });
    var s4 = x3.window.requestAnimationFrame || x3.window.webkitRequestAnimationFrame || x3.window.mozRequestAnimationFrame || x3.window.oRequestAnimationFrame || x3.window.msRequestAnimationFrame || function(t4) {
      return x3.window.setTimeout(t4, 1e3 / 60);
    }, o4 = x3.window.cancelAnimationFrame || x3.window.clearTimeout;
    function a4() {
      return s4.apply(x3.window, arguments);
    }
    x3.util.animate = function(i4) {
      i4 || (i4 = {});
      var s5, o5 = false, h4 = function() {
        var t4 = x3.runningAnimations.indexOf(s5);
        return t4 > -1 && x3.runningAnimations.splice(t4, 1)[0];
      };
      return s5 = t3(e3(i4), { cancel: function() {
        return o5 = true, h4();
      }, currentValue: "startValue" in i4 ? i4.startValue : 0, completionRate: 0, durationRate: 0 }), x3.runningAnimations.push(s5), a4(function(t4) {
        var e4, l4 = t4 || +/* @__PURE__ */ new Date(), c4 = i4.duration || 500, u4 = l4 + c4, d4 = i4.onChange || r4, f4 = i4.abort || r4, g4 = i4.onComplete || r4, p4 = i4.easing || n4, m4 = "startValue" in i4 && i4.startValue.length > 0, v4 = "startValue" in i4 ? i4.startValue : 0, _4 = "endValue" in i4 ? i4.endValue : 100, y4 = i4.byValue || (m4 ? v4.map(function(t5, e5) {
          return _4[e5] - v4[e5];
        }) : _4 - v4);
        i4.onStart && i4.onStart(), function t5(i5) {
          var r5 = (e4 = i5 || +/* @__PURE__ */ new Date()) > u4 ? c4 : e4 - l4, n5 = r5 / c4, b4 = m4 ? v4.map(function(t6, e5) {
            return p4(r5, v4[e5], y4[e5], c4);
          }) : p4(r5, v4, y4, c4), w4 = m4 ? Math.abs((b4[0] - v4[0]) / y4[0]) : Math.abs((b4 - v4) / y4);
          if (s5.currentValue = m4 ? b4.slice() : b4, s5.completionRate = w4, s5.durationRate = n5, !o5) {
            if (!f4(b4, w4, n5)) return e4 > u4 ? (s5.currentValue = m4 ? _4.slice() : _4, s5.completionRate = 1, s5.durationRate = 1, d4(m4 ? _4.slice() : _4, 1, 1), g4(_4, 1, 1), void h4()) : (d4(b4, w4, n5), void a4(t5));
            h4();
          }
        }(l4);
      }), s5.cancel;
    }, x3.util.requestAnimFrame = a4, x3.util.cancelAnimFrame = function() {
      return o4.apply(x3.window, arguments);
    }, x3.runningAnimations = i3;
  }(), function() {
    function t3(t4, e3, i3) {
      var r4 = "rgba(" + parseInt(t4[0] + i3 * (e3[0] - t4[0]), 10) + "," + parseInt(t4[1] + i3 * (e3[1] - t4[1]), 10) + "," + parseInt(t4[2] + i3 * (e3[2] - t4[2]), 10);
      return (r4 += "," + (t4 && e3 ? parseFloat(t4[3] + i3 * (e3[3] - t4[3])) : 1)) + ")";
    }
    x3.util.animateColor = function(e3, i3, r4, n4) {
      var s4 = new x3.Color(e3).getSource(), o4 = new x3.Color(i3).getSource(), a4 = n4.onComplete, h4 = n4.onChange;
      return n4 = n4 || {}, x3.util.animate(x3.util.object.extend(n4, { duration: r4 || 500, startValue: s4, endValue: o4, byValue: o4, easing: function(e4, i4, r5, s5) {
        return t3(i4, r5, n4.colorEasing ? n4.colorEasing(e4, s5) : 1 - Math.cos(e4 / s5 * (Math.PI / 2)));
      }, onComplete: function(e4, i4, r5) {
        if (a4) return a4(t3(o4, o4, 0), i4, r5);
      }, onChange: function(e4, i4, r5) {
        if (h4) {
          if (Array.isArray(e4)) return h4(t3(e4, e4, 0), i4, r5);
          h4(e4, i4, r5);
        }
      } }));
    };
  }(), function() {
    function t3(t4, e4, i4, r5) {
      return t4 < Math.abs(e4) ? (t4 = e4, r5 = i4 / 4) : r5 = 0 === e4 && 0 === t4 ? i4 / (2 * Math.PI) * Math.asin(1) : i4 / (2 * Math.PI) * Math.asin(e4 / t4), { a: t4, c: e4, p: i4, s: r5 };
    }
    function e3(t4, e4, i4) {
      return t4.a * Math.pow(2, 10 * (e4 -= 1)) * Math.sin((e4 * i4 - t4.s) * (2 * Math.PI) / t4.p);
    }
    function i3(t4, e4, i4, n4) {
      return i4 - r4(n4 - t4, 0, i4, n4) + e4;
    }
    function r4(t4, e4, i4, r5) {
      return (t4 /= r5) < 1 / 2.75 ? i4 * (7.5625 * t4 * t4) + e4 : t4 < 2 / 2.75 ? i4 * (7.5625 * (t4 -= 1.5 / 2.75) * t4 + 0.75) + e4 : t4 < 2.5 / 2.75 ? i4 * (7.5625 * (t4 -= 2.25 / 2.75) * t4 + 0.9375) + e4 : i4 * (7.5625 * (t4 -= 2.625 / 2.75) * t4 + 0.984375) + e4;
    }
    x3.util.ease = { easeInQuad: function(t4, e4, i4, r5) {
      return i4 * (t4 /= r5) * t4 + e4;
    }, easeOutQuad: function(t4, e4, i4, r5) {
      return -i4 * (t4 /= r5) * (t4 - 2) + e4;
    }, easeInOutQuad: function(t4, e4, i4, r5) {
      return (t4 /= r5 / 2) < 1 ? i4 / 2 * t4 * t4 + e4 : -i4 / 2 * (--t4 * (t4 - 2) - 1) + e4;
    }, easeInCubic: function(t4, e4, i4, r5) {
      return i4 * (t4 /= r5) * t4 * t4 + e4;
    }, easeOutCubic: function(t4, e4, i4, r5) {
      return i4 * ((t4 = t4 / r5 - 1) * t4 * t4 + 1) + e4;
    }, easeInOutCubic: function(t4, e4, i4, r5) {
      return (t4 /= r5 / 2) < 1 ? i4 / 2 * t4 * t4 * t4 + e4 : i4 / 2 * ((t4 -= 2) * t4 * t4 + 2) + e4;
    }, easeInQuart: function(t4, e4, i4, r5) {
      return i4 * (t4 /= r5) * t4 * t4 * t4 + e4;
    }, easeOutQuart: function(t4, e4, i4, r5) {
      return -i4 * ((t4 = t4 / r5 - 1) * t4 * t4 * t4 - 1) + e4;
    }, easeInOutQuart: function(t4, e4, i4, r5) {
      return (t4 /= r5 / 2) < 1 ? i4 / 2 * t4 * t4 * t4 * t4 + e4 : -i4 / 2 * ((t4 -= 2) * t4 * t4 * t4 - 2) + e4;
    }, easeInQuint: function(t4, e4, i4, r5) {
      return i4 * (t4 /= r5) * t4 * t4 * t4 * t4 + e4;
    }, easeOutQuint: function(t4, e4, i4, r5) {
      return i4 * ((t4 = t4 / r5 - 1) * t4 * t4 * t4 * t4 + 1) + e4;
    }, easeInOutQuint: function(t4, e4, i4, r5) {
      return (t4 /= r5 / 2) < 1 ? i4 / 2 * t4 * t4 * t4 * t4 * t4 + e4 : i4 / 2 * ((t4 -= 2) * t4 * t4 * t4 * t4 + 2) + e4;
    }, easeInSine: function(t4, e4, i4, r5) {
      return -i4 * Math.cos(t4 / r5 * (Math.PI / 2)) + i4 + e4;
    }, easeOutSine: function(t4, e4, i4, r5) {
      return i4 * Math.sin(t4 / r5 * (Math.PI / 2)) + e4;
    }, easeInOutSine: function(t4, e4, i4, r5) {
      return -i4 / 2 * (Math.cos(Math.PI * t4 / r5) - 1) + e4;
    }, easeInExpo: function(t4, e4, i4, r5) {
      return 0 === t4 ? e4 : i4 * Math.pow(2, 10 * (t4 / r5 - 1)) + e4;
    }, easeOutExpo: function(t4, e4, i4, r5) {
      return t4 === r5 ? e4 + i4 : i4 * (1 - Math.pow(2, -10 * t4 / r5)) + e4;
    }, easeInOutExpo: function(t4, e4, i4, r5) {
      return 0 === t4 ? e4 : t4 === r5 ? e4 + i4 : (t4 /= r5 / 2) < 1 ? i4 / 2 * Math.pow(2, 10 * (t4 - 1)) + e4 : i4 / 2 * (2 - Math.pow(2, -10 * --t4)) + e4;
    }, easeInCirc: function(t4, e4, i4, r5) {
      return -i4 * (Math.sqrt(1 - (t4 /= r5) * t4) - 1) + e4;
    }, easeOutCirc: function(t4, e4, i4, r5) {
      return i4 * Math.sqrt(1 - (t4 = t4 / r5 - 1) * t4) + e4;
    }, easeInOutCirc: function(t4, e4, i4, r5) {
      return (t4 /= r5 / 2) < 1 ? -i4 / 2 * (Math.sqrt(1 - t4 * t4) - 1) + e4 : i4 / 2 * (Math.sqrt(1 - (t4 -= 2) * t4) + 1) + e4;
    }, easeInElastic: function(i4, r5, n4, s4) {
      var o4 = 0;
      return 0 === i4 ? r5 : 1 == (i4 /= s4) ? r5 + n4 : (o4 || (o4 = 0.3 * s4), -e3(t3(n4, n4, o4, 1.70158), i4, s4) + r5);
    }, easeOutElastic: function(e4, i4, r5, n4) {
      var s4 = 0;
      if (0 === e4) return i4;
      if (1 == (e4 /= n4)) return i4 + r5;
      s4 || (s4 = 0.3 * n4);
      var o4 = t3(r5, r5, s4, 1.70158);
      return o4.a * Math.pow(2, -10 * e4) * Math.sin((e4 * n4 - o4.s) * (2 * Math.PI) / o4.p) + o4.c + i4;
    }, easeInOutElastic: function(i4, r5, n4, s4) {
      var o4 = 0;
      if (0 === i4) return r5;
      if (2 == (i4 /= s4 / 2)) return r5 + n4;
      o4 || (o4 = s4 * (0.3 * 1.5));
      var a4 = t3(n4, n4, o4, 1.70158);
      return i4 < 1 ? -0.5 * e3(a4, i4, s4) + r5 : a4.a * Math.pow(2, -10 * (i4 -= 1)) * Math.sin((i4 * s4 - a4.s) * (2 * Math.PI) / a4.p) * 0.5 + a4.c + r5;
    }, easeInBack: function(t4, e4, i4, r5, n4) {
      return void 0 === n4 && (n4 = 1.70158), i4 * (t4 /= r5) * t4 * ((n4 + 1) * t4 - n4) + e4;
    }, easeOutBack: function(t4, e4, i4, r5, n4) {
      return void 0 === n4 && (n4 = 1.70158), i4 * ((t4 = t4 / r5 - 1) * t4 * ((n4 + 1) * t4 + n4) + 1) + e4;
    }, easeInOutBack: function(t4, e4, i4, r5, n4) {
      return void 0 === n4 && (n4 = 1.70158), (t4 /= r5 / 2) < 1 ? i4 / 2 * (t4 * t4 * ((1 + (n4 *= 1.525)) * t4 - n4)) + e4 : i4 / 2 * ((t4 -= 2) * t4 * ((1 + (n4 *= 1.525)) * t4 + n4) + 2) + e4;
    }, easeInBounce: i3, easeOutBounce: r4, easeInOutBounce: function(t4, e4, n4, s4) {
      return t4 < s4 / 2 ? 0.5 * i3(2 * t4, 0, n4, s4) + e4 : 0.5 * r4(2 * t4 - s4, 0, n4, s4) + 0.5 * n4 + e4;
    } };
  }(), function(t3) {
    var e3 = t3.fabric || (t3.fabric = {}), i3 = e3.util.object.extend, r4 = e3.util.object.clone, n4 = e3.util.toFixed, s4 = e3.util.parseUnit, o4 = e3.util.multiplyTransformMatrices, a4 = { cx: "left", x: "left", r: "radius", cy: "top", y: "top", display: "visible", visibility: "visible", transform: "transformMatrix", "fill-opacity": "fillOpacity", "fill-rule": "fillRule", "font-family": "fontFamily", "font-size": "fontSize", "font-style": "fontStyle", "font-weight": "fontWeight", "letter-spacing": "charSpacing", "paint-order": "paintFirst", "stroke-dasharray": "strokeDashArray", "stroke-dashoffset": "strokeDashOffset", "stroke-linecap": "strokeLineCap", "stroke-linejoin": "strokeLineJoin", "stroke-miterlimit": "strokeMiterLimit", "stroke-opacity": "strokeOpacity", "stroke-width": "strokeWidth", "text-decoration": "textDecoration", "text-anchor": "textAnchor", opacity: "opacity", "clip-path": "clipPath", "clip-rule": "clipRule", "vector-effect": "strokeUniform", "image-rendering": "imageSmoothing" }, h4 = { stroke: "strokeOpacity", fill: "fillOpacity" }, l4 = "font-size", c4 = "clip-path";
    function u4(t4) {
      return t4 in a4 ? a4[t4] : t4;
    }
    function d4(t4, i4, r5, n5) {
      var a5, h5 = Array.isArray(i4);
      if ("fill" !== t4 && "stroke" !== t4 || "none" !== i4) {
        if ("strokeUniform" === t4) return "non-scaling-stroke" === i4;
        if ("strokeDashArray" === t4) i4 = "none" === i4 ? null : i4.replace(/,/g, " ").split(/\s+/).map(parseFloat);
        else if ("transformMatrix" === t4) i4 = r5 && r5.transformMatrix ? o4(r5.transformMatrix, e3.parseTransformAttribute(i4)) : e3.parseTransformAttribute(i4);
        else if ("visible" === t4) i4 = "none" !== i4 && "hidden" !== i4, r5 && false === r5.visible && (i4 = false);
        else if ("opacity" === t4) i4 = parseFloat(i4), r5 && void 0 !== r5.opacity && (i4 *= r5.opacity);
        else if ("textAnchor" === t4) i4 = "start" === i4 ? "left" : "end" === i4 ? "right" : "center";
        else if ("charSpacing" === t4) a5 = s4(i4, n5) / n5 * 1e3;
        else if ("paintFirst" === t4) {
          var l5 = i4.indexOf("fill"), c5 = i4.indexOf("stroke");
          i4 = "fill", (l5 > -1 && c5 > -1 && c5 < l5 || -1 === l5 && c5 > -1) && (i4 = "stroke");
        } else {
          if ("href" === t4 || "xlink:href" === t4 || "font" === t4) return i4;
          if ("imageSmoothing" === t4) return "optimizeQuality" === i4;
          a5 = h5 ? i4.map(s4) : s4(i4, n5);
        }
      } else i4 = "";
      return !h5 && isNaN(a5) ? i4 : a5;
    }
    function f4(t4) {
      return new RegExp("^(" + t4.join("|") + ")\\b", "i");
    }
    function g4(t4, e4) {
      var i4, r5, n5, s5, o5 = [];
      for (n5 = 0, s5 = e4.length; n5 < s5; n5++) i4 = e4[n5], r5 = t4.getElementsByTagName(i4), o5 = o5.concat(Array.prototype.slice.call(r5));
      return o5;
    }
    function p4(t4, e4) {
      var i4, r5 = true;
      return (i4 = m4(t4, e4.pop())) && e4.length && (r5 = function(t5, e5) {
        for (var i5, r6 = true; t5.parentNode && 1 === t5.parentNode.nodeType && e5.length; ) r6 && (i5 = e5.pop()), r6 = m4(t5 = t5.parentNode, i5);
        return 0 === e5.length;
      }(t4, e4)), i4 && r5 && 0 === e4.length;
    }
    function m4(t4, e4) {
      var i4, r5, n5 = t4.nodeName, s5 = t4.getAttribute("class"), o5 = t4.getAttribute("id");
      if (i4 = new RegExp("^" + n5, "i"), e4 = e4.replace(i4, ""), o5 && e4.length && (i4 = new RegExp("#" + o5 + "(?![a-zA-Z\\-]+)", "i"), e4 = e4.replace(i4, "")), s5 && e4.length) for (r5 = (s5 = s5.split(" ")).length; r5--; ) i4 = new RegExp("\\." + s5[r5] + "(?![a-zA-Z\\-]+)", "i"), e4 = e4.replace(i4, "");
      return 0 === e4.length;
    }
    function v4(t4, e4) {
      var i4;
      if (t4.getElementById && (i4 = t4.getElementById(e4)), i4) return i4;
      var r5, n5, s5, o5 = t4.getElementsByTagName("*");
      for (n5 = 0, s5 = o5.length; n5 < s5; n5++) if (e4 === (r5 = o5[n5]).getAttribute("id")) return r5;
    }
    e3.svgValidTagNamesRegEx = f4(["path", "circle", "polygon", "polyline", "ellipse", "rect", "line", "image", "text"]), e3.svgViewBoxElementsRegEx = f4(["symbol", "image", "marker", "pattern", "view", "svg"]), e3.svgInvalidAncestorsRegEx = f4(["pattern", "defs", "symbol", "metadata", "clipPath", "mask", "desc"]), e3.svgValidParentsRegEx = f4(["symbol", "g", "a", "svg", "clipPath", "defs"]), e3.cssRules = {}, e3.gradientDefs = {}, e3.clipPaths = {}, e3.parseTransformAttribute = function() {
      function t4(t5, i5, r6) {
        t5[r6] = Math.tan(e3.util.degreesToRadians(i5[0]));
      }
      var i4 = e3.iMatrix, r5 = e3.reNum, n5 = e3.commaWsp, s5 = "(?:(?:(matrix)\\s*\\(\\s*(" + r5 + ")" + n5 + "(" + r5 + ")" + n5 + "(" + r5 + ")" + n5 + "(" + r5 + ")" + n5 + "(" + r5 + ")" + n5 + "(" + r5 + ")\\s*\\))|(?:(translate)\\s*\\(\\s*(" + r5 + ")(?:" + n5 + "(" + r5 + "))?\\s*\\))|(?:(scale)\\s*\\(\\s*(" + r5 + ")(?:" + n5 + "(" + r5 + "))?\\s*\\))|(?:(rotate)\\s*\\(\\s*(" + r5 + ")(?:" + n5 + "(" + r5 + ")" + n5 + "(" + r5 + "))?\\s*\\))|(?:(skewX)\\s*\\(\\s*(" + r5 + ")\\s*\\))|(?:(skewY)\\s*\\(\\s*(" + r5 + ")\\s*\\)))", o5 = new RegExp("^\\s*(?:(?:" + s5 + "(?:" + n5 + "*" + s5 + ")*)?)\\s*$"), a5 = new RegExp(s5, "g");
      return function(r6) {
        var n6 = i4.concat(), h5 = [];
        if (!r6 || r6 && !o5.test(r6)) return n6;
        r6.replace(a5, function(r7) {
          var o6 = new RegExp(s5).exec(r7).filter(function(t5) {
            return !!t5;
          }), a6 = o6[1], l6 = o6.slice(2).map(parseFloat);
          switch (a6) {
            case "translate":
              !function(t5, e4) {
                t5[4] = e4[0], 2 === e4.length && (t5[5] = e4[1]);
              }(n6, l6);
              break;
            case "rotate":
              l6[0] = e3.util.degreesToRadians(l6[0]), function(t5, i5) {
                var r8 = e3.util.cos(i5[0]), n7 = e3.util.sin(i5[0]), s6 = 0, o7 = 0;
                3 === i5.length && (s6 = i5[1], o7 = i5[2]), t5[0] = r8, t5[1] = n7, t5[2] = -n7, t5[3] = r8, t5[4] = s6 - (r8 * s6 - n7 * o7), t5[5] = o7 - (n7 * s6 + r8 * o7);
              }(n6, l6);
              break;
            case "scale":
              !function(t5, e4) {
                var i5 = e4[0], r8 = 2 === e4.length ? e4[1] : e4[0];
                t5[0] = i5, t5[3] = r8;
              }(n6, l6);
              break;
            case "skewX":
              t4(n6, l6, 2);
              break;
            case "skewY":
              t4(n6, l6, 1);
              break;
            case "matrix":
              n6 = l6;
          }
          h5.push(n6.concat()), n6 = i4.concat();
        });
        for (var l5 = h5[0]; h5.length > 1; ) h5.shift(), l5 = e3.util.multiplyTransformMatrices(l5, h5[0]);
        return l5;
      };
    }();
    var _4 = new RegExp("^\\s*(" + e3.reNum + "+)\\s*,?\\s*(" + e3.reNum + "+)\\s*,?\\s*(" + e3.reNum + "+)\\s*,?\\s*(" + e3.reNum + "+)\\s*$");
    function y4(t4) {
      if (!e3.svgViewBoxElementsRegEx.test(t4.nodeName)) return {};
      var i4, r5, n5, o5, a5, h5, l5 = t4.getAttribute("viewBox"), c5 = 1, u5 = 1, d5 = t4.getAttribute("width"), f5 = t4.getAttribute("height"), g5 = t4.getAttribute("x") || 0, p5 = t4.getAttribute("y") || 0, m5 = t4.getAttribute("preserveAspectRatio") || "", v5 = !l5 || !(l5 = l5.match(_4)), y5 = !d5 || !f5 || "100%" === d5 || "100%" === f5, b5 = v5 && y5, w5 = {}, C4 = "", S4 = 0, x4 = 0;
      if (w5.width = 0, w5.height = 0, w5.toBeParsed = b5, v5 && (g5 || p5) && t4.parentNode && "#document" !== t4.parentNode.nodeName && (C4 = " translate(" + s4(g5) + " " + s4(p5) + ") ", a5 = (t4.getAttribute("transform") || "") + C4, t4.setAttribute("transform", a5), t4.removeAttribute("x"), t4.removeAttribute("y")), b5) return w5;
      if (v5) return w5.width = s4(d5), w5.height = s4(f5), w5;
      if (i4 = -parseFloat(l5[1]), r5 = -parseFloat(l5[2]), n5 = parseFloat(l5[3]), o5 = parseFloat(l5[4]), w5.minX = i4, w5.minY = r5, w5.viewBoxWidth = n5, w5.viewBoxHeight = o5, y5 ? (w5.width = n5, w5.height = o5) : (w5.width = s4(d5), w5.height = s4(f5), c5 = w5.width / n5, u5 = w5.height / o5), "none" !== (m5 = e3.util.parsePreserveAspectRatioAttribute(m5)).alignX && ("meet" === m5.meetOrSlice && (u5 = c5 = c5 > u5 ? u5 : c5), "slice" === m5.meetOrSlice && (u5 = c5 = c5 > u5 ? c5 : u5), S4 = w5.width - n5 * c5, x4 = w5.height - o5 * c5, "Mid" === m5.alignX && (S4 /= 2), "Mid" === m5.alignY && (x4 /= 2), "Min" === m5.alignX && (S4 = 0), "Min" === m5.alignY && (x4 = 0)), 1 === c5 && 1 === u5 && 0 === i4 && 0 === r5 && 0 === g5 && 0 === p5) return w5;
      if ((g5 || p5) && "#document" !== t4.parentNode.nodeName && (C4 = " translate(" + s4(g5) + " " + s4(p5) + ") "), a5 = C4 + " matrix(" + c5 + " 0 0 " + u5 + " " + (i4 * c5 + S4) + " " + (r5 * u5 + x4) + ") ", "svg" === t4.nodeName) {
        for (h5 = t4.ownerDocument.createElementNS(e3.svgNS, "g"); t4.firstChild; ) h5.appendChild(t4.firstChild);
        t4.appendChild(h5);
      } else (h5 = t4).removeAttribute("x"), h5.removeAttribute("y"), a5 = h5.getAttribute("transform") + a5;
      return h5.setAttribute("transform", a5), w5;
    }
    function b4(t4, e4) {
      var i4 = "xlink:href", r5 = v4(t4, e4.getAttribute(i4).slice(1));
      if (r5 && r5.getAttribute(i4) && b4(t4, r5), ["gradientTransform", "x1", "x2", "y1", "y2", "gradientUnits", "cx", "cy", "r", "fx", "fy"].forEach(function(t5) {
        r5 && !e4.hasAttribute(t5) && r5.hasAttribute(t5) && e4.setAttribute(t5, r5.getAttribute(t5));
      }), !e4.children.length) for (var n5 = r5.cloneNode(true); n5.firstChild; ) e4.appendChild(n5.firstChild);
      e4.removeAttribute(i4);
    }
    e3.parseSVGDocument = function(t4, i4, n5, s5) {
      if (t4) {
        !function(t5) {
          for (var i5 = g4(t5, ["use", "svg:use"]), r5 = 0; i5.length && r5 < i5.length; ) {
            var n6 = i5[r5], s6 = n6.getAttribute("xlink:href") || n6.getAttribute("href");
            if (null === s6) return;
            var o6, a6, h6, l6, c6 = s6.slice(1), u6 = n6.getAttribute("x") || 0, d6 = n6.getAttribute("y") || 0, f6 = v4(t5, c6).cloneNode(true), p5 = (f6.getAttribute("transform") || "") + " translate(" + u6 + ", " + d6 + ")", m5 = i5.length, _5 = e3.svgNS;
            if (y4(f6), /^svg$/i.test(f6.nodeName)) {
              var b5 = f6.ownerDocument.createElementNS(_5, "g");
              for (a6 = 0, l6 = (h6 = f6.attributes).length; a6 < l6; a6++) o6 = h6.item(a6), b5.setAttributeNS(_5, o6.nodeName, o6.nodeValue);
              for (; f6.firstChild; ) b5.appendChild(f6.firstChild);
              f6 = b5;
            }
            for (a6 = 0, l6 = (h6 = n6.attributes).length; a6 < l6; a6++) "x" !== (o6 = h6.item(a6)).nodeName && "y" !== o6.nodeName && "xlink:href" !== o6.nodeName && "href" !== o6.nodeName && ("transform" === o6.nodeName ? p5 = o6.nodeValue + " " + p5 : f6.setAttribute(o6.nodeName, o6.nodeValue));
            f6.setAttribute("transform", p5), f6.setAttribute("instantiated_by_use", "1"), f6.removeAttribute("id"), n6.parentNode.replaceChild(f6, n6), i5.length === m5 && r5++;
          }
        }(t4);
        var o5, a5, h5 = e3.Object.__uid++, l5 = y4(t4), c5 = e3.util.toArray(t4.getElementsByTagName("*"));
        if (l5.crossOrigin = s5 && s5.crossOrigin, l5.svgUid = h5, 0 === c5.length && e3.isLikelyNode) {
          var u5 = [];
          for (o5 = 0, a5 = (c5 = t4.selectNodes('//*[name(.)!="svg"]')).length; o5 < a5; o5++) u5[o5] = c5[o5];
          c5 = u5;
        }
        var d5 = c5.filter(function(t5) {
          return y4(t5), e3.svgValidTagNamesRegEx.test(t5.nodeName.replace("svg:", "")) && !function(t6, e4) {
            for (; t6 && (t6 = t6.parentNode); ) if (t6.nodeName && e4.test(t6.nodeName.replace("svg:", "")) && !t6.getAttribute("instantiated_by_use")) return true;
            return false;
          }(t5, e3.svgInvalidAncestorsRegEx);
        });
        if (!d5 || d5 && !d5.length) i4 && i4([], {});
        else {
          var f5 = {};
          c5.filter(function(t5) {
            return "clipPath" === t5.nodeName.replace("svg:", "");
          }).forEach(function(t5) {
            var i5 = t5.getAttribute("id");
            f5[i5] = e3.util.toArray(t5.getElementsByTagName("*")).filter(function(t6) {
              return e3.svgValidTagNamesRegEx.test(t6.nodeName.replace("svg:", ""));
            });
          }), e3.gradientDefs[h5] = e3.getGradientDefs(t4), e3.cssRules[h5] = e3.getCSSRules(t4), e3.clipPaths[h5] = f5, e3.parseElements(d5, function(t5, r5) {
            i4 && (i4(t5, l5, r5, c5), delete e3.gradientDefs[h5], delete e3.cssRules[h5], delete e3.clipPaths[h5]);
          }, r4(l5), n5, s5);
        }
      }
    };
    var w4 = new RegExp("(normal|italic)?\\s*(normal|small-caps)?\\s*(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)?\\s*(" + e3.reNum + "(?:px|cm|mm|em|pt|pc|in)*)(?:\\/(normal|" + e3.reNum + "))?\\s+(.*)");
    i3(e3, { parseFontDeclaration: function(t4, e4) {
      var i4 = t4.match(w4);
      if (i4) {
        var r5 = i4[1], n5 = i4[3], o5 = i4[4], a5 = i4[5], h5 = i4[6];
        r5 && (e4.fontStyle = r5), n5 && (e4.fontWeight = isNaN(parseFloat(n5)) ? n5 : parseFloat(n5)), o5 && (e4.fontSize = s4(o5)), h5 && (e4.fontFamily = h5), a5 && (e4.lineHeight = "normal" === a5 ? 1 : a5);
      }
    }, getGradientDefs: function(t4) {
      var e4, i4 = g4(t4, ["linearGradient", "radialGradient", "svg:linearGradient", "svg:radialGradient"]), r5 = 0, n5 = {};
      for (r5 = i4.length; r5--; ) (e4 = i4[r5]).getAttribute("xlink:href") && b4(t4, e4), n5[e4.getAttribute("id")] = e4;
      return n5;
    }, parseAttributes: function(t4, r5, o5) {
      if (t4) {
        var a5, f5, g5, m5 = {};
        void 0 === o5 && (o5 = t4.getAttribute("svgUid")), t4.parentNode && e3.svgValidParentsRegEx.test(t4.parentNode.nodeName) && (m5 = e3.parseAttributes(t4.parentNode, r5, o5));
        var v5 = r5.reduce(function(e4, i4) {
          return (a5 = t4.getAttribute(i4)) && (e4[i4] = a5), e4;
        }, {}), _5 = i3(function(t5, i4) {
          var r6 = {};
          for (var n5 in e3.cssRules[i4]) if (p4(t5, n5.split(" "))) for (var s5 in e3.cssRules[i4][n5]) r6[s5] = e3.cssRules[i4][n5][s5];
          return r6;
        }(t4, o5), e3.parseStyleAttribute(t4));
        v5 = i3(v5, _5), _5[c4] && t4.setAttribute(c4, _5[c4]), f5 = g5 = m5.fontSize || e3.Text.DEFAULT_SVG_FONT_SIZE, v5[l4] && (v5[l4] = f5 = s4(v5[l4], g5));
        var y5, b5, w5 = {};
        for (var C4 in v5) b5 = d4(y5 = u4(C4), v5[C4], m5, f5), w5[y5] = b5;
        w5 && w5.font && e3.parseFontDeclaration(w5.font, w5);
        var S4 = i3(m5, w5);
        return e3.svgValidParentsRegEx.test(t4.nodeName) ? S4 : function(t5) {
          for (var i4 in h4) if (void 0 !== t5[h4[i4]] && "" !== t5[i4]) {
            if (void 0 === t5[i4]) {
              if (!e3.Object.prototype[i4]) continue;
              t5[i4] = e3.Object.prototype[i4];
            }
            if (0 !== t5[i4].indexOf("url(")) {
              var r6 = new e3.Color(t5[i4]);
              t5[i4] = r6.setAlpha(n4(r6.getAlpha() * t5[h4[i4]], 2)).toRgba();
            }
          }
          return t5;
        }(S4);
      }
    }, parseElements: function(t4, i4, r5, n5, s5) {
      new e3.ElementsParser(t4, i4, r5, n5, s5).parse();
    }, parseStyleAttribute: function(t4) {
      var e4 = {}, i4 = t4.getAttribute("style");
      return i4 ? ("string" == typeof i4 ? function(t5, e5) {
        var i5, r5;
        t5.replace(/;\s*$/, "").split(";").forEach(function(t6) {
          var n5 = t6.split(":");
          i5 = n5[0].trim().toLowerCase(), r5 = n5[1].trim(), e5[i5] = r5;
        });
      }(i4, e4) : function(t5, e5) {
        var i5, r5;
        for (var n5 in t5) void 0 !== t5[n5] && (i5 = n5.toLowerCase(), r5 = t5[n5], e5[i5] = r5);
      }(i4, e4), e4) : e4;
    }, parsePointsAttribute: function(t4) {
      if (!t4) return null;
      var e4, i4, r5 = [];
      for (e4 = 0, i4 = (t4 = (t4 = t4.replace(/,/g, " ").trim()).split(/\s+/)).length; e4 < i4; e4 += 2) r5.push({ x: parseFloat(t4[e4]), y: parseFloat(t4[e4 + 1]) });
      return r5;
    }, getCSSRules: function(t4) {
      var i4, r5, n5 = t4.getElementsByTagName("style"), s5 = {};
      for (i4 = 0, r5 = n5.length; i4 < r5; i4++) {
        var o5 = n5[i4].textContent;
        "" !== (o5 = o5.replace(/\/\*[\s\S]*?\*\//g, "")).trim() && o5.split("}").filter(function(t5) {
          return t5.trim();
        }).forEach(function(t5) {
          var n6 = t5.split("{"), o6 = {}, a5 = n6[1].trim().split(";").filter(function(t6) {
            return t6.trim();
          });
          for (i4 = 0, r5 = a5.length; i4 < r5; i4++) {
            var h5 = a5[i4].split(":"), l5 = h5[0].trim(), c5 = h5[1].trim();
            o6[l5] = c5;
          }
          (t5 = n6[0].trim()).split(",").forEach(function(t6) {
            "" !== (t6 = t6.replace(/^svg/i, "").trim()) && (s5[t6] ? e3.util.object.extend(s5[t6], o6) : s5[t6] = e3.util.object.clone(o6));
          });
        });
      }
      return s5;
    }, loadSVGFromURL: function(t4, i4, r5, n5) {
      t4 = t4.replace(/^\n\s*/, "").trim(), new e3.util.request(t4, { method: "get", onComplete: function(t5) {
        var s5 = t5.responseXML;
        if (!s5 || !s5.documentElement) return i4 && i4(null), false;
        e3.parseSVGDocument(s5.documentElement, function(t6, e4, r6, n6) {
          i4 && i4(t6, e4, r6, n6);
        }, r5, n5);
      } });
    }, loadSVGFromString: function(t4, i4, r5, n5) {
      var s5 = new e3.window.DOMParser().parseFromString(t4.trim(), "text/xml");
      e3.parseSVGDocument(s5.documentElement, function(t5, e4, r6, n6) {
        i4(t5, e4, r6, n6);
      }, r5, n5);
    } });
  }(e2), x3.ElementsParser = function(t3, e3, i3, r4, n4, s4) {
    this.elements = t3, this.callback = e3, this.options = i3, this.reviver = r4, this.svgUid = i3 && i3.svgUid || 0, this.parsingOptions = n4, this.regexUrl = /^url\(['"]?#([^'"]+)['"]?\)/g, this.doc = s4;
  }, (m3 = x3.ElementsParser.prototype).parse = function() {
    this.instances = new Array(this.elements.length), this.numElements = this.elements.length, this.createObjects();
  }, m3.createObjects = function() {
    var t3 = this;
    this.elements.forEach(function(e3, i3) {
      e3.setAttribute("svgUid", t3.svgUid), t3.createObject(e3, i3);
    });
  }, m3.findTag = function(t3) {
    return x3[x3.util.string.capitalize(t3.tagName.replace("svg:", ""))];
  }, m3.createObject = function(t3, e3) {
    var i3 = this.findTag(t3);
    if (i3 && i3.fromElement) try {
      i3.fromElement(t3, this.createCallback(e3, t3), this.options);
    } catch (t4) {
      x3.log(t4);
    }
    else this.checkIfDone();
  }, m3.createCallback = function(t3, e3) {
    var i3 = this;
    return function(r4) {
      var n4;
      i3.resolveGradient(r4, e3, "fill"), i3.resolveGradient(r4, e3, "stroke"), r4 instanceof x3.Image && r4._originalElement && (n4 = r4.parsePreserveAspectRatioAttribute(e3)), r4._removeTransformMatrix(n4), i3.resolveClipPath(r4, e3), i3.reviver && i3.reviver(e3, r4), i3.instances[t3] = r4, i3.checkIfDone();
    };
  }, m3.extractPropertyDefinition = function(t3, e3, i3) {
    var r4 = t3[e3], n4 = this.regexUrl;
    if (n4.test(r4)) {
      n4.lastIndex = 0;
      var s4 = n4.exec(r4)[1];
      return n4.lastIndex = 0, x3[i3][this.svgUid][s4];
    }
  }, m3.resolveGradient = function(t3, e3, i3) {
    var r4 = this.extractPropertyDefinition(t3, i3, "gradientDefs");
    if (r4) {
      var n4 = e3.getAttribute(i3 + "-opacity"), s4 = x3.Gradient.fromElement(r4, t3, n4, this.options);
      t3.set(i3, s4);
    }
  }, m3.createClipPathCallback = function(t3, e3) {
    return function(t4) {
      t4._removeTransformMatrix(), t4.fillRule = t4.clipRule, e3.push(t4);
    };
  }, m3.resolveClipPath = function(t3, e3) {
    var i3, r4, n4, s4, o4 = this.extractPropertyDefinition(t3, "clipPath", "clipPaths");
    if (o4) {
      n4 = [], r4 = x3.util.invertTransform(t3.calcTransformMatrix());
      for (var a4 = o4[0].parentNode, h4 = e3; h4.parentNode && h4.getAttribute("clip-path") !== t3.clipPath; ) h4 = h4.parentNode;
      h4.parentNode.appendChild(a4);
      for (var l4 = 0; l4 < o4.length; l4++) i3 = o4[l4], this.findTag(i3).fromElement(i3, this.createClipPathCallback(t3, n4), this.options);
      o4 = 1 === n4.length ? n4[0] : new x3.Group(n4), s4 = x3.util.multiplyTransformMatrices(r4, o4.calcTransformMatrix()), o4.clipPath && this.resolveClipPath(o4, h4);
      var c4 = x3.util.qrDecompose(s4);
      o4.flipX = false, o4.flipY = false, o4.set("scaleX", c4.scaleX), o4.set("scaleY", c4.scaleY), o4.angle = c4.angle, o4.skewX = c4.skewX, o4.skewY = 0, o4.setPositionByOrigin({ x: c4.translateX, y: c4.translateY }, "center", "center"), t3.clipPath = o4;
    } else delete t3.clipPath;
  }, m3.checkIfDone = function() {
    0 == --this.numElements && (this.instances = this.instances.filter(function(t3) {
      return null != t3;
    }), this.callback(this.instances, this.elements));
  }, function(t3) {
    var e3 = t3.fabric || (t3.fabric = {});
    function i3(t4, e4) {
      this.x = t4, this.y = e4;
    }
    e3.Point ? e3.warn("fabric.Point is already defined") : (e3.Point = i3, i3.prototype = { type: "point", constructor: i3, add: function(t4) {
      return new i3(this.x + t4.x, this.y + t4.y);
    }, addEquals: function(t4) {
      return this.x += t4.x, this.y += t4.y, this;
    }, scalarAdd: function(t4) {
      return new i3(this.x + t4, this.y + t4);
    }, scalarAddEquals: function(t4) {
      return this.x += t4, this.y += t4, this;
    }, subtract: function(t4) {
      return new i3(this.x - t4.x, this.y - t4.y);
    }, subtractEquals: function(t4) {
      return this.x -= t4.x, this.y -= t4.y, this;
    }, scalarSubtract: function(t4) {
      return new i3(this.x - t4, this.y - t4);
    }, scalarSubtractEquals: function(t4) {
      return this.x -= t4, this.y -= t4, this;
    }, multiply: function(t4) {
      return new i3(this.x * t4, this.y * t4);
    }, multiplyEquals: function(t4) {
      return this.x *= t4, this.y *= t4, this;
    }, divide: function(t4) {
      return new i3(this.x / t4, this.y / t4);
    }, divideEquals: function(t4) {
      return this.x /= t4, this.y /= t4, this;
    }, eq: function(t4) {
      return this.x === t4.x && this.y === t4.y;
    }, lt: function(t4) {
      return this.x < t4.x && this.y < t4.y;
    }, lte: function(t4) {
      return this.x <= t4.x && this.y <= t4.y;
    }, gt: function(t4) {
      return this.x > t4.x && this.y > t4.y;
    }, gte: function(t4) {
      return this.x >= t4.x && this.y >= t4.y;
    }, lerp: function(t4, e4) {
      return void 0 === e4 && (e4 = 0.5), e4 = Math.max(Math.min(1, e4), 0), new i3(this.x + (t4.x - this.x) * e4, this.y + (t4.y - this.y) * e4);
    }, distanceFrom: function(t4) {
      var e4 = this.x - t4.x, i4 = this.y - t4.y;
      return Math.sqrt(e4 * e4 + i4 * i4);
    }, midPointFrom: function(t4) {
      return this.lerp(t4);
    }, min: function(t4) {
      return new i3(Math.min(this.x, t4.x), Math.min(this.y, t4.y));
    }, max: function(t4) {
      return new i3(Math.max(this.x, t4.x), Math.max(this.y, t4.y));
    }, toString: function() {
      return this.x + "," + this.y;
    }, setXY: function(t4, e4) {
      return this.x = t4, this.y = e4, this;
    }, setX: function(t4) {
      return this.x = t4, this;
    }, setY: function(t4) {
      return this.y = t4, this;
    }, setFromPoint: function(t4) {
      return this.x = t4.x, this.y = t4.y, this;
    }, swap: function(t4) {
      var e4 = this.x, i4 = this.y;
      this.x = t4.x, this.y = t4.y, t4.x = e4, t4.y = i4;
    }, clone: function() {
      return new i3(this.x, this.y);
    } });
  }(e2), function(t3) {
    var e3 = t3.fabric || (t3.fabric = {});
    function i3(t4) {
      this.status = t4, this.points = [];
    }
    e3.Intersection ? e3.warn("fabric.Intersection is already defined") : (e3.Intersection = i3, e3.Intersection.prototype = { constructor: i3, appendPoint: function(t4) {
      return this.points.push(t4), this;
    }, appendPoints: function(t4) {
      return this.points = this.points.concat(t4), this;
    } }, e3.Intersection.intersectLineLine = function(t4, r4, n4, s4) {
      var o4, a4 = (s4.x - n4.x) * (t4.y - n4.y) - (s4.y - n4.y) * (t4.x - n4.x), h4 = (r4.x - t4.x) * (t4.y - n4.y) - (r4.y - t4.y) * (t4.x - n4.x), l4 = (s4.y - n4.y) * (r4.x - t4.x) - (s4.x - n4.x) * (r4.y - t4.y);
      if (0 !== l4) {
        var c4 = a4 / l4, u4 = h4 / l4;
        0 <= c4 && c4 <= 1 && 0 <= u4 && u4 <= 1 ? (o4 = new i3("Intersection")).appendPoint(new e3.Point(t4.x + c4 * (r4.x - t4.x), t4.y + c4 * (r4.y - t4.y))) : o4 = new i3();
      } else o4 = new i3(0 === a4 || 0 === h4 ? "Coincident" : "Parallel");
      return o4;
    }, e3.Intersection.intersectLinePolygon = function(t4, e4, r4) {
      var n4, s4, o4, a4, h4 = new i3(), l4 = r4.length;
      for (a4 = 0; a4 < l4; a4++) n4 = r4[a4], s4 = r4[(a4 + 1) % l4], o4 = i3.intersectLineLine(t4, e4, n4, s4), h4.appendPoints(o4.points);
      return h4.points.length > 0 && (h4.status = "Intersection"), h4;
    }, e3.Intersection.intersectPolygonPolygon = function(t4, e4) {
      var r4, n4 = new i3(), s4 = t4.length;
      for (r4 = 0; r4 < s4; r4++) {
        var o4 = t4[r4], a4 = t4[(r4 + 1) % s4], h4 = i3.intersectLinePolygon(o4, a4, e4);
        n4.appendPoints(h4.points);
      }
      return n4.points.length > 0 && (n4.status = "Intersection"), n4;
    }, e3.Intersection.intersectPolygonRectangle = function(t4, r4, n4) {
      var s4 = r4.min(n4), o4 = r4.max(n4), a4 = new e3.Point(o4.x, s4.y), h4 = new e3.Point(s4.x, o4.y), l4 = i3.intersectLinePolygon(s4, a4, t4), c4 = i3.intersectLinePolygon(a4, o4, t4), u4 = i3.intersectLinePolygon(o4, h4, t4), d4 = i3.intersectLinePolygon(h4, s4, t4), f4 = new i3();
      return f4.appendPoints(l4.points), f4.appendPoints(c4.points), f4.appendPoints(u4.points), f4.appendPoints(d4.points), f4.points.length > 0 && (f4.status = "Intersection"), f4;
    });
  }(e2), function(t3) {
    var e3 = t3.fabric || (t3.fabric = {});
    function i3(t4) {
      t4 ? this._tryParsingColor(t4) : this.setSource([0, 0, 0, 1]);
    }
    function r4(t4, e4, i4) {
      return i4 < 0 && (i4 += 1), i4 > 1 && (i4 -= 1), i4 < 1 / 6 ? t4 + 6 * (e4 - t4) * i4 : i4 < 0.5 ? e4 : i4 < 2 / 3 ? t4 + (e4 - t4) * (2 / 3 - i4) * 6 : t4;
    }
    e3.Color ? e3.warn("fabric.Color is already defined.") : (e3.Color = i3, e3.Color.prototype = { _tryParsingColor: function(t4) {
      var e4;
      t4 in i3.colorNameMap && (t4 = i3.colorNameMap[t4]), "transparent" === t4 && (e4 = [255, 255, 255, 0]), e4 || (e4 = i3.sourceFromHex(t4)), e4 || (e4 = i3.sourceFromRgb(t4)), e4 || (e4 = i3.sourceFromHsl(t4)), e4 || (e4 = [0, 0, 0, 1]), e4 && this.setSource(e4);
    }, _rgbToHsl: function(t4, i4, r5) {
      t4 /= 255, i4 /= 255, r5 /= 255;
      var n4, s4, o4, a4 = e3.util.array.max([t4, i4, r5]), h4 = e3.util.array.min([t4, i4, r5]);
      if (o4 = (a4 + h4) / 2, a4 === h4) n4 = s4 = 0;
      else {
        var l4 = a4 - h4;
        switch (s4 = o4 > 0.5 ? l4 / (2 - a4 - h4) : l4 / (a4 + h4), a4) {
          case t4:
            n4 = (i4 - r5) / l4 + (i4 < r5 ? 6 : 0);
            break;
          case i4:
            n4 = (r5 - t4) / l4 + 2;
            break;
          case r5:
            n4 = (t4 - i4) / l4 + 4;
        }
        n4 /= 6;
      }
      return [Math.round(360 * n4), Math.round(100 * s4), Math.round(100 * o4)];
    }, getSource: function() {
      return this._source;
    }, setSource: function(t4) {
      this._source = t4;
    }, toRgb: function() {
      var t4 = this.getSource();
      return "rgb(" + t4[0] + "," + t4[1] + "," + t4[2] + ")";
    }, toRgba: function() {
      var t4 = this.getSource();
      return "rgba(" + t4[0] + "," + t4[1] + "," + t4[2] + "," + t4[3] + ")";
    }, toHsl: function() {
      var t4 = this.getSource(), e4 = this._rgbToHsl(t4[0], t4[1], t4[2]);
      return "hsl(" + e4[0] + "," + e4[1] + "%," + e4[2] + "%)";
    }, toHsla: function() {
      var t4 = this.getSource(), e4 = this._rgbToHsl(t4[0], t4[1], t4[2]);
      return "hsla(" + e4[0] + "," + e4[1] + "%," + e4[2] + "%," + t4[3] + ")";
    }, toHex: function() {
      var t4, e4, i4, r5 = this.getSource();
      return t4 = 1 === (t4 = r5[0].toString(16)).length ? "0" + t4 : t4, e4 = 1 === (e4 = r5[1].toString(16)).length ? "0" + e4 : e4, i4 = 1 === (i4 = r5[2].toString(16)).length ? "0" + i4 : i4, t4.toUpperCase() + e4.toUpperCase() + i4.toUpperCase();
    }, toHexa: function() {
      var t4, e4 = this.getSource();
      return t4 = 1 === (t4 = (t4 = Math.round(255 * e4[3])).toString(16)).length ? "0" + t4 : t4, this.toHex() + t4.toUpperCase();
    }, getAlpha: function() {
      return this.getSource()[3];
    }, setAlpha: function(t4) {
      var e4 = this.getSource();
      return e4[3] = t4, this.setSource(e4), this;
    }, toGrayscale: function() {
      var t4 = this.getSource(), e4 = parseInt((0.3 * t4[0] + 0.59 * t4[1] + 0.11 * t4[2]).toFixed(0), 10), i4 = t4[3];
      return this.setSource([e4, e4, e4, i4]), this;
    }, toBlackWhite: function(t4) {
      var e4 = this.getSource(), i4 = (0.3 * e4[0] + 0.59 * e4[1] + 0.11 * e4[2]).toFixed(0), r5 = e4[3];
      return t4 = t4 || 127, i4 = Number(i4) < Number(t4) ? 0 : 255, this.setSource([i4, i4, i4, r5]), this;
    }, overlayWith: function(t4) {
      t4 instanceof i3 || (t4 = new i3(t4));
      var e4, r5 = [], n4 = this.getAlpha(), s4 = this.getSource(), o4 = t4.getSource();
      for (e4 = 0; e4 < 3; e4++) r5.push(Math.round(0.5 * s4[e4] + 0.5 * o4[e4]));
      return r5[3] = n4, this.setSource(r5), this;
    } }, e3.Color.reRGBa = /^rgba?\(\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*(?:\s*,\s*((?:\d*\.?\d+)?)\s*)?\)$/i, e3.Color.reHSLa = /^hsla?\(\s*(\d{1,3})\s*,\s*(\d{1,3}\%)\s*,\s*(\d{1,3}\%)\s*(?:\s*,\s*(\d+(?:\.\d+)?)\s*)?\)$/i, e3.Color.reHex = /^#?([0-9a-f]{8}|[0-9a-f]{6}|[0-9a-f]{4}|[0-9a-f]{3})$/i, e3.Color.colorNameMap = { aliceblue: "#F0F8FF", antiquewhite: "#FAEBD7", aqua: "#00FFFF", aquamarine: "#7FFFD4", azure: "#F0FFFF", beige: "#F5F5DC", bisque: "#FFE4C4", black: "#000000", blanchedalmond: "#FFEBCD", blue: "#0000FF", blueviolet: "#8A2BE2", brown: "#A52A2A", burlywood: "#DEB887", cadetblue: "#5F9EA0", chartreuse: "#7FFF00", chocolate: "#D2691E", coral: "#FF7F50", cornflowerblue: "#6495ED", cornsilk: "#FFF8DC", crimson: "#DC143C", cyan: "#00FFFF", darkblue: "#00008B", darkcyan: "#008B8B", darkgoldenrod: "#B8860B", darkgray: "#A9A9A9", darkgrey: "#A9A9A9", darkgreen: "#006400", darkkhaki: "#BDB76B", darkmagenta: "#8B008B", darkolivegreen: "#556B2F", darkorange: "#FF8C00", darkorchid: "#9932CC", darkred: "#8B0000", darksalmon: "#E9967A", darkseagreen: "#8FBC8F", darkslateblue: "#483D8B", darkslategray: "#2F4F4F", darkslategrey: "#2F4F4F", darkturquoise: "#00CED1", darkviolet: "#9400D3", deeppink: "#FF1493", deepskyblue: "#00BFFF", dimgray: "#696969", dimgrey: "#696969", dodgerblue: "#1E90FF", firebrick: "#B22222", floralwhite: "#FFFAF0", forestgreen: "#228B22", fuchsia: "#FF00FF", gainsboro: "#DCDCDC", ghostwhite: "#F8F8FF", gold: "#FFD700", goldenrod: "#DAA520", gray: "#808080", grey: "#808080", green: "#008000", greenyellow: "#ADFF2F", honeydew: "#F0FFF0", hotpink: "#FF69B4", indianred: "#CD5C5C", indigo: "#4B0082", ivory: "#FFFFF0", khaki: "#F0E68C", lavender: "#E6E6FA", lavenderblush: "#FFF0F5", lawngreen: "#7CFC00", lemonchiffon: "#FFFACD", lightblue: "#ADD8E6", lightcoral: "#F08080", lightcyan: "#E0FFFF", lightgoldenrodyellow: "#FAFAD2", lightgray: "#D3D3D3", lightgrey: "#D3D3D3", lightgreen: "#90EE90", lightpink: "#FFB6C1", lightsalmon: "#FFA07A", lightseagreen: "#20B2AA", lightskyblue: "#87CEFA", lightslategray: "#778899", lightslategrey: "#778899", lightsteelblue: "#B0C4DE", lightyellow: "#FFFFE0", lime: "#00FF00", limegreen: "#32CD32", linen: "#FAF0E6", magenta: "#FF00FF", maroon: "#800000", mediumaquamarine: "#66CDAA", mediumblue: "#0000CD", mediumorchid: "#BA55D3", mediumpurple: "#9370DB", mediumseagreen: "#3CB371", mediumslateblue: "#7B68EE", mediumspringgreen: "#00FA9A", mediumturquoise: "#48D1CC", mediumvioletred: "#C71585", midnightblue: "#191970", mintcream: "#F5FFFA", mistyrose: "#FFE4E1", moccasin: "#FFE4B5", navajowhite: "#FFDEAD", navy: "#000080", oldlace: "#FDF5E6", olive: "#808000", olivedrab: "#6B8E23", orange: "#FFA500", orangered: "#FF4500", orchid: "#DA70D6", palegoldenrod: "#EEE8AA", palegreen: "#98FB98", paleturquoise: "#AFEEEE", palevioletred: "#DB7093", papayawhip: "#FFEFD5", peachpuff: "#FFDAB9", peru: "#CD853F", pink: "#FFC0CB", plum: "#DDA0DD", powderblue: "#B0E0E6", purple: "#800080", rebeccapurple: "#663399", red: "#FF0000", rosybrown: "#BC8F8F", royalblue: "#4169E1", saddlebrown: "#8B4513", salmon: "#FA8072", sandybrown: "#F4A460", seagreen: "#2E8B57", seashell: "#FFF5EE", sienna: "#A0522D", silver: "#C0C0C0", skyblue: "#87CEEB", slateblue: "#6A5ACD", slategray: "#708090", slategrey: "#708090", snow: "#FFFAFA", springgreen: "#00FF7F", steelblue: "#4682B4", tan: "#D2B48C", teal: "#008080", thistle: "#D8BFD8", tomato: "#FF6347", turquoise: "#40E0D0", violet: "#EE82EE", wheat: "#F5DEB3", white: "#FFFFFF", whitesmoke: "#F5F5F5", yellow: "#FFFF00", yellowgreen: "#9ACD32" }, e3.Color.fromRgb = function(t4) {
      return i3.fromSource(i3.sourceFromRgb(t4));
    }, e3.Color.sourceFromRgb = function(t4) {
      var e4 = t4.match(i3.reRGBa);
      if (e4) {
        var r5 = parseInt(e4[1], 10) / (/%$/.test(e4[1]) ? 100 : 1) * (/%$/.test(e4[1]) ? 255 : 1), n4 = parseInt(e4[2], 10) / (/%$/.test(e4[2]) ? 100 : 1) * (/%$/.test(e4[2]) ? 255 : 1), s4 = parseInt(e4[3], 10) / (/%$/.test(e4[3]) ? 100 : 1) * (/%$/.test(e4[3]) ? 255 : 1);
        return [parseInt(r5, 10), parseInt(n4, 10), parseInt(s4, 10), e4[4] ? parseFloat(e4[4]) : 1];
      }
    }, e3.Color.fromRgba = i3.fromRgb, e3.Color.fromHsl = function(t4) {
      return i3.fromSource(i3.sourceFromHsl(t4));
    }, e3.Color.sourceFromHsl = function(t4) {
      var e4 = t4.match(i3.reHSLa);
      if (e4) {
        var n4, s4, o4, a4 = (parseFloat(e4[1]) % 360 + 360) % 360 / 360, h4 = parseFloat(e4[2]) / (/%$/.test(e4[2]) ? 100 : 1), l4 = parseFloat(e4[3]) / (/%$/.test(e4[3]) ? 100 : 1);
        if (0 === h4) n4 = s4 = o4 = l4;
        else {
          var c4 = l4 <= 0.5 ? l4 * (h4 + 1) : l4 + h4 - l4 * h4, u4 = 2 * l4 - c4;
          n4 = r4(u4, c4, a4 + 1 / 3), s4 = r4(u4, c4, a4), o4 = r4(u4, c4, a4 - 1 / 3);
        }
        return [Math.round(255 * n4), Math.round(255 * s4), Math.round(255 * o4), e4[4] ? parseFloat(e4[4]) : 1];
      }
    }, e3.Color.fromHsla = i3.fromHsl, e3.Color.fromHex = function(t4) {
      return i3.fromSource(i3.sourceFromHex(t4));
    }, e3.Color.sourceFromHex = function(t4) {
      if (t4.match(i3.reHex)) {
        var e4 = t4.slice(t4.indexOf("#") + 1), r5 = 3 === e4.length || 4 === e4.length, n4 = 8 === e4.length || 4 === e4.length, s4 = r5 ? e4.charAt(0) + e4.charAt(0) : e4.substring(0, 2), o4 = r5 ? e4.charAt(1) + e4.charAt(1) : e4.substring(2, 4), a4 = r5 ? e4.charAt(2) + e4.charAt(2) : e4.substring(4, 6), h4 = n4 ? r5 ? e4.charAt(3) + e4.charAt(3) : e4.substring(6, 8) : "FF";
        return [parseInt(s4, 16), parseInt(o4, 16), parseInt(a4, 16), parseFloat((parseInt(h4, 16) / 255).toFixed(2))];
      }
    }, e3.Color.fromSource = function(t4) {
      var e4 = new i3();
      return e4.setSource(t4), e4;
    });
  }(e2), function(t3) {
    var e3 = t3.fabric || (t3.fabric = {}), i3 = ["e", "se", "s", "sw", "w", "nw", "n", "ne", "e"], r4 = ["ns", "nesw", "ew", "nwse"], n4 = {}, s4 = "left", o4 = "top", a4 = "right", h4 = "bottom", l4 = "center", c4 = { top: h4, bottom: o4, left: a4, right: s4, center: l4 }, u4 = e3.util.radiansToDegrees, d4 = Math.sign || function(t4) {
      return (t4 > 0) - (t4 < 0) || +t4;
    };
    function f4(t4, e4) {
      var i4 = t4.angle + u4(Math.atan2(e4.y, e4.x)) + 360;
      return Math.round(i4 % 360 / 45);
    }
    function g4(t4, i4) {
      var r5 = i4.transform.target, n5 = r5.canvas, s5 = e3.util.object.clone(i4);
      s5.target = r5, n5 && n5.fire("object:" + t4, s5), r5.fire(t4, i4);
    }
    function p4(t4, e4) {
      var i4 = e4.canvas, r5 = t4[i4.uniScaleKey];
      return i4.uniformScaling && !r5 || !i4.uniformScaling && r5;
    }
    function m4(t4) {
      return t4.originX === l4 && t4.originY === l4;
    }
    function v4(t4, e4, i4) {
      var r5 = t4.lockScalingX, n5 = t4.lockScalingY;
      return !((!r5 || !n5) && (e4 || !r5 && !n5 || !i4) && (!r5 || "x" !== e4) && (!n5 || "y" !== e4));
    }
    function _4(t4, e4, i4, r5) {
      return { e: t4, transform: e4, pointer: { x: i4, y: r5 } };
    }
    function y4(t4) {
      return function(e4, i4, r5, n5) {
        var s5 = i4.target, o5 = s5.getCenterPoint(), a5 = s5.translateToOriginPoint(o5, i4.originX, i4.originY), h5 = t4(e4, i4, r5, n5);
        return s5.setPositionByOrigin(a5, i4.originX, i4.originY), h5;
      };
    }
    function b4(t4, e4) {
      return function(i4, r5, n5, s5) {
        var o5 = e4(i4, r5, n5, s5);
        return o5 && g4(t4, _4(i4, r5, n5, s5)), o5;
      };
    }
    function w4(t4, i4, r5, n5, s5) {
      var o5 = t4.target, a5 = o5.controls[t4.corner], h5 = o5.canvas.getZoom(), l5 = o5.padding / h5, c5 = o5.toLocalPoint(new e3.Point(n5, s5), i4, r5);
      return c5.x >= l5 && (c5.x -= l5), c5.x <= -l5 && (c5.x += l5), c5.y >= l5 && (c5.y -= l5), c5.y <= l5 && (c5.y += l5), c5.x -= a5.offsetX, c5.y -= a5.offsetY, c5;
    }
    function C4(t4) {
      return t4.flipX !== t4.flipY;
    }
    function S4(t4, e4, i4, r5, n5) {
      if (0 !== t4[e4]) {
        var s5 = n5 / t4._getTransformedDimensions()[r5] * t4[i4];
        t4.set(i4, s5);
      }
    }
    function x4(t4, e4, i4, r5) {
      var n5, l5 = e4.target, c5 = l5._getTransformedDimensions(0, l5.skewY), d5 = w4(e4, e4.originX, e4.originY, i4, r5), f5 = Math.abs(2 * d5.x) - c5.x, g5 = l5.skewX;
      f5 < 2 ? n5 = 0 : (n5 = u4(Math.atan2(f5 / l5.scaleX, c5.y / l5.scaleY)), e4.originX === s4 && e4.originY === h4 && (n5 = -n5), e4.originX === a4 && e4.originY === o4 && (n5 = -n5), C4(l5) && (n5 = -n5));
      var p5 = g5 !== n5;
      if (p5) {
        var m5 = l5._getTransformedDimensions().y;
        l5.set("skewX", n5), S4(l5, "skewY", "scaleY", "y", m5);
      }
      return p5;
    }
    function T4(t4, e4, i4, r5) {
      var n5, l5 = e4.target, c5 = l5._getTransformedDimensions(l5.skewX, 0), d5 = w4(e4, e4.originX, e4.originY, i4, r5), f5 = Math.abs(2 * d5.y) - c5.y, g5 = l5.skewY;
      f5 < 2 ? n5 = 0 : (n5 = u4(Math.atan2(f5 / l5.scaleY, c5.x / l5.scaleX)), e4.originX === s4 && e4.originY === h4 && (n5 = -n5), e4.originX === a4 && e4.originY === o4 && (n5 = -n5), C4(l5) && (n5 = -n5));
      var p5 = g5 !== n5;
      if (p5) {
        var m5 = l5._getTransformedDimensions().x;
        l5.set("skewY", n5), S4(l5, "skewX", "scaleX", "x", m5);
      }
      return p5;
    }
    function O4(t4, e4, i4, r5, n5) {
      n5 = n5 || {};
      var s5, o5, a5, h5, l5, u5, f5 = e4.target, g5 = f5.lockScalingX, _5 = f5.lockScalingY, y5 = n5.by, b5 = p4(t4, f5), C5 = v4(f5, y5, b5), S5 = e4.gestureScale;
      if (C5) return false;
      if (S5) o5 = e4.scaleX * S5, a5 = e4.scaleY * S5;
      else {
        if (s5 = w4(e4, e4.originX, e4.originY, i4, r5), l5 = "y" !== y5 ? d4(s5.x) : 1, u5 = "x" !== y5 ? d4(s5.y) : 1, e4.signX || (e4.signX = l5), e4.signY || (e4.signY = u5), f5.lockScalingFlip && (e4.signX !== l5 || e4.signY !== u5)) return false;
        if (h5 = f5._getTransformedDimensions(), b5 && !y5) {
          var x5 = Math.abs(s5.x) + Math.abs(s5.y), T5 = e4.original, O5 = x5 / (Math.abs(h5.x * T5.scaleX / f5.scaleX) + Math.abs(h5.y * T5.scaleY / f5.scaleY));
          o5 = T5.scaleX * O5, a5 = T5.scaleY * O5;
        } else o5 = Math.abs(s5.x * f5.scaleX / h5.x), a5 = Math.abs(s5.y * f5.scaleY / h5.y);
        m4(e4) && (o5 *= 2, a5 *= 2), e4.signX !== l5 && "y" !== y5 && (e4.originX = c4[e4.originX], o5 *= -1, e4.signX = l5), e4.signY !== u5 && "x" !== y5 && (e4.originY = c4[e4.originY], a5 *= -1, e4.signY = u5);
      }
      var E4 = f5.scaleX, D3 = f5.scaleY;
      return y5 ? ("x" === y5 && f5.set("scaleX", o5), "y" === y5 && f5.set("scaleY", a5)) : (!g5 && f5.set("scaleX", o5), !_5 && f5.set("scaleY", a5)), E4 !== f5.scaleX || D3 !== f5.scaleY;
    }
    n4.scaleCursorStyleHandler = function(t4, e4, r5) {
      var n5 = p4(t4, r5), s5 = "";
      if (0 !== e4.x && 0 === e4.y ? s5 = "x" : 0 === e4.x && 0 !== e4.y && (s5 = "y"), v4(r5, s5, n5)) return "not-allowed";
      var o5 = f4(r5, e4);
      return i3[o5] + "-resize";
    }, n4.skewCursorStyleHandler = function(t4, e4, i4) {
      var n5 = "not-allowed";
      if (0 !== e4.x && i4.lockSkewingY) return n5;
      if (0 !== e4.y && i4.lockSkewingX) return n5;
      var s5 = f4(i4, e4) % 4;
      return r4[s5] + "-resize";
    }, n4.scaleSkewCursorStyleHandler = function(t4, e4, i4) {
      return t4[i4.canvas.altActionKey] ? n4.skewCursorStyleHandler(t4, e4, i4) : n4.scaleCursorStyleHandler(t4, e4, i4);
    }, n4.rotationWithSnapping = b4("rotating", y4(function(t4, e4, i4, r5) {
      var n5 = e4, s5 = n5.target, o5 = s5.translateToOriginPoint(s5.getCenterPoint(), n5.originX, n5.originY);
      if (s5.lockRotation) return false;
      var a5, h5 = Math.atan2(n5.ey - o5.y, n5.ex - o5.x), l5 = Math.atan2(r5 - o5.y, i4 - o5.x), c5 = u4(l5 - h5 + n5.theta);
      if (s5.snapAngle > 0) {
        var d5 = s5.snapAngle, f5 = s5.snapThreshold || d5, g5 = Math.ceil(c5 / d5) * d5, p5 = Math.floor(c5 / d5) * d5;
        Math.abs(c5 - p5) < f5 ? c5 = p5 : Math.abs(c5 - g5) < f5 && (c5 = g5);
      }
      return c5 < 0 && (c5 = 360 + c5), c5 %= 360, a5 = s5.angle !== c5, s5.angle = c5, a5;
    })), n4.scalingEqually = b4("scaling", y4(function(t4, e4, i4, r5) {
      return O4(t4, e4, i4, r5);
    })), n4.scalingX = b4("scaling", y4(function(t4, e4, i4, r5) {
      return O4(t4, e4, i4, r5, { by: "x" });
    })), n4.scalingY = b4("scaling", y4(function(t4, e4, i4, r5) {
      return O4(t4, e4, i4, r5, { by: "y" });
    })), n4.scalingYOrSkewingX = function(t4, e4, i4, r5) {
      return t4[e4.target.canvas.altActionKey] ? n4.skewHandlerX(t4, e4, i4, r5) : n4.scalingY(t4, e4, i4, r5);
    }, n4.scalingXOrSkewingY = function(t4, e4, i4, r5) {
      return t4[e4.target.canvas.altActionKey] ? n4.skewHandlerY(t4, e4, i4, r5) : n4.scalingX(t4, e4, i4, r5);
    }, n4.changeWidth = b4("resizing", y4(function(t4, e4, i4, r5) {
      var n5 = e4.target, s5 = w4(e4, e4.originX, e4.originY, i4, r5), o5 = n5.strokeWidth / (n5.strokeUniform ? n5.scaleX : 1), a5 = m4(e4) ? 2 : 1, h5 = n5.width, l5 = Math.abs(s5.x * a5 / n5.scaleX) - o5;
      return n5.set("width", Math.max(l5, 0)), h5 !== l5;
    })), n4.skewHandlerX = function(t4, e4, i4, r5) {
      var n5, h5 = e4.target, c5 = h5.skewX, u5 = e4.originY;
      return !h5.lockSkewingX && (0 === c5 ? n5 = w4(e4, l4, l4, i4, r5).x > 0 ? s4 : a4 : (c5 > 0 && (n5 = u5 === o4 ? s4 : a4), c5 < 0 && (n5 = u5 === o4 ? a4 : s4), C4(h5) && (n5 = n5 === s4 ? a4 : s4)), e4.originX = n5, b4("skewing", y4(x4))(t4, e4, i4, r5));
    }, n4.skewHandlerY = function(t4, e4, i4, r5) {
      var n5, a5 = e4.target, c5 = a5.skewY, u5 = e4.originX;
      return !a5.lockSkewingY && (0 === c5 ? n5 = w4(e4, l4, l4, i4, r5).y > 0 ? o4 : h4 : (c5 > 0 && (n5 = u5 === s4 ? o4 : h4), c5 < 0 && (n5 = u5 === s4 ? h4 : o4), C4(a5) && (n5 = n5 === o4 ? h4 : o4)), e4.originY = n5, b4("skewing", y4(T4))(t4, e4, i4, r5));
    }, n4.dragHandler = function(t4, e4, i4, r5) {
      var n5 = e4.target, s5 = i4 - e4.offsetX, o5 = r5 - e4.offsetY, a5 = !n5.get("lockMovementX") && n5.left !== s5, h5 = !n5.get("lockMovementY") && n5.top !== o5;
      return a5 && n5.set("left", s5), h5 && n5.set("top", o5), (a5 || h5) && g4("moving", _4(t4, e4, i4, r5)), a5 || h5;
    }, n4.scaleOrSkewActionName = function(t4, e4, i4) {
      var r5 = t4[i4.canvas.altActionKey];
      return 0 === e4.x ? r5 ? "skewX" : "scaleY" : 0 === e4.y ? r5 ? "skewY" : "scaleX" : void 0;
    }, n4.rotationStyleHandler = function(t4, e4, i4) {
      return i4.lockRotation ? "not-allowed" : e4.cursorStyle;
    }, n4.fireEvent = g4, n4.wrapWithFixedAnchor = y4, n4.wrapWithFireEvent = b4, n4.getLocalPoint = w4, e3.controlsUtils = n4;
  }(e2), function(t3) {
    var e3 = t3.fabric || (t3.fabric = {}), i3 = e3.util.degreesToRadians, r4 = e3.controlsUtils;
    r4.renderCircleControl = function(t4, e4, i4, r5, n4) {
      r5 = r5 || {};
      var s4, o4 = this.sizeX || r5.cornerSize || n4.cornerSize, a4 = this.sizeY || r5.cornerSize || n4.cornerSize, h4 = void 0 !== r5.transparentCorners ? r5.transparentCorners : n4.transparentCorners, l4 = h4 ? "stroke" : "fill", c4 = !h4 && (r5.cornerStrokeColor || n4.cornerStrokeColor), u4 = e4, d4 = i4;
      t4.save(), t4.fillStyle = r5.cornerColor || n4.cornerColor, t4.strokeStyle = r5.cornerStrokeColor || n4.cornerStrokeColor, o4 > a4 ? (s4 = o4, t4.scale(1, a4 / o4), d4 = i4 * o4 / a4) : a4 > o4 ? (s4 = a4, t4.scale(o4 / a4, 1), u4 = e4 * a4 / o4) : s4 = o4, t4.lineWidth = 1, t4.beginPath(), t4.arc(u4, d4, s4 / 2, 0, 2 * Math.PI, false), t4[l4](), c4 && t4.stroke(), t4.restore();
    }, r4.renderSquareControl = function(t4, e4, r5, n4, s4) {
      n4 = n4 || {};
      var o4 = this.sizeX || n4.cornerSize || s4.cornerSize, a4 = this.sizeY || n4.cornerSize || s4.cornerSize, h4 = void 0 !== n4.transparentCorners ? n4.transparentCorners : s4.transparentCorners, l4 = h4 ? "stroke" : "fill", c4 = !h4 && (n4.cornerStrokeColor || s4.cornerStrokeColor), u4 = o4 / 2, d4 = a4 / 2;
      t4.save(), t4.fillStyle = n4.cornerColor || s4.cornerColor, t4.strokeStyle = n4.cornerStrokeColor || s4.cornerStrokeColor, t4.lineWidth = 1, t4.translate(e4, r5), t4.rotate(i3(s4.angle)), t4[l4 + "Rect"](-u4, -d4, o4, a4), c4 && t4.strokeRect(-u4, -d4, o4, a4), t4.restore();
    };
  }(e2), function(t3) {
    var e3 = t3.fabric || (t3.fabric = {});
    e3.Control = function(t4) {
      for (var e4 in t4) this[e4] = t4[e4];
    }, e3.Control.prototype = { visible: true, actionName: "scale", angle: 0, x: 0, y: 0, offsetX: 0, offsetY: 0, sizeX: null, sizeY: null, touchSizeX: null, touchSizeY: null, cursorStyle: "crosshair", withConnection: false, actionHandler: function() {
    }, mouseDownHandler: function() {
    }, mouseUpHandler: function() {
    }, getActionHandler: function() {
      return this.actionHandler;
    }, getMouseDownHandler: function() {
      return this.mouseDownHandler;
    }, getMouseUpHandler: function() {
      return this.mouseUpHandler;
    }, cursorStyleHandler: function(t4, e4) {
      return e4.cursorStyle;
    }, getActionName: function(t4, e4) {
      return e4.actionName;
    }, getVisibility: function(t4, e4) {
      var i3 = t4._controlsVisibility;
      return i3 && void 0 !== i3[e4] ? i3[e4] : this.visible;
    }, setVisibility: function(t4) {
      this.visible = t4;
    }, positionHandler: function(t4, i3) {
      return e3.util.transformPoint({ x: this.x * t4.x + this.offsetX, y: this.y * t4.y + this.offsetY }, i3);
    }, calcCornerCoords: function(t4, i3, r4, n4, s4) {
      var o4, a4, h4, l4, c4 = s4 ? this.touchSizeX : this.sizeX, u4 = s4 ? this.touchSizeY : this.sizeY;
      if (c4 && u4 && c4 !== u4) {
        var d4 = Math.atan2(u4, c4), f4 = Math.sqrt(c4 * c4 + u4 * u4) / 2, g4 = d4 - e3.util.degreesToRadians(t4), p4 = Math.PI / 2 - d4 - e3.util.degreesToRadians(t4);
        o4 = f4 * e3.util.cos(g4), a4 = f4 * e3.util.sin(g4), h4 = f4 * e3.util.cos(p4), l4 = f4 * e3.util.sin(p4);
      } else f4 = 0.7071067812 * (c4 && u4 ? c4 : i3), g4 = e3.util.degreesToRadians(45 - t4), o4 = h4 = f4 * e3.util.cos(g4), a4 = l4 = f4 * e3.util.sin(g4);
      return { tl: { x: r4 - l4, y: n4 - h4 }, tr: { x: r4 + o4, y: n4 - a4 }, bl: { x: r4 - o4, y: n4 + a4 }, br: { x: r4 + l4, y: n4 + h4 } };
    }, render: function(t4, i3, r4, n4, s4) {
      "circle" === ((n4 = n4 || {}).cornerStyle || s4.cornerStyle) ? e3.controlsUtils.renderCircleControl.call(this, t4, i3, r4, n4, s4) : e3.controlsUtils.renderSquareControl.call(this, t4, i3, r4, n4, s4);
    } };
  }(e2), function() {
    function t3(t4, e4) {
      var i3, r4, n4, s4, o4 = t4.getAttribute("style"), a4 = t4.getAttribute("offset") || 0;
      if (a4 = (a4 = parseFloat(a4) / (/%$/.test(a4) ? 100 : 1)) < 0 ? 0 : a4 > 1 ? 1 : a4, o4) {
        var h4 = o4.split(/\s*;\s*/);
        for ("" === h4[h4.length - 1] && h4.pop(), s4 = h4.length; s4--; ) {
          var l4 = h4[s4].split(/\s*:\s*/), c4 = l4[0].trim(), u4 = l4[1].trim();
          "stop-color" === c4 ? i3 = u4 : "stop-opacity" === c4 && (n4 = u4);
        }
      }
      return i3 || (i3 = t4.getAttribute("stop-color") || "rgb(0,0,0)"), n4 || (n4 = t4.getAttribute("stop-opacity")), r4 = (i3 = new x3.Color(i3)).getAlpha(), n4 = isNaN(parseFloat(n4)) ? 1 : parseFloat(n4), n4 *= r4 * e4, { offset: a4, color: i3.toRgb(), opacity: n4 };
    }
    var e3 = x3.util.object.clone;
    x3.Gradient = x3.util.createClass({ offsetX: 0, offsetY: 0, gradientTransform: null, gradientUnits: "pixels", type: "linear", initialize: function(t4) {
      t4 || (t4 = {}), t4.coords || (t4.coords = {});
      var e4, i3 = this;
      Object.keys(t4).forEach(function(e5) {
        i3[e5] = t4[e5];
      }), this.id ? this.id += "_" + x3.Object.__uid++ : this.id = x3.Object.__uid++, e4 = { x1: t4.coords.x1 || 0, y1: t4.coords.y1 || 0, x2: t4.coords.x2 || 0, y2: t4.coords.y2 || 0 }, "radial" === this.type && (e4.r1 = t4.coords.r1 || 0, e4.r2 = t4.coords.r2 || 0), this.coords = e4, this.colorStops = t4.colorStops.slice();
    }, addColorStop: function(t4) {
      for (var e4 in t4) {
        var i3 = new x3.Color(t4[e4]);
        this.colorStops.push({ offset: parseFloat(e4), color: i3.toRgb(), opacity: i3.getAlpha() });
      }
      return this;
    }, toObject: function(t4) {
      var e4 = { type: this.type, coords: this.coords, colorStops: this.colorStops, offsetX: this.offsetX, offsetY: this.offsetY, gradientUnits: this.gradientUnits, gradientTransform: this.gradientTransform ? this.gradientTransform.concat() : this.gradientTransform };
      return x3.util.populateWithProperties(this, e4, t4), e4;
    }, toSVG: function(t4, i3) {
      var r4, n4, s4, o4, a4 = e3(this.coords, true), h4 = (i3 = i3 || {}, e3(this.colorStops, true)), l4 = a4.r1 > a4.r2, c4 = this.gradientTransform ? this.gradientTransform.concat() : x3.iMatrix.concat(), u4 = -this.offsetX, d4 = -this.offsetY, f4 = !!i3.additionalTransform, g4 = "pixels" === this.gradientUnits ? "userSpaceOnUse" : "objectBoundingBox";
      if (h4.sort(function(t5, e4) {
        return t5.offset - e4.offset;
      }), "objectBoundingBox" === g4 ? (u4 /= t4.width, d4 /= t4.height) : (u4 += t4.width / 2, d4 += t4.height / 2), "path" === t4.type && "percentage" !== this.gradientUnits && (u4 -= t4.pathOffset.x, d4 -= t4.pathOffset.y), c4[4] -= u4, c4[5] -= d4, o4 = 'id="SVGID_' + this.id + '" gradientUnits="' + g4 + '"', o4 += ' gradientTransform="' + (f4 ? i3.additionalTransform + " " : "") + x3.util.matrixToSVG(c4) + '" ', "linear" === this.type ? s4 = ["<linearGradient ", o4, ' x1="', a4.x1, '" y1="', a4.y1, '" x2="', a4.x2, '" y2="', a4.y2, '">\n'] : "radial" === this.type && (s4 = ["<radialGradient ", o4, ' cx="', l4 ? a4.x1 : a4.x2, '" cy="', l4 ? a4.y1 : a4.y2, '" r="', l4 ? a4.r1 : a4.r2, '" fx="', l4 ? a4.x2 : a4.x1, '" fy="', l4 ? a4.y2 : a4.y1, '">\n']), "radial" === this.type) {
        if (l4) for ((h4 = h4.concat()).reverse(), r4 = 0, n4 = h4.length; r4 < n4; r4++) h4[r4].offset = 1 - h4[r4].offset;
        var p4 = Math.min(a4.r1, a4.r2);
        if (p4 > 0) {
          var m4 = p4 / Math.max(a4.r1, a4.r2);
          for (r4 = 0, n4 = h4.length; r4 < n4; r4++) h4[r4].offset += m4 * (1 - h4[r4].offset);
        }
      }
      for (r4 = 0, n4 = h4.length; r4 < n4; r4++) {
        var v4 = h4[r4];
        s4.push("<stop ", 'offset="', 100 * v4.offset + "%", '" style="stop-color:', v4.color, void 0 !== v4.opacity ? ";stop-opacity: " + v4.opacity : ";", '"/>\n');
      }
      return s4.push("linear" === this.type ? "</linearGradient>\n" : "</radialGradient>\n"), s4.join("");
    }, toLive: function(t4) {
      var e4, i3, r4, n4 = x3.util.object.clone(this.coords);
      if (this.type) {
        for ("linear" === this.type ? e4 = t4.createLinearGradient(n4.x1, n4.y1, n4.x2, n4.y2) : "radial" === this.type && (e4 = t4.createRadialGradient(n4.x1, n4.y1, n4.r1, n4.x2, n4.y2, n4.r2)), i3 = 0, r4 = this.colorStops.length; i3 < r4; i3++) {
          var s4 = this.colorStops[i3].color, o4 = this.colorStops[i3].opacity, a4 = this.colorStops[i3].offset;
          void 0 !== o4 && (s4 = new x3.Color(s4).setAlpha(o4).toRgba()), e4.addColorStop(a4, s4);
        }
        return e4;
      }
    } }), x3.util.object.extend(x3.Gradient, { fromElement: function(e4, i3, r4, n4) {
      var s4 = parseFloat(r4) / (/%$/.test(r4) ? 100 : 1);
      s4 = s4 < 0 ? 0 : s4 > 1 ? 1 : s4, isNaN(s4) && (s4 = 1);
      var o4, a4, h4, l4, c4 = e4.getElementsByTagName("stop"), u4 = "userSpaceOnUse" === e4.getAttribute("gradientUnits") ? "pixels" : "percentage", d4 = e4.getAttribute("gradientTransform") || "", f4 = [], g4 = 0, p4 = 0;
      for ("linearGradient" === e4.nodeName || "LINEARGRADIENT" === e4.nodeName ? (o4 = "linear", a4 = function(t4) {
        return { x1: t4.getAttribute("x1") || 0, y1: t4.getAttribute("y1") || 0, x2: t4.getAttribute("x2") || "100%", y2: t4.getAttribute("y2") || 0 };
      }(e4)) : (o4 = "radial", a4 = function(t4) {
        return { x1: t4.getAttribute("fx") || t4.getAttribute("cx") || "50%", y1: t4.getAttribute("fy") || t4.getAttribute("cy") || "50%", r1: 0, x2: t4.getAttribute("cx") || "50%", y2: t4.getAttribute("cy") || "50%", r2: t4.getAttribute("r") || "50%" };
      }(e4)), h4 = c4.length; h4--; ) f4.push(t3(c4[h4], s4));
      return l4 = x3.parseTransformAttribute(d4), function(t4, e5, i4, r5) {
        var n5, s5;
        Object.keys(e5).forEach(function(t5) {
          "Infinity" === (n5 = e5[t5]) ? s5 = 1 : "-Infinity" === n5 ? s5 = 0 : (s5 = parseFloat(e5[t5], 10), "string" == typeof n5 && /^(\d+\.\d+)%|(\d+)%$/.test(n5) && (s5 *= 0.01, "pixels" === r5 && ("x1" !== t5 && "x2" !== t5 && "r2" !== t5 || (s5 *= i4.viewBoxWidth || i4.width), "y1" !== t5 && "y2" !== t5 || (s5 *= i4.viewBoxHeight || i4.height)))), e5[t5] = s5;
        });
      }(0, a4, n4, u4), "pixels" === u4 && (g4 = -i3.left, p4 = -i3.top), new x3.Gradient({ id: e4.getAttribute("id"), type: o4, coords: a4, colorStops: f4, gradientUnits: u4, gradientTransform: l4, offsetX: g4, offsetY: p4 });
    } });
  }(), v3 = x3.util.toFixed, x3.Pattern = x3.util.createClass({ repeat: "repeat", offsetX: 0, offsetY: 0, crossOrigin: "", patternTransform: null, initialize: function(t3, e3) {
    if (t3 || (t3 = {}), this.id = x3.Object.__uid++, this.setOptions(t3), !t3.source || t3.source && "string" != typeof t3.source) e3 && e3(this);
    else {
      var i3 = this;
      this.source = x3.util.createImage(), x3.util.loadImage(t3.source, function(t4, r4) {
        i3.source = t4, e3 && e3(i3, r4);
      }, null, this.crossOrigin);
    }
  }, toObject: function(t3) {
    var e3, i3, r4 = x3.Object.NUM_FRACTION_DIGITS;
    return "string" == typeof this.source.src ? e3 = this.source.src : "object" == typeof this.source && this.source.toDataURL && (e3 = this.source.toDataURL()), i3 = { type: "pattern", source: e3, repeat: this.repeat, crossOrigin: this.crossOrigin, offsetX: v3(this.offsetX, r4), offsetY: v3(this.offsetY, r4), patternTransform: this.patternTransform ? this.patternTransform.concat() : null }, x3.util.populateWithProperties(this, i3, t3), i3;
  }, toSVG: function(t3) {
    var e3 = "function" == typeof this.source ? this.source() : this.source, i3 = e3.width / t3.width, r4 = e3.height / t3.height, n4 = this.offsetX / t3.width, s4 = this.offsetY / t3.height, o4 = "";
    return "repeat-x" !== this.repeat && "no-repeat" !== this.repeat || (r4 = 1, s4 && (r4 += Math.abs(s4))), "repeat-y" !== this.repeat && "no-repeat" !== this.repeat || (i3 = 1, n4 && (i3 += Math.abs(n4))), e3.src ? o4 = e3.src : e3.toDataURL && (o4 = e3.toDataURL()), '<pattern id="SVGID_' + this.id + '" x="' + n4 + '" y="' + s4 + '" width="' + i3 + '" height="' + r4 + '">\n<image x="0" y="0" width="' + e3.width + '" height="' + e3.height + '" xlink:href="' + o4 + '"></image>\n</pattern>\n';
  }, setOptions: function(t3) {
    for (var e3 in t3) this[e3] = t3[e3];
  }, toLive: function(t3) {
    var e3 = this.source;
    if (!e3) return "";
    if (void 0 !== e3.src) {
      if (!e3.complete) return "";
      if (0 === e3.naturalWidth || 0 === e3.naturalHeight) return "";
    }
    return t3.createPattern(e3, this.repeat);
  } }), function(t3) {
    var e3 = t3.fabric || (t3.fabric = {}), i3 = e3.util.toFixed;
    e3.Shadow ? e3.warn("fabric.Shadow is already defined.") : (e3.Shadow = e3.util.createClass({ color: "rgb(0,0,0)", blur: 0, offsetX: 0, offsetY: 0, affectStroke: false, includeDefaultValues: true, nonScaling: false, initialize: function(t4) {
      for (var i4 in "string" == typeof t4 && (t4 = this._parseShadow(t4)), t4) this[i4] = t4[i4];
      this.id = e3.Object.__uid++;
    }, _parseShadow: function(t4) {
      var i4 = t4.trim(), r4 = e3.Shadow.reOffsetsAndBlur.exec(i4) || [];
      return { color: (i4.replace(e3.Shadow.reOffsetsAndBlur, "") || "rgb(0,0,0)").trim(), offsetX: parseFloat(r4[1], 10) || 0, offsetY: parseFloat(r4[2], 10) || 0, blur: parseFloat(r4[3], 10) || 0 };
    }, toString: function() {
      return [this.offsetX, this.offsetY, this.blur, this.color].join("px ");
    }, toSVG: function(t4) {
      var r4 = 40, n4 = 40, s4 = e3.Object.NUM_FRACTION_DIGITS, o4 = e3.util.rotateVector({ x: this.offsetX, y: this.offsetY }, e3.util.degreesToRadians(-t4.angle)), a4 = new e3.Color(this.color);
      return t4.width && t4.height && (r4 = 100 * i3((Math.abs(o4.x) + this.blur) / t4.width, s4) + 20, n4 = 100 * i3((Math.abs(o4.y) + this.blur) / t4.height, s4) + 20), t4.flipX && (o4.x *= -1), t4.flipY && (o4.y *= -1), '<filter id="SVGID_' + this.id + '" y="-' + n4 + '%" height="' + (100 + 2 * n4) + '%" x="-' + r4 + '%" width="' + (100 + 2 * r4) + '%" >\n	<feGaussianBlur in="SourceAlpha" stdDeviation="' + i3(this.blur ? this.blur / 2 : 0, s4) + '"></feGaussianBlur>\n	<feOffset dx="' + i3(o4.x, s4) + '" dy="' + i3(o4.y, s4) + '" result="oBlur" ></feOffset>\n	<feFlood flood-color="' + a4.toRgb() + '" flood-opacity="' + a4.getAlpha() + '"/>\n	<feComposite in2="oBlur" operator="in" />\n	<feMerge>\n		<feMergeNode></feMergeNode>\n		<feMergeNode in="SourceGraphic"></feMergeNode>\n	</feMerge>\n</filter>\n';
    }, toObject: function() {
      if (this.includeDefaultValues) return { color: this.color, blur: this.blur, offsetX: this.offsetX, offsetY: this.offsetY, affectStroke: this.affectStroke, nonScaling: this.nonScaling };
      var t4 = {}, i4 = e3.Shadow.prototype;
      return ["color", "blur", "offsetX", "offsetY", "affectStroke", "nonScaling"].forEach(function(e4) {
        this[e4] !== i4[e4] && (t4[e4] = this[e4]);
      }, this), t4;
    } }), e3.Shadow.reOffsetsAndBlur = /(?:\s|^)(-?\d+(?:\.\d*)?(?:px)?(?:\s?|$))?(-?\d+(?:\.\d*)?(?:px)?(?:\s?|$))?(\d+(?:\.\d*)?(?:px)?)?(?:\s?|$)(?:$|\s)/);
  }(e2), function() {
    if (x3.StaticCanvas) x3.warn("fabric.StaticCanvas is already defined.");
    else {
      var t3 = x3.util.object.extend, e3 = x3.util.getElementOffset, i3 = x3.util.removeFromArray, r4 = x3.util.toFixed, n4 = x3.util.transformPoint, s4 = x3.util.invertTransform, o4 = x3.util.getNodeCanvas, a4 = x3.util.createCanvasElement, h4 = new Error("Could not initialize `canvas` element");
      x3.StaticCanvas = x3.util.createClass(x3.CommonMethods, { initialize: function(t4, e4) {
        e4 || (e4 = {}), this.renderAndResetBound = this.renderAndReset.bind(this), this.requestRenderAllBound = this.requestRenderAll.bind(this), this._initStatic(t4, e4);
      }, backgroundColor: "", backgroundImage: null, overlayColor: "", overlayImage: null, includeDefaultValues: true, stateful: false, renderOnAddRemove: true, controlsAboveOverlay: false, allowTouchScrolling: false, imageSmoothingEnabled: true, viewportTransform: x3.iMatrix.concat(), backgroundVpt: true, overlayVpt: true, enableRetinaScaling: true, vptCoords: {}, skipOffscreen: true, clipPath: void 0, _initStatic: function(t4, e4) {
        var i4 = this.requestRenderAllBound;
        this._objects = [], this._createLowerCanvas(t4), this._initOptions(e4), this.interactive || this._initRetinaScaling(), e4.overlayImage && this.setOverlayImage(e4.overlayImage, i4), e4.backgroundImage && this.setBackgroundImage(e4.backgroundImage, i4), e4.backgroundColor && this.setBackgroundColor(e4.backgroundColor, i4), e4.overlayColor && this.setOverlayColor(e4.overlayColor, i4), this.calcOffset();
      }, _isRetinaScaling: function() {
        return x3.devicePixelRatio > 1 && this.enableRetinaScaling;
      }, getRetinaScaling: function() {
        return this._isRetinaScaling() ? Math.max(1, x3.devicePixelRatio) : 1;
      }, _initRetinaScaling: function() {
        if (this._isRetinaScaling()) {
          var t4 = x3.devicePixelRatio;
          this.__initRetinaScaling(t4, this.lowerCanvasEl, this.contextContainer), this.upperCanvasEl && this.__initRetinaScaling(t4, this.upperCanvasEl, this.contextTop);
        }
      }, __initRetinaScaling: function(t4, e4, i4) {
        e4.setAttribute("width", this.width * t4), e4.setAttribute("height", this.height * t4), i4.scale(t4, t4);
      }, calcOffset: function() {
        return this._offset = e3(this.lowerCanvasEl), this;
      }, setOverlayImage: function(t4, e4, i4) {
        return this.__setBgOverlayImage("overlayImage", t4, e4, i4);
      }, setBackgroundImage: function(t4, e4, i4) {
        return this.__setBgOverlayImage("backgroundImage", t4, e4, i4);
      }, setOverlayColor: function(t4, e4) {
        return this.__setBgOverlayColor("overlayColor", t4, e4);
      }, setBackgroundColor: function(t4, e4) {
        return this.__setBgOverlayColor("backgroundColor", t4, e4);
      }, __setBgOverlayImage: function(t4, e4, i4, r5) {
        return "string" == typeof e4 ? x3.util.loadImage(e4, function(e5, n5) {
          if (e5) {
            var s5 = new x3.Image(e5, r5);
            this[t4] = s5, s5.canvas = this;
          }
          i4 && i4(e5, n5);
        }, this, r5 && r5.crossOrigin) : (r5 && e4.setOptions(r5), this[t4] = e4, e4 && (e4.canvas = this), i4 && i4(e4, false)), this;
      }, __setBgOverlayColor: function(t4, e4, i4) {
        return this[t4] = e4, this._initGradient(e4, t4), this._initPattern(e4, t4, i4), this;
      }, _createCanvasElement: function() {
        var t4 = a4();
        if (!t4) throw h4;
        if (t4.style || (t4.style = {}), void 0 === t4.getContext) throw h4;
        return t4;
      }, _initOptions: function(t4) {
        var e4 = this.lowerCanvasEl;
        this._setOptions(t4), this.width = this.width || parseInt(e4.width, 10) || 0, this.height = this.height || parseInt(e4.height, 10) || 0, this.lowerCanvasEl.style && (e4.width = this.width, e4.height = this.height, e4.style.width = this.width + "px", e4.style.height = this.height + "px", this.viewportTransform = this.viewportTransform.slice());
      }, _createLowerCanvas: function(t4) {
        t4 && t4.getContext ? this.lowerCanvasEl = t4 : this.lowerCanvasEl = x3.util.getById(t4) || this._createCanvasElement(), x3.util.addClass(this.lowerCanvasEl, "lower-canvas"), this._originalCanvasStyle = this.lowerCanvasEl.style, this.interactive && this._applyCanvasStyle(this.lowerCanvasEl), this.contextContainer = this.lowerCanvasEl.getContext("2d");
      }, getWidth: function() {
        return this.width;
      }, getHeight: function() {
        return this.height;
      }, setWidth: function(t4, e4) {
        return this.setDimensions({ width: t4 }, e4);
      }, setHeight: function(t4, e4) {
        return this.setDimensions({ height: t4 }, e4);
      }, setDimensions: function(t4, e4) {
        var i4;
        for (var r5 in e4 = e4 || {}, t4) i4 = t4[r5], e4.cssOnly || (this._setBackstoreDimension(r5, t4[r5]), i4 += "px", this.hasLostContext = true), e4.backstoreOnly || this._setCssDimension(r5, i4);
        return this._isCurrentlyDrawing && this.freeDrawingBrush && this.freeDrawingBrush._setBrushStyles(this.contextTop), this._initRetinaScaling(), this.calcOffset(), e4.cssOnly || this.requestRenderAll(), this;
      }, _setBackstoreDimension: function(t4, e4) {
        return this.lowerCanvasEl[t4] = e4, this.upperCanvasEl && (this.upperCanvasEl[t4] = e4), this.cacheCanvasEl && (this.cacheCanvasEl[t4] = e4), this[t4] = e4, this;
      }, _setCssDimension: function(t4, e4) {
        return this.lowerCanvasEl.style[t4] = e4, this.upperCanvasEl && (this.upperCanvasEl.style[t4] = e4), this.wrapperEl && (this.wrapperEl.style[t4] = e4), this;
      }, getZoom: function() {
        return this.viewportTransform[0];
      }, setViewportTransform: function(t4) {
        var e4, i4, r5, n5 = this._activeObject, s5 = this.backgroundImage, o5 = this.overlayImage;
        for (this.viewportTransform = t4, i4 = 0, r5 = this._objects.length; i4 < r5; i4++) (e4 = this._objects[i4]).group || e4.setCoords(true);
        return n5 && n5.setCoords(), s5 && s5.setCoords(true), o5 && o5.setCoords(true), this.calcViewportBoundaries(), this.renderOnAddRemove && this.requestRenderAll(), this;
      }, zoomToPoint: function(t4, e4) {
        var i4 = t4, r5 = this.viewportTransform.slice(0);
        t4 = n4(t4, s4(this.viewportTransform)), r5[0] = e4, r5[3] = e4;
        var o5 = n4(t4, r5);
        return r5[4] += i4.x - o5.x, r5[5] += i4.y - o5.y, this.setViewportTransform(r5);
      }, setZoom: function(t4) {
        return this.zoomToPoint(new x3.Point(0, 0), t4), this;
      }, absolutePan: function(t4) {
        var e4 = this.viewportTransform.slice(0);
        return e4[4] = -t4.x, e4[5] = -t4.y, this.setViewportTransform(e4);
      }, relativePan: function(t4) {
        return this.absolutePan(new x3.Point(-t4.x - this.viewportTransform[4], -t4.y - this.viewportTransform[5]));
      }, getElement: function() {
        return this.lowerCanvasEl;
      }, _onObjectAdded: function(t4) {
        this.stateful && t4.setupState(), t4._set("canvas", this), t4.setCoords(), this.fire("object:added", { target: t4 }), t4.fire("added");
      }, _onObjectRemoved: function(t4) {
        this.fire("object:removed", { target: t4 }), t4.fire("removed"), delete t4.canvas;
      }, clearContext: function(t4) {
        return t4.clearRect(0, 0, this.width, this.height), this;
      }, getContext: function() {
        return this.contextContainer;
      }, clear: function() {
        return this.remove.apply(this, this.getObjects()), this.backgroundImage = null, this.overlayImage = null, this.backgroundColor = "", this.overlayColor = "", this._hasITextHandlers && (this.off("mouse:up", this._mouseUpITextHandler), this._iTextInstances = null, this._hasITextHandlers = false), this.clearContext(this.contextContainer), this.fire("canvas:cleared"), this.renderOnAddRemove && this.requestRenderAll(), this;
      }, renderAll: function() {
        var t4 = this.contextContainer;
        return this.renderCanvas(t4, this._objects), this;
      }, renderAndReset: function() {
        this.isRendering = 0, this.renderAll();
      }, requestRenderAll: function() {
        return this.isRendering || (this.isRendering = x3.util.requestAnimFrame(this.renderAndResetBound)), this;
      }, calcViewportBoundaries: function() {
        var t4 = {}, e4 = this.width, i4 = this.height, r5 = s4(this.viewportTransform);
        return t4.tl = n4({ x: 0, y: 0 }, r5), t4.br = n4({ x: e4, y: i4 }, r5), t4.tr = new x3.Point(t4.br.x, t4.tl.y), t4.bl = new x3.Point(t4.tl.x, t4.br.y), this.vptCoords = t4, t4;
      }, cancelRequestedRender: function() {
        this.isRendering && (x3.util.cancelAnimFrame(this.isRendering), this.isRendering = 0);
      }, renderCanvas: function(t4, e4) {
        var i4 = this.viewportTransform, r5 = this.clipPath;
        this.cancelRequestedRender(), this.calcViewportBoundaries(), this.clearContext(t4), x3.util.setImageSmoothing(t4, this.imageSmoothingEnabled), this.fire("before:render", { ctx: t4 }), this._renderBackground(t4), t4.save(), t4.transform(i4[0], i4[1], i4[2], i4[3], i4[4], i4[5]), this._renderObjects(t4, e4), t4.restore(), !this.controlsAboveOverlay && this.interactive && this.drawControls(t4), r5 && (r5.canvas = this, r5.shouldCache(), r5._transformDone = true, r5.renderCache({ forClipping: true }), this.drawClipPathOnCanvas(t4)), this._renderOverlay(t4), this.controlsAboveOverlay && this.interactive && this.drawControls(t4), this.fire("after:render", { ctx: t4 });
      }, drawClipPathOnCanvas: function(t4) {
        var e4 = this.viewportTransform, i4 = this.clipPath;
        t4.save(), t4.transform(e4[0], e4[1], e4[2], e4[3], e4[4], e4[5]), t4.globalCompositeOperation = "destination-in", i4.transform(t4), t4.scale(1 / i4.zoomX, 1 / i4.zoomY), t4.drawImage(i4._cacheCanvas, -i4.cacheTranslationX, -i4.cacheTranslationY), t4.restore();
      }, _renderObjects: function(t4, e4) {
        var i4, r5;
        for (i4 = 0, r5 = e4.length; i4 < r5; ++i4) e4[i4] && e4[i4].render(t4);
      }, _renderBackgroundOrOverlay: function(t4, e4) {
        var i4 = this[e4 + "Color"], r5 = this[e4 + "Image"], n5 = this.viewportTransform, s5 = this[e4 + "Vpt"];
        if (i4 || r5) {
          if (i4) {
            t4.save(), t4.beginPath(), t4.moveTo(0, 0), t4.lineTo(this.width, 0), t4.lineTo(this.width, this.height), t4.lineTo(0, this.height), t4.closePath(), t4.fillStyle = i4.toLive ? i4.toLive(t4, this) : i4, s5 && t4.transform(n5[0], n5[1], n5[2], n5[3], n5[4], n5[5]), t4.transform(1, 0, 0, 1, i4.offsetX || 0, i4.offsetY || 0);
            var o5 = i4.gradientTransform || i4.patternTransform;
            o5 && t4.transform(o5[0], o5[1], o5[2], o5[3], o5[4], o5[5]), t4.fill(), t4.restore();
          }
          r5 && (t4.save(), s5 && t4.transform(n5[0], n5[1], n5[2], n5[3], n5[4], n5[5]), r5.render(t4), t4.restore());
        }
      }, _renderBackground: function(t4) {
        this._renderBackgroundOrOverlay(t4, "background");
      }, _renderOverlay: function(t4) {
        this._renderBackgroundOrOverlay(t4, "overlay");
      }, getCenter: function() {
        return { top: this.height / 2, left: this.width / 2 };
      }, getCenterPoint: function() {
        return new x3.Point(this.width / 2, this.height / 2);
      }, centerObjectH: function(t4) {
        return this._centerObject(t4, new x3.Point(this.getCenterPoint().x, t4.getCenterPoint().y));
      }, centerObjectV: function(t4) {
        return this._centerObject(t4, new x3.Point(t4.getCenterPoint().x, this.getCenterPoint().y));
      }, centerObject: function(t4) {
        var e4 = this.getCenterPoint();
        return this._centerObject(t4, e4);
      }, viewportCenterObject: function(t4) {
        var e4 = this.getVpCenter();
        return this._centerObject(t4, e4);
      }, viewportCenterObjectH: function(t4) {
        var e4 = this.getVpCenter();
        return this._centerObject(t4, new x3.Point(e4.x, t4.getCenterPoint().y)), this;
      }, viewportCenterObjectV: function(t4) {
        var e4 = this.getVpCenter();
        return this._centerObject(t4, new x3.Point(t4.getCenterPoint().x, e4.y));
      }, getVpCenter: function() {
        var t4 = this.getCenterPoint(), e4 = s4(this.viewportTransform);
        return n4(t4, e4);
      }, _centerObject: function(t4, e4) {
        return t4.setPositionByOrigin(e4, "center", "center"), t4.setCoords(), this.renderOnAddRemove && this.requestRenderAll(), this;
      }, toDatalessJSON: function(t4) {
        return this.toDatalessObject(t4);
      }, toObject: function(t4) {
        return this._toObjectMethod("toObject", t4);
      }, toDatalessObject: function(t4) {
        return this._toObjectMethod("toDatalessObject", t4);
      }, _toObjectMethod: function(e4, i4) {
        var r5 = this.clipPath, n5 = { version: x3.version, objects: this._toObjects(e4, i4) };
        return r5 && !r5.excludeFromExport && (n5.clipPath = this._toObject(this.clipPath, e4, i4)), t3(n5, this.__serializeBgOverlay(e4, i4)), x3.util.populateWithProperties(this, n5, i4), n5;
      }, _toObjects: function(t4, e4) {
        return this._objects.filter(function(t5) {
          return !t5.excludeFromExport;
        }).map(function(i4) {
          return this._toObject(i4, t4, e4);
        }, this);
      }, _toObject: function(t4, e4, i4) {
        var r5;
        this.includeDefaultValues || (r5 = t4.includeDefaultValues, t4.includeDefaultValues = false);
        var n5 = t4[e4](i4);
        return this.includeDefaultValues || (t4.includeDefaultValues = r5), n5;
      }, __serializeBgOverlay: function(t4, e4) {
        var i4 = {}, r5 = this.backgroundImage, n5 = this.overlayImage, s5 = this.backgroundColor, o5 = this.overlayColor;
        return s5 && s5.toObject ? s5.excludeFromExport || (i4.background = s5.toObject(e4)) : s5 && (i4.background = s5), o5 && o5.toObject ? o5.excludeFromExport || (i4.overlay = o5.toObject(e4)) : o5 && (i4.overlay = o5), r5 && !r5.excludeFromExport && (i4.backgroundImage = this._toObject(r5, t4, e4)), n5 && !n5.excludeFromExport && (i4.overlayImage = this._toObject(n5, t4, e4)), i4;
      }, svgViewportTransformation: true, toSVG: function(t4, e4) {
        t4 || (t4 = {}), t4.reviver = e4;
        var i4 = [];
        return this._setSVGPreamble(i4, t4), this._setSVGHeader(i4, t4), this.clipPath && i4.push('<g clip-path="url(#' + this.clipPath.clipPathId + ')" >\n'), this._setSVGBgOverlayColor(i4, "background"), this._setSVGBgOverlayImage(i4, "backgroundImage", e4), this._setSVGObjects(i4, e4), this.clipPath && i4.push("</g>\n"), this._setSVGBgOverlayColor(i4, "overlay"), this._setSVGBgOverlayImage(i4, "overlayImage", e4), i4.push("</svg>"), i4.join("");
      }, _setSVGPreamble: function(t4, e4) {
        e4.suppressPreamble || t4.push('<?xml version="1.0" encoding="', e4.encoding || "UTF-8", '" standalone="no" ?>\n', '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" ', '"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n');
      }, _setSVGHeader: function(t4, e4) {
        var i4, n5 = e4.width || this.width, s5 = e4.height || this.height, o5 = 'viewBox="0 0 ' + this.width + " " + this.height + '" ', a5 = x3.Object.NUM_FRACTION_DIGITS;
        e4.viewBox ? o5 = 'viewBox="' + e4.viewBox.x + " " + e4.viewBox.y + " " + e4.viewBox.width + " " + e4.viewBox.height + '" ' : this.svgViewportTransformation && (i4 = this.viewportTransform, o5 = 'viewBox="' + r4(-i4[4] / i4[0], a5) + " " + r4(-i4[5] / i4[3], a5) + " " + r4(this.width / i4[0], a5) + " " + r4(this.height / i4[3], a5) + '" '), t4.push("<svg ", 'xmlns="http://www.w3.org/2000/svg" ', 'xmlns:xlink="http://www.w3.org/1999/xlink" ', 'version="1.1" ', 'width="', n5, '" ', 'height="', s5, '" ', o5, 'xml:space="preserve">\n', "<desc>Created with Fabric.js ", x3.version, "</desc>\n", "<defs>\n", this.createSVGFontFacesMarkup(), this.createSVGRefElementsMarkup(), this.createSVGClipPathMarkup(e4), "</defs>\n");
      }, createSVGClipPathMarkup: function(t4) {
        var e4 = this.clipPath;
        return e4 ? (e4.clipPathId = "CLIPPATH_" + x3.Object.__uid++, '<clipPath id="' + e4.clipPathId + '" >\n' + this.clipPath.toClipPathSVG(t4.reviver) + "</clipPath>\n") : "";
      }, createSVGRefElementsMarkup: function() {
        var t4 = this;
        return ["background", "overlay"].map(function(e4) {
          var i4 = t4[e4 + "Color"];
          if (i4 && i4.toLive) {
            var r5 = t4[e4 + "Vpt"], n5 = t4.viewportTransform, s5 = { width: t4.width / (r5 ? n5[0] : 1), height: t4.height / (r5 ? n5[3] : 1) };
            return i4.toSVG(s5, { additionalTransform: r5 ? x3.util.matrixToSVG(n5) : "" });
          }
        }).join("");
      }, createSVGFontFacesMarkup: function() {
        var t4, e4, i4, r5, n5, s5, o5, a5, h5 = "", l4 = {}, c4 = x3.fontPaths, u4 = [];
        for (this._objects.forEach(function t5(e5) {
          u4.push(e5), e5._objects && e5._objects.forEach(t5);
        }), o5 = 0, a5 = u4.length; o5 < a5; o5++) if (e4 = (t4 = u4[o5]).fontFamily, -1 !== t4.type.indexOf("text") && !l4[e4] && c4[e4] && (l4[e4] = true, t4.styles)) for (n5 in i4 = t4.styles) for (s5 in r5 = i4[n5]) !l4[e4 = r5[s5].fontFamily] && c4[e4] && (l4[e4] = true);
        for (var d4 in l4) h5 += ["		@font-face {\n", "			font-family: '", d4, "';\n", "			src: url('", c4[d4], "');\n", "		}\n"].join("");
        return h5 && (h5 = ['	<style type="text/css">', "<![CDATA[\n", h5, "]]>", "</style>\n"].join("")), h5;
      }, _setSVGObjects: function(t4, e4) {
        var i4, r5, n5, s5 = this._objects;
        for (r5 = 0, n5 = s5.length; r5 < n5; r5++) (i4 = s5[r5]).excludeFromExport || this._setSVGObject(t4, i4, e4);
      }, _setSVGObject: function(t4, e4, i4) {
        t4.push(e4.toSVG(i4));
      }, _setSVGBgOverlayImage: function(t4, e4, i4) {
        this[e4] && !this[e4].excludeFromExport && this[e4].toSVG && t4.push(this[e4].toSVG(i4));
      }, _setSVGBgOverlayColor: function(t4, e4) {
        var i4 = this[e4 + "Color"], r5 = this.viewportTransform, n5 = this.width, s5 = this.height;
        if (i4) if (i4.toLive) {
          var o5 = i4.repeat, a5 = x3.util.invertTransform(r5), h5 = this[e4 + "Vpt"] ? x3.util.matrixToSVG(a5) : "";
          t4.push('<rect transform="' + h5 + " translate(", n5 / 2, ",", s5 / 2, ')"', ' x="', i4.offsetX - n5 / 2, '" y="', i4.offsetY - s5 / 2, '" ', 'width="', "repeat-y" === o5 || "no-repeat" === o5 ? i4.source.width : n5, '" height="', "repeat-x" === o5 || "no-repeat" === o5 ? i4.source.height : s5, '" fill="url(#SVGID_' + i4.id + ')"', "></rect>\n");
        } else t4.push('<rect x="0" y="0" width="100%" height="100%" ', 'fill="', i4, '"', "></rect>\n");
      }, sendToBack: function(t4) {
        if (!t4) return this;
        var e4, r5, n5, s5 = this._activeObject;
        if (t4 === s5 && "activeSelection" === t4.type) for (e4 = (n5 = s5._objects).length; e4--; ) r5 = n5[e4], i3(this._objects, r5), this._objects.unshift(r5);
        else i3(this._objects, t4), this._objects.unshift(t4);
        return this.renderOnAddRemove && this.requestRenderAll(), this;
      }, bringToFront: function(t4) {
        if (!t4) return this;
        var e4, r5, n5, s5 = this._activeObject;
        if (t4 === s5 && "activeSelection" === t4.type) for (n5 = s5._objects, e4 = 0; e4 < n5.length; e4++) r5 = n5[e4], i3(this._objects, r5), this._objects.push(r5);
        else i3(this._objects, t4), this._objects.push(t4);
        return this.renderOnAddRemove && this.requestRenderAll(), this;
      }, sendBackwards: function(t4, e4) {
        if (!t4) return this;
        var r5, n5, s5, o5, a5, h5 = this._activeObject, l4 = 0;
        if (t4 === h5 && "activeSelection" === t4.type) for (a5 = h5._objects, r5 = 0; r5 < a5.length; r5++) n5 = a5[r5], (s5 = this._objects.indexOf(n5)) > 0 + l4 && (o5 = s5 - 1, i3(this._objects, n5), this._objects.splice(o5, 0, n5)), l4++;
        else 0 !== (s5 = this._objects.indexOf(t4)) && (o5 = this._findNewLowerIndex(t4, s5, e4), i3(this._objects, t4), this._objects.splice(o5, 0, t4));
        return this.renderOnAddRemove && this.requestRenderAll(), this;
      }, _findNewLowerIndex: function(t4, e4, i4) {
        var r5, n5;
        if (i4) {
          for (r5 = e4, n5 = e4 - 1; n5 >= 0; --n5) if (t4.intersectsWithObject(this._objects[n5]) || t4.isContainedWithinObject(this._objects[n5]) || this._objects[n5].isContainedWithinObject(t4)) {
            r5 = n5;
            break;
          }
        } else r5 = e4 - 1;
        return r5;
      }, bringForward: function(t4, e4) {
        if (!t4) return this;
        var r5, n5, s5, o5, a5, h5 = this._activeObject, l4 = 0;
        if (t4 === h5 && "activeSelection" === t4.type) for (r5 = (a5 = h5._objects).length; r5--; ) n5 = a5[r5], (s5 = this._objects.indexOf(n5)) < this._objects.length - 1 - l4 && (o5 = s5 + 1, i3(this._objects, n5), this._objects.splice(o5, 0, n5)), l4++;
        else (s5 = this._objects.indexOf(t4)) !== this._objects.length - 1 && (o5 = this._findNewUpperIndex(t4, s5, e4), i3(this._objects, t4), this._objects.splice(o5, 0, t4));
        return this.renderOnAddRemove && this.requestRenderAll(), this;
      }, _findNewUpperIndex: function(t4, e4, i4) {
        var r5, n5, s5;
        if (i4) {
          for (r5 = e4, n5 = e4 + 1, s5 = this._objects.length; n5 < s5; ++n5) if (t4.intersectsWithObject(this._objects[n5]) || t4.isContainedWithinObject(this._objects[n5]) || this._objects[n5].isContainedWithinObject(t4)) {
            r5 = n5;
            break;
          }
        } else r5 = e4 + 1;
        return r5;
      }, moveTo: function(t4, e4) {
        return i3(this._objects, t4), this._objects.splice(e4, 0, t4), this.renderOnAddRemove && this.requestRenderAll();
      }, dispose: function() {
        return this.isRendering && (x3.util.cancelAnimFrame(this.isRendering), this.isRendering = 0), this.forEachObject(function(t4) {
          t4.dispose && t4.dispose();
        }), this._objects = [], this.backgroundImage && this.backgroundImage.dispose && this.backgroundImage.dispose(), this.backgroundImage = null, this.overlayImage && this.overlayImage.dispose && this.overlayImage.dispose(), this.overlayImage = null, this._iTextInstances = null, this.contextContainer = null, this.lowerCanvasEl.classList.remove("lower-canvas"), x3.util.setStyle(this.lowerCanvasEl, this._originalCanvasStyle), delete this._originalCanvasStyle, this.lowerCanvasEl.setAttribute("width", this.width), this.lowerCanvasEl.setAttribute("height", this.height), x3.util.cleanUpJsdomNode(this.lowerCanvasEl), this.lowerCanvasEl = void 0, this;
      }, toString: function() {
        return "#<fabric.Canvas (" + this.complexity() + "): { objects: " + this._objects.length + " }>";
      } }), t3(x3.StaticCanvas.prototype, x3.Observable), t3(x3.StaticCanvas.prototype, x3.Collection), t3(x3.StaticCanvas.prototype, x3.DataURLExporter), t3(x3.StaticCanvas, { EMPTY_JSON: '{"objects": [], "background": "white"}', supports: function(t4) {
        var e4 = a4();
        if (!e4 || !e4.getContext) return null;
        var i4 = e4.getContext("2d");
        return i4 && "setLineDash" === t4 ? void 0 !== i4.setLineDash : null;
      } }), x3.StaticCanvas.prototype.toJSON = x3.StaticCanvas.prototype.toObject, x3.isLikelyNode && (x3.StaticCanvas.prototype.createPNGStream = function() {
        var t4 = o4(this.lowerCanvasEl);
        return t4 && t4.createPNGStream();
      }, x3.StaticCanvas.prototype.createJPEGStream = function(t4) {
        var e4 = o4(this.lowerCanvasEl);
        return e4 && e4.createJPEGStream(t4);
      });
    }
  }(), x3.BaseBrush = x3.util.createClass({ color: "rgb(0, 0, 0)", width: 1, shadow: null, strokeLineCap: "round", strokeLineJoin: "round", strokeMiterLimit: 10, strokeDashArray: null, limitedToCanvasSize: false, _setBrushStyles: function(t3) {
    t3.strokeStyle = this.color, t3.lineWidth = this.width, t3.lineCap = this.strokeLineCap, t3.miterLimit = this.strokeMiterLimit, t3.lineJoin = this.strokeLineJoin, t3.setLineDash(this.strokeDashArray || []);
  }, _saveAndTransform: function(t3) {
    var e3 = this.canvas.viewportTransform;
    t3.save(), t3.transform(e3[0], e3[1], e3[2], e3[3], e3[4], e3[5]);
  }, _setShadow: function() {
    if (this.shadow) {
      var t3 = this.canvas, e3 = this.shadow, i3 = t3.contextTop, r4 = t3.getZoom();
      t3 && t3._isRetinaScaling() && (r4 *= x3.devicePixelRatio), i3.shadowColor = e3.color, i3.shadowBlur = e3.blur * r4, i3.shadowOffsetX = e3.offsetX * r4, i3.shadowOffsetY = e3.offsetY * r4;
    }
  }, needsFullRender: function() {
    return new x3.Color(this.color).getAlpha() < 1 || !!this.shadow;
  }, _resetShadow: function() {
    var t3 = this.canvas.contextTop;
    t3.shadowColor = "", t3.shadowBlur = t3.shadowOffsetX = t3.shadowOffsetY = 0;
  }, _isOutSideCanvas: function(t3) {
    return t3.x < 0 || t3.x > this.canvas.getWidth() || t3.y < 0 || t3.y > this.canvas.getHeight();
  } }), x3.PencilBrush = x3.util.createClass(x3.BaseBrush, { decimate: 0.4, drawStraightLine: false, straightLineKey: "shiftKey", initialize: function(t3) {
    this.canvas = t3, this._points = [];
  }, needsFullRender: function() {
    return this.callSuper("needsFullRender") || this._hasStraightLine;
  }, _drawSegment: function(t3, e3, i3) {
    var r4 = e3.midPointFrom(i3);
    return t3.quadraticCurveTo(e3.x, e3.y, r4.x, r4.y), r4;
  }, onMouseDown: function(t3, e3) {
    this.canvas._isMainEvent(e3.e) && (this.drawStraightLine = e3.e[this.straightLineKey], this._prepareForDrawing(t3), this._captureDrawingPath(t3), this._render());
  }, onMouseMove: function(t3, e3) {
    if (this.canvas._isMainEvent(e3.e) && (this.drawStraightLine = e3.e[this.straightLineKey], (true !== this.limitedToCanvasSize || !this._isOutSideCanvas(t3)) && this._captureDrawingPath(t3) && this._points.length > 1)) if (this.needsFullRender()) this.canvas.clearContext(this.canvas.contextTop), this._render();
    else {
      var i3 = this._points, r4 = i3.length, n4 = this.canvas.contextTop;
      this._saveAndTransform(n4), this.oldEnd && (n4.beginPath(), n4.moveTo(this.oldEnd.x, this.oldEnd.y)), this.oldEnd = this._drawSegment(n4, i3[r4 - 2], i3[r4 - 1], true), n4.stroke(), n4.restore();
    }
  }, onMouseUp: function(t3) {
    return !this.canvas._isMainEvent(t3.e) || (this.drawStraightLine = false, this.oldEnd = void 0, this._finalizeAndAddPath(), false);
  }, _prepareForDrawing: function(t3) {
    var e3 = new x3.Point(t3.x, t3.y);
    this._reset(), this._addPoint(e3), this.canvas.contextTop.moveTo(e3.x, e3.y);
  }, _addPoint: function(t3) {
    return !(this._points.length > 1 && t3.eq(this._points[this._points.length - 1]) || (this.drawStraightLine && this._points.length > 1 && (this._hasStraightLine = true, this._points.pop()), this._points.push(t3), 0));
  }, _reset: function() {
    this._points = [], this._setBrushStyles(this.canvas.contextTop), this._setShadow(), this._hasStraightLine = false;
  }, _captureDrawingPath: function(t3) {
    var e3 = new x3.Point(t3.x, t3.y);
    return this._addPoint(e3);
  }, _render: function(t3) {
    var e3, i3, r4 = this._points[0], n4 = this._points[1];
    if (t3 = t3 || this.canvas.contextTop, this._saveAndTransform(t3), t3.beginPath(), 2 === this._points.length && r4.x === n4.x && r4.y === n4.y) {
      var s4 = this.width / 1e3;
      r4 = new x3.Point(r4.x, r4.y), n4 = new x3.Point(n4.x, n4.y), r4.x -= s4, n4.x += s4;
    }
    for (t3.moveTo(r4.x, r4.y), e3 = 1, i3 = this._points.length; e3 < i3; e3++) this._drawSegment(t3, r4, n4), r4 = this._points[e3], n4 = this._points[e3 + 1];
    t3.lineTo(r4.x, r4.y), t3.stroke(), t3.restore();
  }, convertPointsToSVGPath: function(t3) {
    var e3 = this.width / 1e3;
    return x3.util.getSmoothPathFromPoints(t3, e3);
  }, _isEmptySVGPath: function(t3) {
    return "M 0 0 Q 0 0 0 0 L 0 0" === x3.util.joinPath(t3);
  }, createPath: function(t3) {
    var e3 = new x3.Path(t3, { fill: null, stroke: this.color, strokeWidth: this.width, strokeLineCap: this.strokeLineCap, strokeMiterLimit: this.strokeMiterLimit, strokeLineJoin: this.strokeLineJoin, strokeDashArray: this.strokeDashArray });
    return this.shadow && (this.shadow.affectStroke = true, e3.shadow = new x3.Shadow(this.shadow)), e3;
  }, decimatePoints: function(t3, e3) {
    if (t3.length <= 2) return t3;
    var i3, r4 = this.canvas.getZoom(), n4 = Math.pow(e3 / r4, 2), s4 = t3.length - 1, o4 = t3[0], a4 = [o4];
    for (i3 = 1; i3 < s4 - 1; i3++) Math.pow(o4.x - t3[i3].x, 2) + Math.pow(o4.y - t3[i3].y, 2) >= n4 && (o4 = t3[i3], a4.push(o4));
    return a4.push(t3[s4]), a4;
  }, _finalizeAndAddPath: function() {
    this.canvas.contextTop.closePath(), this.decimate && (this._points = this.decimatePoints(this._points, this.decimate));
    var t3 = this.convertPointsToSVGPath(this._points);
    if (this._isEmptySVGPath(t3)) this.canvas.requestRenderAll();
    else {
      var e3 = this.createPath(t3);
      this.canvas.clearContext(this.canvas.contextTop), this.canvas.fire("before:path:created", { path: e3 }), this.canvas.add(e3), this.canvas.requestRenderAll(), e3.setCoords(), this._resetShadow(), this.canvas.fire("path:created", { path: e3 });
    }
  } }), x3.CircleBrush = x3.util.createClass(x3.BaseBrush, { width: 10, initialize: function(t3) {
    this.canvas = t3, this.points = [];
  }, drawDot: function(t3) {
    var e3 = this.addPoint(t3), i3 = this.canvas.contextTop;
    this._saveAndTransform(i3), this.dot(i3, e3), i3.restore();
  }, dot: function(t3, e3) {
    t3.fillStyle = e3.fill, t3.beginPath(), t3.arc(e3.x, e3.y, e3.radius, 0, 2 * Math.PI, false), t3.closePath(), t3.fill();
  }, onMouseDown: function(t3) {
    this.points.length = 0, this.canvas.clearContext(this.canvas.contextTop), this._setShadow(), this.drawDot(t3);
  }, _render: function() {
    var t3, e3, i3 = this.canvas.contextTop, r4 = this.points;
    for (this._saveAndTransform(i3), t3 = 0, e3 = r4.length; t3 < e3; t3++) this.dot(i3, r4[t3]);
    i3.restore();
  }, onMouseMove: function(t3) {
    true === this.limitedToCanvasSize && this._isOutSideCanvas(t3) || (this.needsFullRender() ? (this.canvas.clearContext(this.canvas.contextTop), this.addPoint(t3), this._render()) : this.drawDot(t3));
  }, onMouseUp: function() {
    var t3, e3, i3 = this.canvas.renderOnAddRemove;
    this.canvas.renderOnAddRemove = false;
    var r4 = [];
    for (t3 = 0, e3 = this.points.length; t3 < e3; t3++) {
      var n4 = this.points[t3], s4 = new x3.Circle({ radius: n4.radius, left: n4.x, top: n4.y, originX: "center", originY: "center", fill: n4.fill });
      this.shadow && (s4.shadow = new x3.Shadow(this.shadow)), r4.push(s4);
    }
    var o4 = new x3.Group(r4);
    o4.canvas = this.canvas, this.canvas.fire("before:path:created", { path: o4 }), this.canvas.add(o4), this.canvas.fire("path:created", { path: o4 }), this.canvas.clearContext(this.canvas.contextTop), this._resetShadow(), this.canvas.renderOnAddRemove = i3, this.canvas.requestRenderAll();
  }, addPoint: function(t3) {
    var e3 = new x3.Point(t3.x, t3.y), i3 = x3.util.getRandomInt(Math.max(0, this.width - 20), this.width + 20) / 2, r4 = new x3.Color(this.color).setAlpha(x3.util.getRandomInt(0, 100) / 100).toRgba();
    return e3.radius = i3, e3.fill = r4, this.points.push(e3), e3;
  } }), x3.SprayBrush = x3.util.createClass(x3.BaseBrush, { width: 10, density: 20, dotWidth: 1, dotWidthVariance: 1, randomOpacity: false, optimizeOverlapping: true, initialize: function(t3) {
    this.canvas = t3, this.sprayChunks = [];
  }, onMouseDown: function(t3) {
    this.sprayChunks.length = 0, this.canvas.clearContext(this.canvas.contextTop), this._setShadow(), this.addSprayChunk(t3), this.render(this.sprayChunkPoints);
  }, onMouseMove: function(t3) {
    true === this.limitedToCanvasSize && this._isOutSideCanvas(t3) || (this.addSprayChunk(t3), this.render(this.sprayChunkPoints));
  }, onMouseUp: function() {
    var t3 = this.canvas.renderOnAddRemove;
    this.canvas.renderOnAddRemove = false;
    for (var e3 = [], i3 = 0, r4 = this.sprayChunks.length; i3 < r4; i3++) for (var n4 = this.sprayChunks[i3], s4 = 0, o4 = n4.length; s4 < o4; s4++) {
      var a4 = new x3.Rect({ width: n4[s4].width, height: n4[s4].width, left: n4[s4].x + 1, top: n4[s4].y + 1, originX: "center", originY: "center", fill: this.color });
      e3.push(a4);
    }
    this.optimizeOverlapping && (e3 = this._getOptimizedRects(e3));
    var h4 = new x3.Group(e3);
    this.shadow && h4.set("shadow", new x3.Shadow(this.shadow)), this.canvas.fire("before:path:created", { path: h4 }), this.canvas.add(h4), this.canvas.fire("path:created", { path: h4 }), this.canvas.clearContext(this.canvas.contextTop), this._resetShadow(), this.canvas.renderOnAddRemove = t3, this.canvas.requestRenderAll();
  }, _getOptimizedRects: function(t3) {
    var e3, i3, r4, n4 = {};
    for (i3 = 0, r4 = t3.length; i3 < r4; i3++) n4[e3 = t3[i3].left + "" + t3[i3].top] || (n4[e3] = t3[i3]);
    var s4 = [];
    for (e3 in n4) s4.push(n4[e3]);
    return s4;
  }, render: function(t3) {
    var e3, i3, r4 = this.canvas.contextTop;
    for (r4.fillStyle = this.color, this._saveAndTransform(r4), e3 = 0, i3 = t3.length; e3 < i3; e3++) {
      var n4 = t3[e3];
      void 0 !== n4.opacity && (r4.globalAlpha = n4.opacity), r4.fillRect(n4.x, n4.y, n4.width, n4.width);
    }
    r4.restore();
  }, _render: function() {
    var t3, e3, i3 = this.canvas.contextTop;
    for (i3.fillStyle = this.color, this._saveAndTransform(i3), t3 = 0, e3 = this.sprayChunks.length; t3 < e3; t3++) this.render(this.sprayChunks[t3]);
    i3.restore();
  }, addSprayChunk: function(t3) {
    this.sprayChunkPoints = [];
    var e3, i3, r4, n4, s4 = this.width / 2;
    for (n4 = 0; n4 < this.density; n4++) {
      e3 = x3.util.getRandomInt(t3.x - s4, t3.x + s4), i3 = x3.util.getRandomInt(t3.y - s4, t3.y + s4), r4 = this.dotWidthVariance ? x3.util.getRandomInt(Math.max(1, this.dotWidth - this.dotWidthVariance), this.dotWidth + this.dotWidthVariance) : this.dotWidth;
      var o4 = new x3.Point(e3, i3);
      o4.width = r4, this.randomOpacity && (o4.opacity = x3.util.getRandomInt(0, 100) / 100), this.sprayChunkPoints.push(o4);
    }
    this.sprayChunks.push(this.sprayChunkPoints);
  } }), x3.PatternBrush = x3.util.createClass(x3.PencilBrush, { getPatternSrc: function() {
    var t3 = x3.util.createCanvasElement(), e3 = t3.getContext("2d");
    return t3.width = t3.height = 25, e3.fillStyle = this.color, e3.beginPath(), e3.arc(10, 10, 10, 0, 2 * Math.PI, false), e3.closePath(), e3.fill(), t3;
  }, getPatternSrcFunction: function() {
    return String(this.getPatternSrc).replace("this.color", '"' + this.color + '"');
  }, getPattern: function(t3) {
    return t3.createPattern(this.source || this.getPatternSrc(), "repeat");
  }, _setBrushStyles: function(t3) {
    this.callSuper("_setBrushStyles", t3), t3.strokeStyle = this.getPattern(t3);
  }, createPath: function(t3) {
    var e3 = this.callSuper("createPath", t3), i3 = e3._getLeftTopCoords().scalarAdd(e3.strokeWidth / 2);
    return e3.stroke = new x3.Pattern({ source: this.source || this.getPatternSrcFunction(), offsetX: -i3.x, offsetY: -i3.y }), e3;
  } }), function() {
    var t3 = x3.util.getPointer, e3 = x3.util.degreesToRadians, i3 = x3.util.isTouchEvent;
    for (var r4 in x3.Canvas = x3.util.createClass(x3.StaticCanvas, { initialize: function(t4, e4) {
      e4 || (e4 = {}), this.renderAndResetBound = this.renderAndReset.bind(this), this.requestRenderAllBound = this.requestRenderAll.bind(this), this._initStatic(t4, e4), this._initInteractive(), this._createCacheCanvas();
    }, uniformScaling: true, uniScaleKey: "shiftKey", centeredScaling: false, centeredRotation: false, centeredKey: "altKey", altActionKey: "shiftKey", interactive: true, selection: true, selectionKey: "shiftKey", altSelectionKey: null, selectionColor: "rgba(100, 100, 255, 0.3)", selectionDashArray: [], selectionBorderColor: "rgba(255, 255, 255, 0.3)", selectionLineWidth: 1, selectionFullyContained: false, hoverCursor: "move", moveCursor: "move", defaultCursor: "default", freeDrawingCursor: "crosshair", notAllowedCursor: "not-allowed", containerClass: "canvas-container", perPixelTargetFind: false, targetFindTolerance: 0, skipTargetFind: false, isDrawingMode: false, preserveObjectStacking: false, snapAngle: 0, snapThreshold: null, stopContextMenu: false, fireRightClick: false, fireMiddleClick: false, targets: [], enablePointerEvents: false, _hoveredTarget: null, _hoveredTargets: [], _initInteractive: function() {
      this._currentTransform = null, this._groupSelector = null, this._initWrapperElement(), this._createUpperCanvas(), this._initEventListeners(), this._initRetinaScaling(), this.freeDrawingBrush = x3.PencilBrush && new x3.PencilBrush(this), this.calcOffset();
    }, _chooseObjectsToRender: function() {
      var t4, e4, i4, r5 = this.getActiveObjects();
      if (r5.length > 0 && !this.preserveObjectStacking) {
        e4 = [], i4 = [];
        for (var n4 = 0, s4 = this._objects.length; n4 < s4; n4++) t4 = this._objects[n4], -1 === r5.indexOf(t4) ? e4.push(t4) : i4.push(t4);
        r5.length > 1 && (this._activeObject._objects = i4), e4.push.apply(e4, i4);
      } else e4 = this._objects;
      return e4;
    }, renderAll: function() {
      !this.contextTopDirty || this._groupSelector || this.isDrawingMode || (this.clearContext(this.contextTop), this.contextTopDirty = false), this.hasLostContext && (this.renderTopLayer(this.contextTop), this.hasLostContext = false);
      var t4 = this.contextContainer;
      return this.renderCanvas(t4, this._chooseObjectsToRender()), this;
    }, renderTopLayer: function(t4) {
      t4.save(), this.isDrawingMode && this._isCurrentlyDrawing && (this.freeDrawingBrush && this.freeDrawingBrush._render(), this.contextTopDirty = true), this.selection && this._groupSelector && (this._drawSelection(t4), this.contextTopDirty = true), t4.restore();
    }, renderTop: function() {
      var t4 = this.contextTop;
      return this.clearContext(t4), this.renderTopLayer(t4), this.fire("after:render"), this;
    }, _normalizePointer: function(t4, e4) {
      var i4 = t4.calcTransformMatrix(), r5 = x3.util.invertTransform(i4), n4 = this.restorePointerVpt(e4);
      return x3.util.transformPoint(n4, r5);
    }, isTargetTransparent: function(t4, e4, i4) {
      if (t4.shouldCache() && t4._cacheCanvas && t4 !== this._activeObject) {
        var r5 = this._normalizePointer(t4, { x: e4, y: i4 }), n4 = Math.max(t4.cacheTranslationX + r5.x * t4.zoomX, 0), s4 = Math.max(t4.cacheTranslationY + r5.y * t4.zoomY, 0);
        return x3.util.isTransparent(t4._cacheContext, Math.round(n4), Math.round(s4), this.targetFindTolerance);
      }
      var o4 = this.contextCache, a4 = t4.selectionBackgroundColor, h4 = this.viewportTransform;
      return t4.selectionBackgroundColor = "", this.clearContext(o4), o4.save(), o4.transform(h4[0], h4[1], h4[2], h4[3], h4[4], h4[5]), t4.render(o4), o4.restore(), t4.selectionBackgroundColor = a4, x3.util.isTransparent(o4, e4, i4, this.targetFindTolerance);
    }, _isSelectionKeyPressed: function(t4) {
      return Array.isArray(this.selectionKey) ? !!this.selectionKey.find(function(e4) {
        return true === t4[e4];
      }) : t4[this.selectionKey];
    }, _shouldClearSelection: function(t4, e4) {
      var i4 = this.getActiveObjects(), r5 = this._activeObject;
      return !e4 || e4 && r5 && i4.length > 1 && -1 === i4.indexOf(e4) && r5 !== e4 && !this._isSelectionKeyPressed(t4) || e4 && !e4.evented || e4 && !e4.selectable && r5 && r5 !== e4;
    }, _shouldCenterTransform: function(t4, e4, i4) {
      var r5;
      if (t4) return "scale" === e4 || "scaleX" === e4 || "scaleY" === e4 || "resizing" === e4 ? r5 = this.centeredScaling || t4.centeredScaling : "rotate" === e4 && (r5 = this.centeredRotation || t4.centeredRotation), r5 ? !i4 : i4;
    }, _getOriginFromCorner: function(t4, e4) {
      var i4 = { x: t4.originX, y: t4.originY };
      return "ml" === e4 || "tl" === e4 || "bl" === e4 ? i4.x = "right" : "mr" !== e4 && "tr" !== e4 && "br" !== e4 || (i4.x = "left"), "tl" === e4 || "mt" === e4 || "tr" === e4 ? i4.y = "bottom" : "bl" !== e4 && "mb" !== e4 && "br" !== e4 || (i4.y = "top"), i4;
    }, _getActionFromCorner: function(t4, e4, i4, r5) {
      if (!e4 || !t4) return "drag";
      var n4 = r5.controls[e4];
      return n4.getActionName(i4, n4, r5);
    }, _setupCurrentTransform: function(t4, i4, r5) {
      if (i4) {
        var n4 = this.getPointer(t4), s4 = i4.__corner, o4 = i4.controls[s4], a4 = r5 && s4 ? o4.getActionHandler(t4, i4, o4) : x3.controlsUtils.dragHandler, h4 = this._getActionFromCorner(r5, s4, t4, i4), l4 = this._getOriginFromCorner(i4, s4), c4 = t4[this.centeredKey], u4 = { target: i4, action: h4, actionHandler: a4, corner: s4, scaleX: i4.scaleX, scaleY: i4.scaleY, skewX: i4.skewX, skewY: i4.skewY, offsetX: n4.x - i4.left, offsetY: n4.y - i4.top, originX: l4.x, originY: l4.y, ex: n4.x, ey: n4.y, lastX: n4.x, lastY: n4.y, theta: e3(i4.angle), width: i4.width * i4.scaleX, shiftKey: t4.shiftKey, altKey: c4, original: x3.util.saveObjectTransform(i4) };
        this._shouldCenterTransform(i4, h4, c4) && (u4.originX = "center", u4.originY = "center"), u4.original.originX = l4.x, u4.original.originY = l4.y, this._currentTransform = u4, this._beforeTransform(t4);
      }
    }, setCursor: function(t4) {
      this.upperCanvasEl.style.cursor = t4;
    }, _drawSelection: function(t4) {
      var e4 = this._groupSelector, i4 = new x3.Point(e4.ex, e4.ey), r5 = x3.util.transformPoint(i4, this.viewportTransform), n4 = new x3.Point(e4.ex + e4.left, e4.ey + e4.top), s4 = x3.util.transformPoint(n4, this.viewportTransform), o4 = Math.min(r5.x, s4.x), a4 = Math.min(r5.y, s4.y), h4 = Math.max(r5.x, s4.x), l4 = Math.max(r5.y, s4.y), c4 = this.selectionLineWidth / 2;
      this.selectionColor && (t4.fillStyle = this.selectionColor, t4.fillRect(o4, a4, h4 - o4, l4 - a4)), this.selectionLineWidth && this.selectionBorderColor && (t4.lineWidth = this.selectionLineWidth, t4.strokeStyle = this.selectionBorderColor, o4 += c4, a4 += c4, h4 -= c4, l4 -= c4, x3.Object.prototype._setLineDash.call(this, t4, this.selectionDashArray), t4.strokeRect(o4, a4, h4 - o4, l4 - a4));
    }, findTarget: function(t4, e4) {
      if (!this.skipTargetFind) {
        var r5, n4, s4 = this.getPointer(t4, true), o4 = this._activeObject, a4 = this.getActiveObjects(), h4 = i3(t4), l4 = a4.length > 1 && !e4 || 1 === a4.length;
        if (this.targets = [], l4 && o4._findTargetCorner(s4, h4)) return o4;
        if (a4.length > 1 && !e4 && o4 === this._searchPossibleTargets([o4], s4)) return o4;
        if (1 === a4.length && o4 === this._searchPossibleTargets([o4], s4)) {
          if (!this.preserveObjectStacking) return o4;
          r5 = o4, n4 = this.targets, this.targets = [];
        }
        var c4 = this._searchPossibleTargets(this._objects, s4);
        return t4[this.altSelectionKey] && c4 && r5 && c4 !== r5 && (c4 = r5, this.targets = n4), c4;
      }
    }, _checkTarget: function(t4, e4, i4) {
      if (e4 && e4.visible && e4.evented && e4.containsPoint(t4)) {
        if (!this.perPixelTargetFind && !e4.perPixelTargetFind || e4.isEditing) return true;
        if (!this.isTargetTransparent(e4, i4.x, i4.y)) return true;
      }
    }, _searchPossibleTargets: function(t4, e4) {
      for (var i4, r5, n4 = t4.length; n4--; ) {
        var s4 = t4[n4], o4 = s4.group ? this._normalizePointer(s4.group, e4) : e4;
        if (this._checkTarget(o4, s4, e4)) {
          (i4 = t4[n4]).subTargetCheck && i4 instanceof x3.Group && (r5 = this._searchPossibleTargets(i4._objects, e4)) && this.targets.push(r5);
          break;
        }
      }
      return i4;
    }, restorePointerVpt: function(t4) {
      return x3.util.transformPoint(t4, x3.util.invertTransform(this.viewportTransform));
    }, getPointer: function(e4, i4) {
      if (this._absolutePointer && !i4) return this._absolutePointer;
      if (this._pointer && i4) return this._pointer;
      var r5, n4 = t3(e4), s4 = this.upperCanvasEl, o4 = s4.getBoundingClientRect(), a4 = o4.width || 0, h4 = o4.height || 0;
      a4 && h4 || ("top" in o4 && "bottom" in o4 && (h4 = Math.abs(o4.top - o4.bottom)), "right" in o4 && "left" in o4 && (a4 = Math.abs(o4.right - o4.left))), this.calcOffset(), n4.x = n4.x - this._offset.left, n4.y = n4.y - this._offset.top, i4 || (n4 = this.restorePointerVpt(n4));
      var l4 = this.getRetinaScaling();
      return 1 !== l4 && (n4.x /= l4, n4.y /= l4), r5 = 0 === a4 || 0 === h4 ? { width: 1, height: 1 } : { width: s4.width / a4, height: s4.height / h4 }, { x: n4.x * r5.width, y: n4.y * r5.height };
    }, _createUpperCanvas: function() {
      var t4 = this.lowerCanvasEl.className.replace(/\s*lower-canvas\s*/, ""), e4 = this.lowerCanvasEl, i4 = this.upperCanvasEl;
      i4 ? i4.className = "" : (i4 = this._createCanvasElement(), this.upperCanvasEl = i4), x3.util.addClass(i4, "upper-canvas " + t4), this.wrapperEl.appendChild(i4), this._copyCanvasStyle(e4, i4), this._applyCanvasStyle(i4), this.contextTop = i4.getContext("2d");
    }, getTopContext: function() {
      return this.contextTop;
    }, _createCacheCanvas: function() {
      this.cacheCanvasEl = this._createCanvasElement(), this.cacheCanvasEl.setAttribute("width", this.width), this.cacheCanvasEl.setAttribute("height", this.height), this.contextCache = this.cacheCanvasEl.getContext("2d");
    }, _initWrapperElement: function() {
      this.wrapperEl = x3.util.wrapElement(this.lowerCanvasEl, "div", { class: this.containerClass }), x3.util.setStyle(this.wrapperEl, { width: this.width + "px", height: this.height + "px", position: "relative" }), x3.util.makeElementUnselectable(this.wrapperEl);
    }, _applyCanvasStyle: function(t4) {
      var e4 = this.width || t4.width, i4 = this.height || t4.height;
      x3.util.setStyle(t4, { position: "absolute", width: e4 + "px", height: i4 + "px", left: 0, top: 0, "touch-action": this.allowTouchScrolling ? "manipulation" : "none", "-ms-touch-action": this.allowTouchScrolling ? "manipulation" : "none" }), t4.width = e4, t4.height = i4, x3.util.makeElementUnselectable(t4);
    }, _copyCanvasStyle: function(t4, e4) {
      e4.style.cssText = t4.style.cssText;
    }, getSelectionContext: function() {
      return this.contextTop;
    }, getSelectionElement: function() {
      return this.upperCanvasEl;
    }, getActiveObject: function() {
      return this._activeObject;
    }, getActiveObjects: function() {
      var t4 = this._activeObject;
      return t4 ? "activeSelection" === t4.type && t4._objects ? t4._objects.slice(0) : [t4] : [];
    }, _onObjectRemoved: function(t4) {
      t4 === this._activeObject && (this.fire("before:selection:cleared", { target: t4 }), this._discardActiveObject(), this.fire("selection:cleared", { target: t4 }), t4.fire("deselected")), t4 === this._hoveredTarget && (this._hoveredTarget = null, this._hoveredTargets = []), this.callSuper("_onObjectRemoved", t4);
    }, _fireSelectionEvents: function(t4, e4) {
      var i4 = false, r5 = this.getActiveObjects(), n4 = [], s4 = [];
      t4.forEach(function(t5) {
        -1 === r5.indexOf(t5) && (i4 = true, t5.fire("deselected", { e: e4, target: t5 }), s4.push(t5));
      }), r5.forEach(function(r6) {
        -1 === t4.indexOf(r6) && (i4 = true, r6.fire("selected", { e: e4, target: r6 }), n4.push(r6));
      }), t4.length > 0 && r5.length > 0 ? i4 && this.fire("selection:updated", { e: e4, selected: n4, deselected: s4 }) : r5.length > 0 ? this.fire("selection:created", { e: e4, selected: n4 }) : t4.length > 0 && this.fire("selection:cleared", { e: e4, deselected: s4 });
    }, setActiveObject: function(t4, e4) {
      var i4 = this.getActiveObjects();
      return this._setActiveObject(t4, e4), this._fireSelectionEvents(i4, e4), this;
    }, _setActiveObject: function(t4, e4) {
      return this._activeObject !== t4 && !!this._discardActiveObject(e4, t4) && !t4.onSelect({ e: e4 }) && (this._activeObject = t4, true);
    }, _discardActiveObject: function(t4, e4) {
      var i4 = this._activeObject;
      if (i4) {
        if (i4.onDeselect({ e: t4, object: e4 })) return false;
        this._activeObject = null;
      }
      return true;
    }, discardActiveObject: function(t4) {
      var e4 = this.getActiveObjects(), i4 = this.getActiveObject();
      return e4.length && this.fire("before:selection:cleared", { target: i4, e: t4 }), this._discardActiveObject(t4), this._fireSelectionEvents(e4, t4), this;
    }, dispose: function() {
      var t4 = this.wrapperEl;
      return this.removeListeners(), t4.removeChild(this.upperCanvasEl), t4.removeChild(this.lowerCanvasEl), this.contextCache = null, this.contextTop = null, ["upperCanvasEl", "cacheCanvasEl"].forEach((function(t5) {
        x3.util.cleanUpJsdomNode(this[t5]), this[t5] = void 0;
      }).bind(this)), t4.parentNode && t4.parentNode.replaceChild(this.lowerCanvasEl, this.wrapperEl), delete this.wrapperEl, x3.StaticCanvas.prototype.dispose.call(this), this;
    }, clear: function() {
      return this.discardActiveObject(), this.clearContext(this.contextTop), this.callSuper("clear");
    }, drawControls: function(t4) {
      var e4 = this._activeObject;
      e4 && e4._renderControls(t4);
    }, _toObject: function(t4, e4, i4) {
      var r5 = this._realizeGroupTransformOnObject(t4), n4 = this.callSuper("_toObject", t4, e4, i4);
      return this._unwindGroupTransformOnObject(t4, r5), n4;
    }, _realizeGroupTransformOnObject: function(t4) {
      if (t4.group && "activeSelection" === t4.group.type && this._activeObject === t4.group) {
        var e4 = {};
        return ["angle", "flipX", "flipY", "left", "scaleX", "scaleY", "skewX", "skewY", "top"].forEach(function(i4) {
          e4[i4] = t4[i4];
        }), x3.util.addTransformToObject(t4, this._activeObject.calcOwnMatrix()), e4;
      }
      return null;
    }, _unwindGroupTransformOnObject: function(t4, e4) {
      e4 && t4.set(e4);
    }, _setSVGObject: function(t4, e4, i4) {
      var r5 = this._realizeGroupTransformOnObject(e4);
      this.callSuper("_setSVGObject", t4, e4, i4), this._unwindGroupTransformOnObject(e4, r5);
    }, setViewportTransform: function(t4) {
      this.renderOnAddRemove && this._activeObject && this._activeObject.isEditing && this._activeObject.clearContextTop(), x3.StaticCanvas.prototype.setViewportTransform.call(this, t4);
    } }), x3.StaticCanvas) "prototype" !== r4 && (x3.Canvas[r4] = x3.StaticCanvas[r4]);
  }(), function() {
    var t3 = x3.util.addListener, e3 = x3.util.removeListener, i3 = { passive: false };
    function r4(t4, e4) {
      return t4.button && t4.button === e4 - 1;
    }
    x3.util.object.extend(x3.Canvas.prototype, { mainTouchId: null, _initEventListeners: function() {
      this.removeListeners(), this._bindEvents(), this.addOrRemove(t3, "add");
    }, _getEventPrefix: function() {
      return this.enablePointerEvents ? "pointer" : "mouse";
    }, addOrRemove: function(t4, e4) {
      var r5 = this.upperCanvasEl, n4 = this._getEventPrefix();
      t4(x3.window, "resize", this._onResize), t4(r5, n4 + "down", this._onMouseDown), t4(r5, n4 + "move", this._onMouseMove, i3), t4(r5, n4 + "out", this._onMouseOut), t4(r5, n4 + "enter", this._onMouseEnter), t4(r5, "wheel", this._onMouseWheel), t4(r5, "contextmenu", this._onContextMenu), t4(r5, "dblclick", this._onDoubleClick), t4(r5, "dragover", this._onDragOver), t4(r5, "dragenter", this._onDragEnter), t4(r5, "dragleave", this._onDragLeave), t4(r5, "drop", this._onDrop), this.enablePointerEvents || t4(r5, "touchstart", this._onTouchStart, i3), "undefined" != typeof eventjs && e4 in eventjs && (eventjs[e4](r5, "gesture", this._onGesture), eventjs[e4](r5, "drag", this._onDrag), eventjs[e4](r5, "orientation", this._onOrientationChange), eventjs[e4](r5, "shake", this._onShake), eventjs[e4](r5, "longpress", this._onLongPress));
    }, removeListeners: function() {
      this.addOrRemove(e3, "remove");
      var t4 = this._getEventPrefix();
      e3(x3.document, t4 + "up", this._onMouseUp), e3(x3.document, "touchend", this._onTouchEnd, i3), e3(x3.document, t4 + "move", this._onMouseMove, i3), e3(x3.document, "touchmove", this._onMouseMove, i3);
    }, _bindEvents: function() {
      this.eventsBound || (this._onMouseDown = this._onMouseDown.bind(this), this._onTouchStart = this._onTouchStart.bind(this), this._onMouseMove = this._onMouseMove.bind(this), this._onMouseUp = this._onMouseUp.bind(this), this._onTouchEnd = this._onTouchEnd.bind(this), this._onResize = this._onResize.bind(this), this._onGesture = this._onGesture.bind(this), this._onDrag = this._onDrag.bind(this), this._onShake = this._onShake.bind(this), this._onLongPress = this._onLongPress.bind(this), this._onOrientationChange = this._onOrientationChange.bind(this), this._onMouseWheel = this._onMouseWheel.bind(this), this._onMouseOut = this._onMouseOut.bind(this), this._onMouseEnter = this._onMouseEnter.bind(this), this._onContextMenu = this._onContextMenu.bind(this), this._onDoubleClick = this._onDoubleClick.bind(this), this._onDragOver = this._onDragOver.bind(this), this._onDragEnter = this._simpleEventHandler.bind(this, "dragenter"), this._onDragLeave = this._simpleEventHandler.bind(this, "dragleave"), this._onDrop = this._onDrop.bind(this), this.eventsBound = true);
    }, _onGesture: function(t4, e4) {
      this.__onTransformGesture && this.__onTransformGesture(t4, e4);
    }, _onDrag: function(t4, e4) {
      this.__onDrag && this.__onDrag(t4, e4);
    }, _onMouseWheel: function(t4) {
      this.__onMouseWheel(t4);
    }, _onMouseOut: function(t4) {
      var e4 = this._hoveredTarget;
      this.fire("mouse:out", { target: e4, e: t4 }), this._hoveredTarget = null, e4 && e4.fire("mouseout", { e: t4 });
      var i4 = this;
      this._hoveredTargets.forEach(function(r5) {
        i4.fire("mouse:out", { target: e4, e: t4 }), r5 && e4.fire("mouseout", { e: t4 });
      }), this._hoveredTargets = [], this._iTextInstances && this._iTextInstances.forEach(function(t5) {
        t5.isEditing && t5.hiddenTextarea.focus();
      });
    }, _onMouseEnter: function(t4) {
      this._currentTransform || this.findTarget(t4) || (this.fire("mouse:over", { target: null, e: t4 }), this._hoveredTarget = null, this._hoveredTargets = []);
    }, _onOrientationChange: function(t4, e4) {
      this.__onOrientationChange && this.__onOrientationChange(t4, e4);
    }, _onShake: function(t4, e4) {
      this.__onShake && this.__onShake(t4, e4);
    }, _onLongPress: function(t4, e4) {
      this.__onLongPress && this.__onLongPress(t4, e4);
    }, _onDragOver: function(t4) {
      t4.preventDefault();
      var e4 = this._simpleEventHandler("dragover", t4);
      this._fireEnterLeaveEvents(e4, t4);
    }, _onDrop: function(t4) {
      return this._simpleEventHandler("drop:before", t4), this._simpleEventHandler("drop", t4);
    }, _onContextMenu: function(t4) {
      return this.stopContextMenu && (t4.stopPropagation(), t4.preventDefault()), false;
    }, _onDoubleClick: function(t4) {
      this._cacheTransformEventData(t4), this._handleEvent(t4, "dblclick"), this._resetTransformEventData(t4);
    }, getPointerId: function(t4) {
      var e4 = t4.changedTouches;
      return e4 ? e4[0] && e4[0].identifier : this.enablePointerEvents ? t4.pointerId : -1;
    }, _isMainEvent: function(t4) {
      return true === t4.isPrimary || false !== t4.isPrimary && ("touchend" === t4.type && 0 === t4.touches.length || !t4.changedTouches || t4.changedTouches[0].identifier === this.mainTouchId);
    }, _onTouchStart: function(r5) {
      r5.preventDefault(), null === this.mainTouchId && (this.mainTouchId = this.getPointerId(r5)), this.__onMouseDown(r5), this._resetTransformEventData();
      var n4 = this.upperCanvasEl, s4 = this._getEventPrefix();
      t3(x3.document, "touchend", this._onTouchEnd, i3), t3(x3.document, "touchmove", this._onMouseMove, i3), e3(n4, s4 + "down", this._onMouseDown);
    }, _onMouseDown: function(r5) {
      this.__onMouseDown(r5), this._resetTransformEventData();
      var n4 = this.upperCanvasEl, s4 = this._getEventPrefix();
      e3(n4, s4 + "move", this._onMouseMove, i3), t3(x3.document, s4 + "up", this._onMouseUp), t3(x3.document, s4 + "move", this._onMouseMove, i3);
    }, _onTouchEnd: function(r5) {
      if (!(r5.touches.length > 0)) {
        this.__onMouseUp(r5), this._resetTransformEventData(), this.mainTouchId = null;
        var n4 = this._getEventPrefix();
        e3(x3.document, "touchend", this._onTouchEnd, i3), e3(x3.document, "touchmove", this._onMouseMove, i3);
        var s4 = this;
        this._willAddMouseDown && clearTimeout(this._willAddMouseDown), this._willAddMouseDown = setTimeout(function() {
          t3(s4.upperCanvasEl, n4 + "down", s4._onMouseDown), s4._willAddMouseDown = 0;
        }, 400);
      }
    }, _onMouseUp: function(r5) {
      this.__onMouseUp(r5), this._resetTransformEventData();
      var n4 = this.upperCanvasEl, s4 = this._getEventPrefix();
      this._isMainEvent(r5) && (e3(x3.document, s4 + "up", this._onMouseUp), e3(x3.document, s4 + "move", this._onMouseMove, i3), t3(n4, s4 + "move", this._onMouseMove, i3));
    }, _onMouseMove: function(t4) {
      !this.allowTouchScrolling && t4.preventDefault && t4.preventDefault(), this.__onMouseMove(t4);
    }, _onResize: function() {
      this.calcOffset();
    }, _shouldRender: function(t4) {
      var e4 = this._activeObject;
      return !!(!!e4 != !!t4 || e4 && t4 && e4 !== t4) || (e4 && e4.isEditing, false);
    }, __onMouseUp: function(t4) {
      var e4, i4 = this._currentTransform, n4 = this._groupSelector, s4 = false, o4 = !n4 || 0 === n4.left && 0 === n4.top;
      if (this._cacheTransformEventData(t4), e4 = this._target, this._handleEvent(t4, "up:before"), r4(t4, 3)) this.fireRightClick && this._handleEvent(t4, "up", 3, o4);
      else {
        if (r4(t4, 2)) return this.fireMiddleClick && this._handleEvent(t4, "up", 2, o4), void this._resetTransformEventData();
        if (this.isDrawingMode && this._isCurrentlyDrawing) this._onMouseUpInDrawingMode(t4);
        else if (this._isMainEvent(t4)) {
          if (i4 && (this._finalizeCurrentTransform(t4), s4 = i4.actionPerformed), !o4) {
            var a4 = e4 === this._activeObject;
            this._maybeGroupObjects(t4), s4 || (s4 = this._shouldRender(e4) || !a4 && e4 === this._activeObject);
          }
          var h4, l4;
          if (e4) {
            if (h4 = e4._findTargetCorner(this.getPointer(t4, true), x3.util.isTouchEvent(t4)), e4.selectable && e4 !== this._activeObject && "up" === e4.activeOn) this.setActiveObject(e4, t4), s4 = true;
            else {
              var c4 = e4.controls[h4], u4 = c4 && c4.getMouseUpHandler(t4, e4, c4);
              u4 && u4(t4, i4, (l4 = this.getPointer(t4)).x, l4.y);
            }
            e4.isMoving = false;
          }
          if (i4 && (i4.target !== e4 || i4.corner !== h4)) {
            var d4 = i4.target && i4.target.controls[i4.corner], f4 = d4 && d4.getMouseUpHandler(t4, e4, c4);
            l4 = l4 || this.getPointer(t4), f4 && f4(t4, i4, l4.x, l4.y);
          }
          this._setCursorFromEvent(t4, e4), this._handleEvent(t4, "up", 1, o4), this._groupSelector = null, this._currentTransform = null, e4 && (e4.__corner = 0), s4 ? this.requestRenderAll() : o4 || this.renderTop();
        }
      }
    }, _simpleEventHandler: function(t4, e4) {
      var i4 = this.findTarget(e4), r5 = this.targets, n4 = { e: e4, target: i4, subTargets: r5 };
      if (this.fire(t4, n4), i4 && i4.fire(t4, n4), !r5) return i4;
      for (var s4 = 0; s4 < r5.length; s4++) r5[s4].fire(t4, n4);
      return i4;
    }, _handleEvent: function(t4, e4, i4, r5) {
      var n4 = this._target, s4 = this.targets || [], o4 = { e: t4, target: n4, subTargets: s4, button: i4 || 1, isClick: r5 || false, pointer: this._pointer, absolutePointer: this._absolutePointer, transform: this._currentTransform };
      "up" === e4 && (o4.currentTarget = this.findTarget(t4), o4.currentSubTargets = this.targets), this.fire("mouse:" + e4, o4), n4 && n4.fire("mouse" + e4, o4);
      for (var a4 = 0; a4 < s4.length; a4++) s4[a4].fire("mouse" + e4, o4);
    }, _finalizeCurrentTransform: function(t4) {
      var e4 = this._currentTransform, i4 = e4.target, r5 = { e: t4, target: i4, transform: e4, action: e4.action };
      i4._scaling && (i4._scaling = false), i4.setCoords(), (e4.actionPerformed || this.stateful && i4.hasStateChanged()) && this._fire("modified", r5);
    }, _onMouseDownInDrawingMode: function(t4) {
      this._isCurrentlyDrawing = true, this.getActiveObject() && this.discardActiveObject(t4).requestRenderAll();
      var e4 = this.getPointer(t4);
      this.freeDrawingBrush.onMouseDown(e4, { e: t4, pointer: e4 }), this._handleEvent(t4, "down");
    }, _onMouseMoveInDrawingMode: function(t4) {
      if (this._isCurrentlyDrawing) {
        var e4 = this.getPointer(t4);
        this.freeDrawingBrush.onMouseMove(e4, { e: t4, pointer: e4 });
      }
      this.setCursor(this.freeDrawingCursor), this._handleEvent(t4, "move");
    }, _onMouseUpInDrawingMode: function(t4) {
      var e4 = this.getPointer(t4);
      this._isCurrentlyDrawing = this.freeDrawingBrush.onMouseUp({ e: t4, pointer: e4 }), this._handleEvent(t4, "up");
    }, __onMouseDown: function(t4) {
      this._cacheTransformEventData(t4), this._handleEvent(t4, "down:before");
      var e4 = this._target;
      if (r4(t4, 3)) this.fireRightClick && this._handleEvent(t4, "down", 3);
      else if (r4(t4, 2)) this.fireMiddleClick && this._handleEvent(t4, "down", 2);
      else if (this.isDrawingMode) this._onMouseDownInDrawingMode(t4);
      else if (this._isMainEvent(t4) && !this._currentTransform) {
        var i4 = this._pointer;
        this._previousPointer = i4;
        var n4 = this._shouldRender(e4), s4 = this._shouldGroup(t4, e4);
        if (this._shouldClearSelection(t4, e4) ? this.discardActiveObject(t4) : s4 && (this._handleGrouping(t4, e4), e4 = this._activeObject), !this.selection || e4 && (e4.selectable || e4.isEditing || e4 === this._activeObject) || (this._groupSelector = { ex: this._absolutePointer.x, ey: this._absolutePointer.y, top: 0, left: 0 }), e4) {
          var o4 = e4 === this._activeObject;
          e4.selectable && "down" === e4.activeOn && this.setActiveObject(e4, t4);
          var a4 = e4._findTargetCorner(this.getPointer(t4, true), x3.util.isTouchEvent(t4));
          if (e4.__corner = a4, e4 === this._activeObject && (a4 || !s4)) {
            this._setupCurrentTransform(t4, e4, o4);
            var h4 = e4.controls[a4], l4 = (i4 = this.getPointer(t4), h4 && h4.getMouseDownHandler(t4, e4, h4));
            l4 && l4(t4, this._currentTransform, i4.x, i4.y);
          }
        }
        this._handleEvent(t4, "down"), (n4 || s4) && this.requestRenderAll();
      }
    }, _resetTransformEventData: function() {
      this._target = null, this._pointer = null, this._absolutePointer = null;
    }, _cacheTransformEventData: function(t4) {
      this._resetTransformEventData(), this._pointer = this.getPointer(t4, true), this._absolutePointer = this.restorePointerVpt(this._pointer), this._target = this._currentTransform ? this._currentTransform.target : this.findTarget(t4) || null;
    }, _beforeTransform: function(t4) {
      var e4 = this._currentTransform;
      this.stateful && e4.target.saveState(), this.fire("before:transform", { e: t4, transform: e4 });
    }, __onMouseMove: function(t4) {
      var e4, i4;
      if (this._handleEvent(t4, "move:before"), this._cacheTransformEventData(t4), this.isDrawingMode) this._onMouseMoveInDrawingMode(t4);
      else if (this._isMainEvent(t4)) {
        var r5 = this._groupSelector;
        r5 ? (i4 = this._absolutePointer, r5.left = i4.x - r5.ex, r5.top = i4.y - r5.ey, this.renderTop()) : this._currentTransform ? this._transformObject(t4) : (e4 = this.findTarget(t4) || null, this._setCursorFromEvent(t4, e4), this._fireOverOutEvents(e4, t4)), this._handleEvent(t4, "move"), this._resetTransformEventData();
      }
    }, _fireOverOutEvents: function(t4, e4) {
      var i4 = this._hoveredTarget, r5 = this._hoveredTargets, n4 = this.targets, s4 = Math.max(r5.length, n4.length);
      this.fireSyntheticInOutEvents(t4, e4, { oldTarget: i4, evtOut: "mouseout", canvasEvtOut: "mouse:out", evtIn: "mouseover", canvasEvtIn: "mouse:over" });
      for (var o4 = 0; o4 < s4; o4++) this.fireSyntheticInOutEvents(n4[o4], e4, { oldTarget: r5[o4], evtOut: "mouseout", evtIn: "mouseover" });
      this._hoveredTarget = t4, this._hoveredTargets = this.targets.concat();
    }, _fireEnterLeaveEvents: function(t4, e4) {
      var i4 = this._draggedoverTarget, r5 = this._hoveredTargets, n4 = this.targets, s4 = Math.max(r5.length, n4.length);
      this.fireSyntheticInOutEvents(t4, e4, { oldTarget: i4, evtOut: "dragleave", evtIn: "dragenter" });
      for (var o4 = 0; o4 < s4; o4++) this.fireSyntheticInOutEvents(n4[o4], e4, { oldTarget: r5[o4], evtOut: "dragleave", evtIn: "dragenter" });
      this._draggedoverTarget = t4;
    }, fireSyntheticInOutEvents: function(t4, e4, i4) {
      var r5, n4, s4, o4 = i4.oldTarget, a4 = o4 !== t4, h4 = i4.canvasEvtIn, l4 = i4.canvasEvtOut;
      a4 && (r5 = { e: e4, target: t4, previousTarget: o4 }, n4 = { e: e4, target: o4, nextTarget: t4 }), s4 = t4 && a4, o4 && a4 && (l4 && this.fire(l4, n4), o4.fire(i4.evtOut, n4)), s4 && (h4 && this.fire(h4, r5), t4.fire(i4.evtIn, r5));
    }, __onMouseWheel: function(t4) {
      this._cacheTransformEventData(t4), this._handleEvent(t4, "wheel"), this._resetTransformEventData();
    }, _transformObject: function(t4) {
      var e4 = this.getPointer(t4), i4 = this._currentTransform;
      i4.reset = false, i4.shiftKey = t4.shiftKey, i4.altKey = t4[this.centeredKey], this._performTransformAction(t4, i4, e4), i4.actionPerformed && this.requestRenderAll();
    }, _performTransformAction: function(t4, e4, i4) {
      var r5 = i4.x, n4 = i4.y, s4 = e4.action, o4 = false, a4 = e4.actionHandler;
      a4 && (o4 = a4(t4, e4, r5, n4)), "drag" === s4 && o4 && (e4.target.isMoving = true, this.setCursor(e4.target.moveCursor || this.moveCursor)), e4.actionPerformed = e4.actionPerformed || o4;
    }, _fire: x3.controlsUtils.fireEvent, _setCursorFromEvent: function(t4, e4) {
      if (!e4) return this.setCursor(this.defaultCursor), false;
      var i4 = e4.hoverCursor || this.hoverCursor, r5 = this._activeObject && "activeSelection" === this._activeObject.type ? this._activeObject : null, n4 = (!r5 || !r5.contains(e4)) && e4._findTargetCorner(this.getPointer(t4, true));
      n4 ? this.setCursor(this.getCornerCursor(n4, e4, t4)) : (e4.subTargetCheck && this.targets.concat().reverse().map(function(t5) {
        i4 = t5.hoverCursor || i4;
      }), this.setCursor(i4));
    }, getCornerCursor: function(t4, e4, i4) {
      var r5 = e4.controls[t4];
      return r5.cursorStyleHandler(i4, r5, e4);
    } });
  }(), _3 = Math.min, y3 = Math.max, x3.util.object.extend(x3.Canvas.prototype, { _shouldGroup: function(t3, e3) {
    var i3 = this._activeObject;
    return i3 && this._isSelectionKeyPressed(t3) && e3 && e3.selectable && this.selection && (i3 !== e3 || "activeSelection" === i3.type) && !e3.onSelect({ e: t3 });
  }, _handleGrouping: function(t3, e3) {
    var i3 = this._activeObject;
    i3.__corner || (e3 !== i3 || (e3 = this.findTarget(t3, true)) && e3.selectable) && (i3 && "activeSelection" === i3.type ? this._updateActiveSelection(e3, t3) : this._createActiveSelection(e3, t3));
  }, _updateActiveSelection: function(t3, e3) {
    var i3 = this._activeObject, r4 = i3._objects.slice(0);
    i3.contains(t3) ? (i3.removeWithUpdate(t3), this._hoveredTarget = t3, this._hoveredTargets = this.targets.concat(), 1 === i3.size() && this._setActiveObject(i3.item(0), e3)) : (i3.addWithUpdate(t3), this._hoveredTarget = i3, this._hoveredTargets = this.targets.concat()), this._fireSelectionEvents(r4, e3);
  }, _createActiveSelection: function(t3, e3) {
    var i3 = this.getActiveObjects(), r4 = this._createGroup(t3);
    this._hoveredTarget = r4, this._setActiveObject(r4, e3), this._fireSelectionEvents(i3, e3);
  }, _createGroup: function(t3) {
    var e3 = this._objects, i3 = e3.indexOf(this._activeObject) < e3.indexOf(t3) ? [this._activeObject, t3] : [t3, this._activeObject];
    return this._activeObject.isEditing && this._activeObject.exitEditing(), new x3.ActiveSelection(i3, { canvas: this });
  }, _groupSelectedObjects: function(t3) {
    var e3, i3 = this._collectObjects(t3);
    1 === i3.length ? this.setActiveObject(i3[0], t3) : i3.length > 1 && (e3 = new x3.ActiveSelection(i3.reverse(), { canvas: this }), this.setActiveObject(e3, t3));
  }, _collectObjects: function(t3) {
    for (var e3, i3 = [], r4 = this._groupSelector.ex, n4 = this._groupSelector.ey, s4 = r4 + this._groupSelector.left, o4 = n4 + this._groupSelector.top, a4 = new x3.Point(_3(r4, s4), _3(n4, o4)), h4 = new x3.Point(y3(r4, s4), y3(n4, o4)), l4 = !this.selectionFullyContained, c4 = r4 === s4 && n4 === o4, u4 = this._objects.length; u4-- && !((e3 = this._objects[u4]) && e3.selectable && e3.visible && (l4 && e3.intersectsWithRect(a4, h4, true) || e3.isContainedWithinRect(a4, h4, true) || l4 && e3.containsPoint(a4, null, true) || l4 && e3.containsPoint(h4, null, true)) && (i3.push(e3), c4)); ) ;
    return i3.length > 1 && (i3 = i3.filter(function(e4) {
      return !e4.onSelect({ e: t3 });
    })), i3;
  }, _maybeGroupObjects: function(t3) {
    this.selection && this._groupSelector && this._groupSelectedObjects(t3), this.setCursor(this.defaultCursor), this._groupSelector = null;
  } }), x3.util.object.extend(x3.StaticCanvas.prototype, { toDataURL: function(t3) {
    t3 || (t3 = {});
    var e3 = t3.format || "png", i3 = t3.quality || 1, r4 = (t3.multiplier || 1) * (t3.enableRetinaScaling ? this.getRetinaScaling() : 1), n4 = this.toCanvasElement(r4, t3);
    return x3.util.toDataURL(n4, e3, i3);
  }, toCanvasElement: function(t3, e3) {
    t3 = t3 || 1;
    var i3 = ((e3 = e3 || {}).width || this.width) * t3, r4 = (e3.height || this.height) * t3, n4 = this.getZoom(), s4 = this.width, o4 = this.height, a4 = n4 * t3, h4 = this.viewportTransform, l4 = (h4[4] - (e3.left || 0)) * t3, c4 = (h4[5] - (e3.top || 0)) * t3, u4 = this.interactive, d4 = [a4, 0, 0, a4, l4, c4], f4 = this.enableRetinaScaling, g4 = x3.util.createCanvasElement(), p4 = this.contextTop;
    return g4.width = i3, g4.height = r4, this.contextTop = null, this.enableRetinaScaling = false, this.interactive = false, this.viewportTransform = d4, this.width = i3, this.height = r4, this.calcViewportBoundaries(), this.renderCanvas(g4.getContext("2d"), this._objects), this.viewportTransform = h4, this.width = s4, this.height = o4, this.calcViewportBoundaries(), this.interactive = u4, this.enableRetinaScaling = f4, this.contextTop = p4, g4;
  } }), x3.util.object.extend(x3.StaticCanvas.prototype, { loadFromJSON: function(t3, e3, i3) {
    if (t3) {
      var r4 = "string" == typeof t3 ? JSON.parse(t3) : x3.util.object.clone(t3), n4 = this, s4 = r4.clipPath, o4 = this.renderOnAddRemove;
      return this.renderOnAddRemove = false, delete r4.clipPath, this._enlivenObjects(r4.objects, function(t4) {
        n4.clear(), n4._setBgOverlay(r4, function() {
          s4 ? n4._enlivenObjects([s4], function(i4) {
            n4.clipPath = i4[0], n4.__setupCanvas.call(n4, r4, t4, o4, e3);
          }) : n4.__setupCanvas.call(n4, r4, t4, o4, e3);
        });
      }, i3), this;
    }
  }, __setupCanvas: function(t3, e3, i3, r4) {
    var n4 = this;
    e3.forEach(function(t4, e4) {
      n4.insertAt(t4, e4);
    }), this.renderOnAddRemove = i3, delete t3.objects, delete t3.backgroundImage, delete t3.overlayImage, delete t3.background, delete t3.overlay, this._setOptions(t3), this.renderAll(), r4 && r4();
  }, _setBgOverlay: function(t3, e3) {
    var i3 = { backgroundColor: false, overlayColor: false, backgroundImage: false, overlayImage: false };
    if (t3.backgroundImage || t3.overlayImage || t3.background || t3.overlay) {
      var r4 = function() {
        i3.backgroundImage && i3.overlayImage && i3.backgroundColor && i3.overlayColor && e3 && e3();
      };
      this.__setBgOverlay("backgroundImage", t3.backgroundImage, i3, r4), this.__setBgOverlay("overlayImage", t3.overlayImage, i3, r4), this.__setBgOverlay("backgroundColor", t3.background, i3, r4), this.__setBgOverlay("overlayColor", t3.overlay, i3, r4);
    } else e3 && e3();
  }, __setBgOverlay: function(t3, e3, i3, r4) {
    var n4 = this;
    if (!e3) return i3[t3] = true, void (r4 && r4());
    "backgroundImage" === t3 || "overlayImage" === t3 ? x3.util.enlivenObjects([e3], function(e4) {
      n4[t3] = e4[0], i3[t3] = true, r4 && r4();
    }) : this["set" + x3.util.string.capitalize(t3, true)](e3, function() {
      i3[t3] = true, r4 && r4();
    });
  }, _enlivenObjects: function(t3, e3, i3) {
    t3 && 0 !== t3.length ? x3.util.enlivenObjects(t3, function(t4) {
      e3 && e3(t4);
    }, null, i3) : e3 && e3([]);
  }, _toDataURL: function(t3, e3) {
    this.clone(function(i3) {
      e3(i3.toDataURL(t3));
    });
  }, _toDataURLWithMultiplier: function(t3, e3, i3) {
    this.clone(function(r4) {
      i3(r4.toDataURLWithMultiplier(t3, e3));
    });
  }, clone: function(t3, e3) {
    var i3 = JSON.stringify(this.toJSON(e3));
    this.cloneWithoutData(function(e4) {
      e4.loadFromJSON(i3, function() {
        t3 && t3(e4);
      });
    });
  }, cloneWithoutData: function(t3) {
    var e3 = x3.util.createCanvasElement();
    e3.width = this.width, e3.height = this.height;
    var i3 = new x3.Canvas(e3);
    this.backgroundImage ? (i3.setBackgroundImage(this.backgroundImage.src, function() {
      i3.renderAll(), t3 && t3(i3);
    }), i3.backgroundImageOpacity = this.backgroundImageOpacity, i3.backgroundImageStretch = this.backgroundImageStretch) : t3 && t3(i3);
  } }), function(t3) {
    var e3 = t3.fabric || (t3.fabric = {}), i3 = e3.util.object.extend, r4 = e3.util.object.clone, n4 = e3.util.toFixed, s4 = e3.util.string.capitalize, o4 = e3.util.degreesToRadians, a4 = !e3.isLikelyNode;
    e3.Object || (e3.Object = e3.util.createClass(e3.CommonMethods, { type: "object", originX: "left", originY: "top", top: 0, left: 0, width: 0, height: 0, scaleX: 1, scaleY: 1, flipX: false, flipY: false, opacity: 1, angle: 0, skewX: 0, skewY: 0, cornerSize: 13, touchCornerSize: 24, transparentCorners: true, hoverCursor: null, moveCursor: null, padding: 0, borderColor: "rgb(178,204,255)", borderDashArray: null, cornerColor: "rgb(178,204,255)", cornerStrokeColor: null, cornerStyle: "rect", cornerDashArray: null, centeredScaling: false, centeredRotation: true, fill: "rgb(0,0,0)", fillRule: "nonzero", globalCompositeOperation: "source-over", backgroundColor: "", selectionBackgroundColor: "", stroke: null, strokeWidth: 1, strokeDashArray: null, strokeDashOffset: 0, strokeLineCap: "butt", strokeLineJoin: "miter", strokeMiterLimit: 4, shadow: null, borderOpacityWhenMoving: 0.4, borderScaleFactor: 1, minScaleLimit: 0, selectable: true, evented: true, visible: true, hasControls: true, hasBorders: true, perPixelTargetFind: false, includeDefaultValues: true, lockMovementX: false, lockMovementY: false, lockRotation: false, lockScalingX: false, lockScalingY: false, lockSkewingX: false, lockSkewingY: false, lockScalingFlip: false, excludeFromExport: false, objectCaching: a4, statefullCache: false, noScaleCache: true, strokeUniform: false, dirty: true, __corner: 0, paintFirst: "fill", activeOn: "down", stateProperties: "top left width height scaleX scaleY flipX flipY originX originY transformMatrix stroke strokeWidth strokeDashArray strokeLineCap strokeDashOffset strokeLineJoin strokeMiterLimit angle opacity fill globalCompositeOperation shadow visible backgroundColor skewX skewY fillRule paintFirst clipPath strokeUniform".split(" "), cacheProperties: "fill stroke strokeWidth strokeDashArray width height paintFirst strokeUniform strokeLineCap strokeDashOffset strokeLineJoin strokeMiterLimit backgroundColor clipPath".split(" "), colorProperties: "fill stroke backgroundColor".split(" "), clipPath: void 0, inverted: false, absolutePositioned: false, initialize: function(t4) {
      t4 && this.setOptions(t4);
    }, _createCacheCanvas: function() {
      this._cacheProperties = {}, this._cacheCanvas = e3.util.createCanvasElement(), this._cacheContext = this._cacheCanvas.getContext("2d"), this._updateCacheCanvas(), this.dirty = true;
    }, _limitCacheSize: function(t4) {
      var i4 = e3.perfLimitSizeTotal, r5 = t4.width, n5 = t4.height, s5 = e3.maxCacheSideLimit, o5 = e3.minCacheSideLimit;
      if (r5 <= s5 && n5 <= s5 && r5 * n5 <= i4) return r5 < o5 && (t4.width = o5), n5 < o5 && (t4.height = o5), t4;
      var a5 = r5 / n5, h4 = e3.util.limitDimsByArea(a5, i4), l4 = e3.util.capValue, c4 = l4(o5, h4.x, s5), u4 = l4(o5, h4.y, s5);
      return r5 > c4 && (t4.zoomX /= r5 / c4, t4.width = c4, t4.capped = true), n5 > u4 && (t4.zoomY /= n5 / u4, t4.height = u4, t4.capped = true), t4;
    }, _getCacheCanvasDimensions: function() {
      var t4 = this.getTotalObjectScaling(), e4 = this._getTransformedDimensions(0, 0), i4 = e4.x * t4.scaleX / this.scaleX, r5 = e4.y * t4.scaleY / this.scaleY;
      return { width: i4 + 2, height: r5 + 2, zoomX: t4.scaleX, zoomY: t4.scaleY, x: i4, y: r5 };
    }, _updateCacheCanvas: function() {
      var t4 = this.canvas;
      if (this.noScaleCache && t4 && t4._currentTransform) {
        var i4 = t4._currentTransform.target, r5 = t4._currentTransform.action;
        if (this === i4 && r5.slice && "scale" === r5.slice(0, 5)) return false;
      }
      var n5, s5, o5 = this._cacheCanvas, a5 = this._limitCacheSize(this._getCacheCanvasDimensions()), h4 = e3.minCacheSideLimit, l4 = a5.width, c4 = a5.height, u4 = a5.zoomX, d4 = a5.zoomY, f4 = l4 !== this.cacheWidth || c4 !== this.cacheHeight, g4 = this.zoomX !== u4 || this.zoomY !== d4, p4 = f4 || g4, m4 = 0, v4 = 0, _4 = false;
      if (f4) {
        var y4 = this._cacheCanvas.width, b4 = this._cacheCanvas.height, w4 = l4 > y4 || c4 > b4;
        _4 = w4 || (l4 < 0.9 * y4 || c4 < 0.9 * b4) && y4 > h4 && b4 > h4, w4 && !a5.capped && (l4 > h4 || c4 > h4) && (m4 = 0.1 * l4, v4 = 0.1 * c4);
      }
      return this instanceof e3.Text && this.path && (p4 = true, _4 = true, m4 += this.getHeightOfLine(0) * this.zoomX, v4 += this.getHeightOfLine(0) * this.zoomY), !!p4 && (_4 ? (o5.width = Math.ceil(l4 + m4), o5.height = Math.ceil(c4 + v4)) : (this._cacheContext.setTransform(1, 0, 0, 1, 0, 0), this._cacheContext.clearRect(0, 0, o5.width, o5.height)), n5 = a5.x / 2, s5 = a5.y / 2, this.cacheTranslationX = Math.round(o5.width / 2 - n5) + n5, this.cacheTranslationY = Math.round(o5.height / 2 - s5) + s5, this.cacheWidth = l4, this.cacheHeight = c4, this._cacheContext.translate(this.cacheTranslationX, this.cacheTranslationY), this._cacheContext.scale(u4, d4), this.zoomX = u4, this.zoomY = d4, true);
    }, setOptions: function(t4) {
      this._setOptions(t4), this._initGradient(t4.fill, "fill"), this._initGradient(t4.stroke, "stroke"), this._initPattern(t4.fill, "fill"), this._initPattern(t4.stroke, "stroke");
    }, transform: function(t4) {
      var e4 = this.group && !this.group._transformDone || this.group && this.canvas && t4 === this.canvas.contextTop, i4 = this.calcTransformMatrix(!e4);
      t4.transform(i4[0], i4[1], i4[2], i4[3], i4[4], i4[5]);
    }, toObject: function(t4) {
      var i4 = e3.Object.NUM_FRACTION_DIGITS, r5 = { type: this.type, version: e3.version, originX: this.originX, originY: this.originY, left: n4(this.left, i4), top: n4(this.top, i4), width: n4(this.width, i4), height: n4(this.height, i4), fill: this.fill && this.fill.toObject ? this.fill.toObject() : this.fill, stroke: this.stroke && this.stroke.toObject ? this.stroke.toObject() : this.stroke, strokeWidth: n4(this.strokeWidth, i4), strokeDashArray: this.strokeDashArray ? this.strokeDashArray.concat() : this.strokeDashArray, strokeLineCap: this.strokeLineCap, strokeDashOffset: this.strokeDashOffset, strokeLineJoin: this.strokeLineJoin, strokeUniform: this.strokeUniform, strokeMiterLimit: n4(this.strokeMiterLimit, i4), scaleX: n4(this.scaleX, i4), scaleY: n4(this.scaleY, i4), angle: n4(this.angle, i4), flipX: this.flipX, flipY: this.flipY, opacity: n4(this.opacity, i4), shadow: this.shadow && this.shadow.toObject ? this.shadow.toObject() : this.shadow, visible: this.visible, backgroundColor: this.backgroundColor, fillRule: this.fillRule, paintFirst: this.paintFirst, globalCompositeOperation: this.globalCompositeOperation, skewX: n4(this.skewX, i4), skewY: n4(this.skewY, i4) };
      return this.clipPath && !this.clipPath.excludeFromExport && (r5.clipPath = this.clipPath.toObject(t4), r5.clipPath.inverted = this.clipPath.inverted, r5.clipPath.absolutePositioned = this.clipPath.absolutePositioned), e3.util.populateWithProperties(this, r5, t4), this.includeDefaultValues || (r5 = this._removeDefaultValues(r5)), r5;
    }, toDatalessObject: function(t4) {
      return this.toObject(t4);
    }, _removeDefaultValues: function(t4) {
      var i4 = e3.util.getKlass(t4.type).prototype;
      return i4.stateProperties.forEach(function(e4) {
        "left" !== e4 && "top" !== e4 && (t4[e4] === i4[e4] && delete t4[e4], Array.isArray(t4[e4]) && Array.isArray(i4[e4]) && 0 === t4[e4].length && 0 === i4[e4].length && delete t4[e4]);
      }), t4;
    }, toString: function() {
      return "#<fabric." + s4(this.type) + ">";
    }, getObjectScaling: function() {
      if (!this.group) return { scaleX: this.scaleX, scaleY: this.scaleY };
      var t4 = e3.util.qrDecompose(this.calcTransformMatrix());
      return { scaleX: Math.abs(t4.scaleX), scaleY: Math.abs(t4.scaleY) };
    }, getTotalObjectScaling: function() {
      var t4 = this.getObjectScaling(), e4 = t4.scaleX, i4 = t4.scaleY;
      if (this.canvas) {
        var r5 = this.canvas.getZoom(), n5 = this.canvas.getRetinaScaling();
        e4 *= r5 * n5, i4 *= r5 * n5;
      }
      return { scaleX: e4, scaleY: i4 };
    }, getObjectOpacity: function() {
      var t4 = this.opacity;
      return this.group && (t4 *= this.group.getObjectOpacity()), t4;
    }, _set: function(t4, i4) {
      var r5 = "scaleX" === t4 || "scaleY" === t4, n5 = this[t4] !== i4, s5 = false;
      return r5 && (i4 = this._constrainScale(i4)), "scaleX" === t4 && i4 < 0 ? (this.flipX = !this.flipX, i4 *= -1) : "scaleY" === t4 && i4 < 0 ? (this.flipY = !this.flipY, i4 *= -1) : "shadow" !== t4 || !i4 || i4 instanceof e3.Shadow ? "dirty" === t4 && this.group && this.group.set("dirty", i4) : i4 = new e3.Shadow(i4), this[t4] = i4, n5 && (s5 = this.group && this.group.isOnACache(), this.cacheProperties.indexOf(t4) > -1 ? (this.dirty = true, s5 && this.group.set("dirty", true)) : s5 && this.stateProperties.indexOf(t4) > -1 && this.group.set("dirty", true)), this;
    }, setOnGroup: function() {
    }, getViewportTransform: function() {
      return this.canvas && this.canvas.viewportTransform ? this.canvas.viewportTransform : e3.iMatrix.concat();
    }, isNotVisible: function() {
      return 0 === this.opacity || !this.width && !this.height && 0 === this.strokeWidth || !this.visible;
    }, render: function(t4) {
      this.isNotVisible() || this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen() || (t4.save(), this._setupCompositeOperation(t4), this.drawSelectionBackground(t4), this.transform(t4), this._setOpacity(t4), this._setShadow(t4, this), this.shouldCache() ? (this.renderCache(), this.drawCacheOnCanvas(t4)) : (this._removeCacheCanvas(), this.dirty = false, this.drawObject(t4), this.objectCaching && this.statefullCache && this.saveState({ propertySet: "cacheProperties" })), t4.restore());
    }, renderCache: function(t4) {
      t4 = t4 || {}, this._cacheCanvas && this._cacheContext || this._createCacheCanvas(), this.isCacheDirty() && (this.statefullCache && this.saveState({ propertySet: "cacheProperties" }), this.drawObject(this._cacheContext, t4.forClipping), this.dirty = false);
    }, _removeCacheCanvas: function() {
      this._cacheCanvas = null, this._cacheContext = null, this.cacheWidth = 0, this.cacheHeight = 0;
    }, hasStroke: function() {
      return this.stroke && "transparent" !== this.stroke && 0 !== this.strokeWidth;
    }, hasFill: function() {
      return this.fill && "transparent" !== this.fill;
    }, needsItsOwnCache: function() {
      return !("stroke" !== this.paintFirst || !this.hasFill() || !this.hasStroke() || "object" != typeof this.shadow) || !!this.clipPath;
    }, shouldCache: function() {
      return this.ownCaching = this.needsItsOwnCache() || this.objectCaching && (!this.group || !this.group.isOnACache()), this.ownCaching;
    }, willDrawShadow: function() {
      return !!this.shadow && (0 !== this.shadow.offsetX || 0 !== this.shadow.offsetY);
    }, drawClipPathOnCache: function(t4, i4) {
      if (t4.save(), i4.inverted ? t4.globalCompositeOperation = "destination-out" : t4.globalCompositeOperation = "destination-in", i4.absolutePositioned) {
        var r5 = e3.util.invertTransform(this.calcTransformMatrix());
        t4.transform(r5[0], r5[1], r5[2], r5[3], r5[4], r5[5]);
      }
      i4.transform(t4), t4.scale(1 / i4.zoomX, 1 / i4.zoomY), t4.drawImage(i4._cacheCanvas, -i4.cacheTranslationX, -i4.cacheTranslationY), t4.restore();
    }, drawObject: function(t4, e4) {
      var i4 = this.fill, r5 = this.stroke;
      e4 ? (this.fill = "black", this.stroke = "", this._setClippingProperties(t4)) : this._renderBackground(t4), this._render(t4), this._drawClipPath(t4, this.clipPath), this.fill = i4, this.stroke = r5;
    }, _drawClipPath: function(t4, e4) {
      e4 && (e4.canvas = this.canvas, e4.shouldCache(), e4._transformDone = true, e4.renderCache({ forClipping: true }), this.drawClipPathOnCache(t4, e4));
    }, drawCacheOnCanvas: function(t4) {
      t4.scale(1 / this.zoomX, 1 / this.zoomY), t4.drawImage(this._cacheCanvas, -this.cacheTranslationX, -this.cacheTranslationY);
    }, isCacheDirty: function(t4) {
      if (this.isNotVisible()) return false;
      if (this._cacheCanvas && this._cacheContext && !t4 && this._updateCacheCanvas()) return true;
      if (this.dirty || this.clipPath && this.clipPath.absolutePositioned || this.statefullCache && this.hasStateChanged("cacheProperties")) {
        if (this._cacheCanvas && this._cacheContext && !t4) {
          var e4 = this.cacheWidth / this.zoomX, i4 = this.cacheHeight / this.zoomY;
          this._cacheContext.clearRect(-e4 / 2, -i4 / 2, e4, i4);
        }
        return true;
      }
      return false;
    }, _renderBackground: function(t4) {
      if (this.backgroundColor) {
        var e4 = this._getNonTransformedDimensions();
        t4.fillStyle = this.backgroundColor, t4.fillRect(-e4.x / 2, -e4.y / 2, e4.x, e4.y), this._removeShadow(t4);
      }
    }, _setOpacity: function(t4) {
      this.group && !this.group._transformDone ? t4.globalAlpha = this.getObjectOpacity() : t4.globalAlpha *= this.opacity;
    }, _setStrokeStyles: function(t4, e4) {
      var i4 = e4.stroke;
      i4 && (t4.lineWidth = e4.strokeWidth, t4.lineCap = e4.strokeLineCap, t4.lineDashOffset = e4.strokeDashOffset, t4.lineJoin = e4.strokeLineJoin, t4.miterLimit = e4.strokeMiterLimit, i4.toLive ? "percentage" === i4.gradientUnits || i4.gradientTransform || i4.patternTransform ? this._applyPatternForTransformedGradient(t4, i4) : (t4.strokeStyle = i4.toLive(t4, this), this._applyPatternGradientTransform(t4, i4)) : t4.strokeStyle = e4.stroke);
    }, _setFillStyles: function(t4, e4) {
      var i4 = e4.fill;
      i4 && (i4.toLive ? (t4.fillStyle = i4.toLive(t4, this), this._applyPatternGradientTransform(t4, e4.fill)) : t4.fillStyle = i4);
    }, _setClippingProperties: function(t4) {
      t4.globalAlpha = 1, t4.strokeStyle = "transparent", t4.fillStyle = "#000000";
    }, _setLineDash: function(t4, e4) {
      e4 && 0 !== e4.length && (1 & e4.length && e4.push.apply(e4, e4), t4.setLineDash(e4));
    }, _renderControls: function(t4, i4) {
      var r5, n5, s5, a5 = this.getViewportTransform(), h4 = this.calcTransformMatrix();
      n5 = void 0 !== (i4 = i4 || {}).hasBorders ? i4.hasBorders : this.hasBorders, s5 = void 0 !== i4.hasControls ? i4.hasControls : this.hasControls, h4 = e3.util.multiplyTransformMatrices(a5, h4), r5 = e3.util.qrDecompose(h4), t4.save(), t4.translate(r5.translateX, r5.translateY), t4.lineWidth = 1 * this.borderScaleFactor, this.group || (t4.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1), this.flipX && (r5.angle -= 180), t4.rotate(o4(this.group ? r5.angle : this.angle)), i4.forActiveSelection || this.group ? n5 && this.drawBordersInGroup(t4, r5, i4) : n5 && this.drawBorders(t4, i4), s5 && this.drawControls(t4, i4), t4.restore();
    }, _setShadow: function(t4) {
      if (this.shadow) {
        var i4, r5 = this.shadow, n5 = this.canvas, s5 = n5 && n5.viewportTransform[0] || 1, o5 = n5 && n5.viewportTransform[3] || 1;
        i4 = r5.nonScaling ? { scaleX: 1, scaleY: 1 } : this.getObjectScaling(), n5 && n5._isRetinaScaling() && (s5 *= e3.devicePixelRatio, o5 *= e3.devicePixelRatio), t4.shadowColor = r5.color, t4.shadowBlur = r5.blur * e3.browserShadowBlurConstant * (s5 + o5) * (i4.scaleX + i4.scaleY) / 4, t4.shadowOffsetX = r5.offsetX * s5 * i4.scaleX, t4.shadowOffsetY = r5.offsetY * o5 * i4.scaleY;
      }
    }, _removeShadow: function(t4) {
      this.shadow && (t4.shadowColor = "", t4.shadowBlur = t4.shadowOffsetX = t4.shadowOffsetY = 0);
    }, _applyPatternGradientTransform: function(t4, e4) {
      if (!e4 || !e4.toLive) return { offsetX: 0, offsetY: 0 };
      var i4 = e4.gradientTransform || e4.patternTransform, r5 = -this.width / 2 + e4.offsetX || 0, n5 = -this.height / 2 + e4.offsetY || 0;
      return "percentage" === e4.gradientUnits ? t4.transform(this.width, 0, 0, this.height, r5, n5) : t4.transform(1, 0, 0, 1, r5, n5), i4 && t4.transform(i4[0], i4[1], i4[2], i4[3], i4[4], i4[5]), { offsetX: r5, offsetY: n5 };
    }, _renderPaintInOrder: function(t4) {
      "stroke" === this.paintFirst ? (this._renderStroke(t4), this._renderFill(t4)) : (this._renderFill(t4), this._renderStroke(t4));
    }, _render: function() {
    }, _renderFill: function(t4) {
      this.fill && (t4.save(), this._setFillStyles(t4, this), "evenodd" === this.fillRule ? t4.fill("evenodd") : t4.fill(), t4.restore());
    }, _renderStroke: function(t4) {
      if (this.stroke && 0 !== this.strokeWidth) {
        if (this.shadow && !this.shadow.affectStroke && this._removeShadow(t4), t4.save(), this.strokeUniform && this.group) {
          var e4 = this.getObjectScaling();
          t4.scale(1 / e4.scaleX, 1 / e4.scaleY);
        } else this.strokeUniform && t4.scale(1 / this.scaleX, 1 / this.scaleY);
        this._setLineDash(t4, this.strokeDashArray), this._setStrokeStyles(t4, this), t4.stroke(), t4.restore();
      }
    }, _applyPatternForTransformedGradient: function(t4, i4) {
      var r5, n5 = this._limitCacheSize(this._getCacheCanvasDimensions()), s5 = e3.util.createCanvasElement(), o5 = this.canvas.getRetinaScaling(), a5 = n5.x / this.scaleX / o5, h4 = n5.y / this.scaleY / o5;
      s5.width = a5, s5.height = h4, (r5 = s5.getContext("2d")).beginPath(), r5.moveTo(0, 0), r5.lineTo(a5, 0), r5.lineTo(a5, h4), r5.lineTo(0, h4), r5.closePath(), r5.translate(a5 / 2, h4 / 2), r5.scale(n5.zoomX / this.scaleX / o5, n5.zoomY / this.scaleY / o5), this._applyPatternGradientTransform(r5, i4), r5.fillStyle = i4.toLive(t4), r5.fill(), t4.translate(-this.width / 2 - this.strokeWidth / 2, -this.height / 2 - this.strokeWidth / 2), t4.scale(o5 * this.scaleX / n5.zoomX, o5 * this.scaleY / n5.zoomY), t4.strokeStyle = r5.createPattern(s5, "no-repeat");
    }, _findCenterFromElement: function() {
      return { x: this.left + this.width / 2, y: this.top + this.height / 2 };
    }, _assignTransformMatrixProps: function() {
      if (this.transformMatrix) {
        var t4 = e3.util.qrDecompose(this.transformMatrix);
        this.flipX = false, this.flipY = false, this.set("scaleX", t4.scaleX), this.set("scaleY", t4.scaleY), this.angle = t4.angle, this.skewX = t4.skewX, this.skewY = 0;
      }
    }, _removeTransformMatrix: function(t4) {
      var i4 = this._findCenterFromElement();
      this.transformMatrix && (this._assignTransformMatrixProps(), i4 = e3.util.transformPoint(i4, this.transformMatrix)), this.transformMatrix = null, t4 && (this.scaleX *= t4.scaleX, this.scaleY *= t4.scaleY, this.cropX = t4.cropX, this.cropY = t4.cropY, i4.x += t4.offsetLeft, i4.y += t4.offsetTop, this.width = t4.width, this.height = t4.height), this.setPositionByOrigin(i4, "center", "center");
    }, clone: function(t4, i4) {
      var r5 = this.toObject(i4);
      this.constructor.fromObject ? this.constructor.fromObject(r5, t4) : e3.Object._fromObject("Object", r5, t4);
    }, cloneAsImage: function(t4, i4) {
      var r5 = this.toCanvasElement(i4);
      return t4 && t4(new e3.Image(r5)), this;
    }, toCanvasElement: function(t4) {
      t4 || (t4 = {});
      var i4 = e3.util, r5 = i4.saveObjectTransform(this), n5 = this.group, s5 = this.shadow, o5 = Math.abs, a5 = (t4.multiplier || 1) * (t4.enableRetinaScaling ? e3.devicePixelRatio : 1);
      delete this.group, t4.withoutTransform && i4.resetObjectTransform(this), t4.withoutShadow && (this.shadow = null);
      var h4, l4, c4, u4, d4 = e3.util.createCanvasElement(), f4 = this.getBoundingRect(true, true), g4 = this.shadow, p4 = { x: 0, y: 0 };
      g4 && (l4 = g4.blur, h4 = g4.nonScaling ? { scaleX: 1, scaleY: 1 } : this.getObjectScaling(), p4.x = 2 * Math.round(o5(g4.offsetX) + l4) * o5(h4.scaleX), p4.y = 2 * Math.round(o5(g4.offsetY) + l4) * o5(h4.scaleY)), c4 = f4.width + p4.x, u4 = f4.height + p4.y, d4.width = Math.ceil(c4), d4.height = Math.ceil(u4);
      var m4 = new e3.StaticCanvas(d4, { enableRetinaScaling: false, renderOnAddRemove: false, skipOffscreen: false });
      "jpeg" === t4.format && (m4.backgroundColor = "#fff"), this.setPositionByOrigin(new e3.Point(m4.width / 2, m4.height / 2), "center", "center");
      var v4 = this.canvas;
      m4.add(this);
      var _4 = m4.toCanvasElement(a5 || 1, t4);
      return this.shadow = s5, this.set("canvas", v4), n5 && (this.group = n5), this.set(r5).setCoords(), m4._objects = [], m4.dispose(), m4 = null, _4;
    }, toDataURL: function(t4) {
      return t4 || (t4 = {}), e3.util.toDataURL(this.toCanvasElement(t4), t4.format || "png", t4.quality || 1);
    }, isType: function(t4) {
      return arguments.length > 1 ? Array.from(arguments).includes(this.type) : this.type === t4;
    }, complexity: function() {
      return 1;
    }, toJSON: function(t4) {
      return this.toObject(t4);
    }, rotate: function(t4) {
      var e4 = ("center" !== this.originX || "center" !== this.originY) && this.centeredRotation;
      return e4 && this._setOriginToCenter(), this.set("angle", t4), e4 && this._resetOrigin(), this;
    }, centerH: function() {
      return this.canvas && this.canvas.centerObjectH(this), this;
    }, viewportCenterH: function() {
      return this.canvas && this.canvas.viewportCenterObjectH(this), this;
    }, centerV: function() {
      return this.canvas && this.canvas.centerObjectV(this), this;
    }, viewportCenterV: function() {
      return this.canvas && this.canvas.viewportCenterObjectV(this), this;
    }, center: function() {
      return this.canvas && this.canvas.centerObject(this), this;
    }, viewportCenter: function() {
      return this.canvas && this.canvas.viewportCenterObject(this), this;
    }, getLocalPointer: function(t4, i4) {
      i4 = i4 || this.canvas.getPointer(t4);
      var r5 = new e3.Point(i4.x, i4.y), n5 = this._getLeftTopCoords();
      return this.angle && (r5 = e3.util.rotatePoint(r5, n5, o4(-this.angle))), { x: r5.x - n5.x, y: r5.y - n5.y };
    }, _setupCompositeOperation: function(t4) {
      this.globalCompositeOperation && (t4.globalCompositeOperation = this.globalCompositeOperation);
    }, dispose: function() {
      e3.runningAnimations && e3.runningAnimations.cancelByTarget(this);
    } }), e3.util.createAccessors && e3.util.createAccessors(e3.Object), i3(e3.Object.prototype, e3.Observable), e3.Object.NUM_FRACTION_DIGITS = 2, e3.Object.ENLIVEN_PROPS = ["clipPath"], e3.Object._fromObject = function(t4, i4, n5, s5) {
      var o5 = e3[t4];
      i4 = r4(i4, true), e3.util.enlivenPatterns([i4.fill, i4.stroke], function(t5) {
        void 0 !== t5[0] && (i4.fill = t5[0]), void 0 !== t5[1] && (i4.stroke = t5[1]), e3.util.enlivenObjectEnlivables(i4, i4, function() {
          var t6 = s5 ? new o5(i4[s5], i4) : new o5(i4);
          n5 && n5(t6);
        });
      });
    }, e3.Object.__uid = 0);
  }(e2), b3 = x3.util.degreesToRadians, w3 = { left: -0.5, center: 0, right: 0.5 }, C3 = { top: -0.5, center: 0, bottom: 0.5 }, x3.util.object.extend(x3.Object.prototype, { translateToGivenOrigin: function(t3, e3, i3, r4, n4) {
    var s4, o4, a4, h4 = t3.x, l4 = t3.y;
    return "string" == typeof e3 ? e3 = w3[e3] : e3 -= 0.5, "string" == typeof r4 ? r4 = w3[r4] : r4 -= 0.5, "string" == typeof i3 ? i3 = C3[i3] : i3 -= 0.5, "string" == typeof n4 ? n4 = C3[n4] : n4 -= 0.5, o4 = n4 - i3, ((s4 = r4 - e3) || o4) && (a4 = this._getTransformedDimensions(), h4 = t3.x + s4 * a4.x, l4 = t3.y + o4 * a4.y), new x3.Point(h4, l4);
  }, translateToCenterPoint: function(t3, e3, i3) {
    var r4 = this.translateToGivenOrigin(t3, e3, i3, "center", "center");
    return this.angle ? x3.util.rotatePoint(r4, t3, b3(this.angle)) : r4;
  }, translateToOriginPoint: function(t3, e3, i3) {
    var r4 = this.translateToGivenOrigin(t3, "center", "center", e3, i3);
    return this.angle ? x3.util.rotatePoint(r4, t3, b3(this.angle)) : r4;
  }, getCenterPoint: function() {
    var t3 = new x3.Point(this.left, this.top);
    return this.translateToCenterPoint(t3, this.originX, this.originY);
  }, getPointByOrigin: function(t3, e3) {
    var i3 = this.getCenterPoint();
    return this.translateToOriginPoint(i3, t3, e3);
  }, toLocalPoint: function(t3, e3, i3) {
    var r4, n4, s4 = this.getCenterPoint();
    return r4 = void 0 !== e3 && void 0 !== i3 ? this.translateToGivenOrigin(s4, "center", "center", e3, i3) : new x3.Point(this.left, this.top), n4 = new x3.Point(t3.x, t3.y), this.angle && (n4 = x3.util.rotatePoint(n4, s4, -b3(this.angle))), n4.subtractEquals(r4);
  }, setPositionByOrigin: function(t3, e3, i3) {
    var r4 = this.translateToCenterPoint(t3, e3, i3), n4 = this.translateToOriginPoint(r4, this.originX, this.originY);
    this.set("left", n4.x), this.set("top", n4.y);
  }, adjustPosition: function(t3) {
    var e3, i3, r4 = b3(this.angle), n4 = this.getScaledWidth(), s4 = x3.util.cos(r4) * n4, o4 = x3.util.sin(r4) * n4;
    e3 = "string" == typeof this.originX ? w3[this.originX] : this.originX - 0.5, i3 = "string" == typeof t3 ? w3[t3] : t3 - 0.5, this.left += s4 * (i3 - e3), this.top += o4 * (i3 - e3), this.setCoords(), this.originX = t3;
  }, _setOriginToCenter: function() {
    this._originalOriginX = this.originX, this._originalOriginY = this.originY;
    var t3 = this.getCenterPoint();
    this.originX = "center", this.originY = "center", this.left = t3.x, this.top = t3.y;
  }, _resetOrigin: function() {
    var t3 = this.translateToOriginPoint(this.getCenterPoint(), this._originalOriginX, this._originalOriginY);
    this.originX = this._originalOriginX, this.originY = this._originalOriginY, this.left = t3.x, this.top = t3.y, this._originalOriginX = null, this._originalOriginY = null;
  }, _getLeftTopCoords: function() {
    return this.translateToOriginPoint(this.getCenterPoint(), "left", "top");
  } }), function() {
    var t3 = x3.util, e3 = t3.degreesToRadians, i3 = t3.multiplyTransformMatrices, r4 = t3.transformPoint;
    t3.object.extend(x3.Object.prototype, { oCoords: null, aCoords: null, lineCoords: null, ownMatrixCache: null, matrixCache: null, controls: {}, _getCoords: function(t4, e4) {
      return e4 ? t4 ? this.calcACoords() : this.calcLineCoords() : (this.aCoords && this.lineCoords || this.setCoords(true), t4 ? this.aCoords : this.lineCoords);
    }, getCoords: function(t4, e4) {
      return i4 = this._getCoords(t4, e4), [new x3.Point(i4.tl.x, i4.tl.y), new x3.Point(i4.tr.x, i4.tr.y), new x3.Point(i4.br.x, i4.br.y), new x3.Point(i4.bl.x, i4.bl.y)];
      var i4;
    }, intersectsWithRect: function(t4, e4, i4, r5) {
      var n4 = this.getCoords(i4, r5);
      return "Intersection" === x3.Intersection.intersectPolygonRectangle(n4, t4, e4).status;
    }, intersectsWithObject: function(t4, e4, i4) {
      return "Intersection" === x3.Intersection.intersectPolygonPolygon(this.getCoords(e4, i4), t4.getCoords(e4, i4)).status || t4.isContainedWithinObject(this, e4, i4) || this.isContainedWithinObject(t4, e4, i4);
    }, isContainedWithinObject: function(t4, e4, i4) {
      for (var r5 = this.getCoords(e4, i4), n4 = e4 ? t4.aCoords : t4.lineCoords, s4 = 0, o4 = t4._getImageLines(n4); s4 < 4; s4++) if (!t4.containsPoint(r5[s4], o4)) return false;
      return true;
    }, isContainedWithinRect: function(t4, e4, i4, r5) {
      var n4 = this.getBoundingRect(i4, r5);
      return n4.left >= t4.x && n4.left + n4.width <= e4.x && n4.top >= t4.y && n4.top + n4.height <= e4.y;
    }, containsPoint: function(t4, e4, i4, r5) {
      var n4 = this._getCoords(i4, r5), s4 = (e4 = e4 || this._getImageLines(n4), this._findCrossPoints(t4, e4));
      return 0 !== s4 && s4 % 2 == 1;
    }, isOnScreen: function(t4) {
      if (!this.canvas) return false;
      var e4 = this.canvas.vptCoords.tl, i4 = this.canvas.vptCoords.br;
      return !!this.getCoords(true, t4).some(function(t5) {
        return t5.x <= i4.x && t5.x >= e4.x && t5.y <= i4.y && t5.y >= e4.y;
      }) || !!this.intersectsWithRect(e4, i4, true, t4) || this._containsCenterOfCanvas(e4, i4, t4);
    }, _containsCenterOfCanvas: function(t4, e4, i4) {
      var r5 = { x: (t4.x + e4.x) / 2, y: (t4.y + e4.y) / 2 };
      return !!this.containsPoint(r5, null, true, i4);
    }, isPartiallyOnScreen: function(t4) {
      if (!this.canvas) return false;
      var e4 = this.canvas.vptCoords.tl, i4 = this.canvas.vptCoords.br;
      return !!this.intersectsWithRect(e4, i4, true, t4) || this.getCoords(true, t4).every(function(t5) {
        return (t5.x >= i4.x || t5.x <= e4.x) && (t5.y >= i4.y || t5.y <= e4.y);
      }) && this._containsCenterOfCanvas(e4, i4, t4);
    }, _getImageLines: function(t4) {
      return { topline: { o: t4.tl, d: t4.tr }, rightline: { o: t4.tr, d: t4.br }, bottomline: { o: t4.br, d: t4.bl }, leftline: { o: t4.bl, d: t4.tl } };
    }, _findCrossPoints: function(t4, e4) {
      var i4, r5, n4, s4 = 0;
      for (var o4 in e4) if (!((n4 = e4[o4]).o.y < t4.y && n4.d.y < t4.y || n4.o.y >= t4.y && n4.d.y >= t4.y || (n4.o.x === n4.d.x && n4.o.x >= t4.x ? r5 = n4.o.x : (i4 = (n4.d.y - n4.o.y) / (n4.d.x - n4.o.x), r5 = -(t4.y - 0 * t4.x - (n4.o.y - i4 * n4.o.x)) / (0 - i4)), r5 >= t4.x && (s4 += 1), 2 !== s4))) break;
      return s4;
    }, getBoundingRect: function(e4, i4) {
      var r5 = this.getCoords(e4, i4);
      return t3.makeBoundingBoxFromPoints(r5);
    }, getScaledWidth: function() {
      return this._getTransformedDimensions().x;
    }, getScaledHeight: function() {
      return this._getTransformedDimensions().y;
    }, _constrainScale: function(t4) {
      return Math.abs(t4) < this.minScaleLimit ? t4 < 0 ? -this.minScaleLimit : this.minScaleLimit : 0 === t4 ? 1e-4 : t4;
    }, scale: function(t4) {
      return this._set("scaleX", t4), this._set("scaleY", t4), this.setCoords();
    }, scaleToWidth: function(t4, e4) {
      var i4 = this.getBoundingRect(e4).width / this.getScaledWidth();
      return this.scale(t4 / this.width / i4);
    }, scaleToHeight: function(t4, e4) {
      var i4 = this.getBoundingRect(e4).height / this.getScaledHeight();
      return this.scale(t4 / this.height / i4);
    }, calcLineCoords: function() {
      var i4 = this.getViewportTransform(), n4 = this.padding, s4 = e3(this.angle), o4 = t3.cos(s4) * n4, a4 = t3.sin(s4) * n4, h4 = o4 + a4, l4 = o4 - a4, c4 = this.calcACoords(), u4 = { tl: r4(c4.tl, i4), tr: r4(c4.tr, i4), bl: r4(c4.bl, i4), br: r4(c4.br, i4) };
      return n4 && (u4.tl.x -= l4, u4.tl.y -= h4, u4.tr.x += h4, u4.tr.y -= l4, u4.bl.x -= h4, u4.bl.y += l4, u4.br.x += l4, u4.br.y += h4), u4;
    }, calcOCoords: function() {
      var t4 = this._calcRotateMatrix(), e4 = this._calcTranslateMatrix(), r5 = this.getViewportTransform(), n4 = i3(r5, e4), s4 = i3(n4, t4), o4 = (s4 = i3(s4, [1 / r5[0], 0, 0, 1 / r5[3], 0, 0]), this._calculateCurrentDimensions()), a4 = {};
      return this.forEachControl(function(t5, e5, i4) {
        a4[e5] = t5.positionHandler(o4, s4, i4);
      }), a4;
    }, calcACoords: function() {
      var t4 = this._calcRotateMatrix(), e4 = this._calcTranslateMatrix(), n4 = i3(e4, t4), s4 = this._getTransformedDimensions(), o4 = s4.x / 2, a4 = s4.y / 2;
      return { tl: r4({ x: -o4, y: -a4 }, n4), tr: r4({ x: o4, y: -a4 }, n4), bl: r4({ x: -o4, y: a4 }, n4), br: r4({ x: o4, y: a4 }, n4) };
    }, setCoords: function(t4) {
      return this.aCoords = this.calcACoords(), this.lineCoords = this.group ? this.aCoords : this.calcLineCoords(), t4 || (this.oCoords = this.calcOCoords(), this._setCornerCoords && this._setCornerCoords()), this;
    }, _calcRotateMatrix: function() {
      return t3.calcRotateMatrix(this);
    }, _calcTranslateMatrix: function() {
      var t4 = this.getCenterPoint();
      return [1, 0, 0, 1, t4.x, t4.y];
    }, transformMatrixKey: function(t4) {
      var e4 = "_", i4 = "";
      return !t4 && this.group && (i4 = this.group.transformMatrixKey(t4) + e4), i4 + this.top + e4 + this.left + e4 + this.scaleX + e4 + this.scaleY + e4 + this.skewX + e4 + this.skewY + e4 + this.angle + e4 + this.originX + e4 + this.originY + e4 + this.width + e4 + this.height + e4 + this.strokeWidth + this.flipX + this.flipY;
    }, calcTransformMatrix: function(t4) {
      var e4 = this.calcOwnMatrix();
      if (t4 || !this.group) return e4;
      var r5 = this.transformMatrixKey(t4), n4 = this.matrixCache || (this.matrixCache = {});
      return n4.key === r5 ? n4.value : (this.group && (e4 = i3(this.group.calcTransformMatrix(false), e4)), n4.key = r5, n4.value = e4, e4);
    }, calcOwnMatrix: function() {
      var e4 = this.transformMatrixKey(true), i4 = this.ownMatrixCache || (this.ownMatrixCache = {});
      if (i4.key === e4) return i4.value;
      var r5 = this._calcTranslateMatrix(), n4 = { angle: this.angle, translateX: r5[4], translateY: r5[5], scaleX: this.scaleX, scaleY: this.scaleY, skewX: this.skewX, skewY: this.skewY, flipX: this.flipX, flipY: this.flipY };
      return i4.key = e4, i4.value = t3.composeMatrix(n4), i4.value;
    }, _getNonTransformedDimensions: function() {
      var t4 = this.strokeWidth;
      return { x: this.width + t4, y: this.height + t4 };
    }, _getTransformedDimensions: function(e4, i4) {
      void 0 === e4 && (e4 = this.skewX), void 0 === i4 && (i4 = this.skewY);
      var r5, n4, s4, o4 = 0 === e4 && 0 === i4;
      if (this.strokeUniform ? (n4 = this.width, s4 = this.height) : (n4 = (r5 = this._getNonTransformedDimensions()).x, s4 = r5.y), o4) return this._finalizeDimensions(n4 * this.scaleX, s4 * this.scaleY);
      var a4 = t3.sizeAfterTransform(n4, s4, { scaleX: this.scaleX, scaleY: this.scaleY, skewX: e4, skewY: i4 });
      return this._finalizeDimensions(a4.x, a4.y);
    }, _finalizeDimensions: function(t4, e4) {
      return this.strokeUniform ? { x: t4 + this.strokeWidth, y: e4 + this.strokeWidth } : { x: t4, y: e4 };
    }, _calculateCurrentDimensions: function() {
      var t4 = this.getViewportTransform(), e4 = this._getTransformedDimensions();
      return r4(e4, t4, true).scalarAdd(2 * this.padding);
    } });
  }(), x3.util.object.extend(x3.Object.prototype, { sendToBack: function() {
    return this.group ? x3.StaticCanvas.prototype.sendToBack.call(this.group, this) : this.canvas && this.canvas.sendToBack(this), this;
  }, bringToFront: function() {
    return this.group ? x3.StaticCanvas.prototype.bringToFront.call(this.group, this) : this.canvas && this.canvas.bringToFront(this), this;
  }, sendBackwards: function(t3) {
    return this.group ? x3.StaticCanvas.prototype.sendBackwards.call(this.group, this, t3) : this.canvas && this.canvas.sendBackwards(this, t3), this;
  }, bringForward: function(t3) {
    return this.group ? x3.StaticCanvas.prototype.bringForward.call(this.group, this, t3) : this.canvas && this.canvas.bringForward(this, t3), this;
  }, moveTo: function(t3) {
    return this.group && "activeSelection" !== this.group.type ? x3.StaticCanvas.prototype.moveTo.call(this.group, this, t3) : this.canvas && this.canvas.moveTo(this, t3), this;
  } }), function() {
    function t3(t4, e4) {
      if (e4) {
        if (e4.toLive) return t4 + ": url(#SVGID_" + e4.id + "); ";
        var i3 = new x3.Color(e4), r4 = t4 + ": " + i3.toRgb() + "; ", n4 = i3.getAlpha();
        return 1 !== n4 && (r4 += t4 + "-opacity: " + n4.toString() + "; "), r4;
      }
      return t4 + ": none; ";
    }
    var e3 = x3.util.toFixed;
    x3.util.object.extend(x3.Object.prototype, { getSvgStyles: function(e4) {
      var i3 = this.fillRule ? this.fillRule : "nonzero", r4 = this.strokeWidth ? this.strokeWidth : "0", n4 = this.strokeDashArray ? this.strokeDashArray.join(" ") : "none", s4 = this.strokeDashOffset ? this.strokeDashOffset : "0", o4 = this.strokeLineCap ? this.strokeLineCap : "butt", a4 = this.strokeLineJoin ? this.strokeLineJoin : "miter", h4 = this.strokeMiterLimit ? this.strokeMiterLimit : "4", l4 = void 0 !== this.opacity ? this.opacity : "1", c4 = this.visible ? "" : " visibility: hidden;", u4 = e4 ? "" : this.getSvgFilter(), d4 = t3("fill", this.fill);
      return [t3("stroke", this.stroke), "stroke-width: ", r4, "; ", "stroke-dasharray: ", n4, "; ", "stroke-linecap: ", o4, "; ", "stroke-dashoffset: ", s4, "; ", "stroke-linejoin: ", a4, "; ", "stroke-miterlimit: ", h4, "; ", d4, "fill-rule: ", i3, "; ", "opacity: ", l4, ";", u4, c4].join("");
    }, getSvgSpanStyles: function(e4, i3) {
      var r4 = "; ", n4 = e4.fontFamily ? "font-family: " + (-1 === e4.fontFamily.indexOf("'") && -1 === e4.fontFamily.indexOf('"') ? "'" + e4.fontFamily + "'" : e4.fontFamily) + r4 : "", s4 = e4.strokeWidth ? "stroke-width: " + e4.strokeWidth + r4 : "", o4 = e4.fontSize ? "font-size: " + e4.fontSize + "px" + r4 : "", a4 = e4.fontStyle ? "font-style: " + e4.fontStyle + r4 : "", h4 = e4.fontWeight ? "font-weight: " + e4.fontWeight + r4 : "", l4 = e4.fill ? t3("fill", e4.fill) : "", c4 = e4.stroke ? t3("stroke", e4.stroke) : "", u4 = this.getSvgTextDecoration(e4);
      return u4 && (u4 = "text-decoration: " + u4 + r4), [c4, s4, n4, o4, a4, h4, u4, l4, e4.deltaY ? "baseline-shift: " + -e4.deltaY + "; " : "", i3 ? "white-space: pre; " : ""].join("");
    }, getSvgTextDecoration: function(t4) {
      return ["overline", "underline", "line-through"].filter(function(e4) {
        return t4[e4.replace("-", "")];
      }).join(" ");
    }, getSvgFilter: function() {
      return this.shadow ? "filter: url(#SVGID_" + this.shadow.id + ");" : "";
    }, getSvgCommons: function() {
      return [this.id ? 'id="' + this.id + '" ' : "", this.clipPath ? 'clip-path="url(#' + this.clipPath.clipPathId + ')" ' : ""].join("");
    }, getSvgTransform: function(t4, e4) {
      var i3 = t4 ? this.calcTransformMatrix() : this.calcOwnMatrix();
      return 'transform="' + x3.util.matrixToSVG(i3) + (e4 || "") + '" ';
    }, _setSVGBg: function(t4) {
      if (this.backgroundColor) {
        var i3 = x3.Object.NUM_FRACTION_DIGITS;
        t4.push("		<rect ", this._getFillAttributes(this.backgroundColor), ' x="', e3(-this.width / 2, i3), '" y="', e3(-this.height / 2, i3), '" width="', e3(this.width, i3), '" height="', e3(this.height, i3), '"></rect>\n');
      }
    }, toSVG: function(t4) {
      return this._createBaseSVGMarkup(this._toSVG(t4), { reviver: t4 });
    }, toClipPathSVG: function(t4) {
      return "	" + this._createBaseClipPathSVGMarkup(this._toSVG(t4), { reviver: t4 });
    }, _createBaseClipPathSVGMarkup: function(t4, e4) {
      var i3 = (e4 = e4 || {}).reviver, r4 = e4.additionalTransform || "", n4 = [this.getSvgTransform(true, r4), this.getSvgCommons()].join(""), s4 = t4.indexOf("COMMON_PARTS");
      return t4[s4] = n4, i3 ? i3(t4.join("")) : t4.join("");
    }, _createBaseSVGMarkup: function(t4, e4) {
      var i3, r4, n4 = (e4 = e4 || {}).noStyle, s4 = e4.reviver, o4 = n4 ? "" : 'style="' + this.getSvgStyles() + '" ', a4 = e4.withShadow ? 'style="' + this.getSvgFilter() + '" ' : "", h4 = this.clipPath, l4 = this.strokeUniform ? 'vector-effect="non-scaling-stroke" ' : "", c4 = h4 && h4.absolutePositioned, u4 = this.stroke, d4 = this.fill, f4 = this.shadow, g4 = [], p4 = t4.indexOf("COMMON_PARTS"), m4 = e4.additionalTransform;
      return h4 && (h4.clipPathId = "CLIPPATH_" + x3.Object.__uid++, r4 = '<clipPath id="' + h4.clipPathId + '" >\n' + h4.toClipPathSVG(s4) + "</clipPath>\n"), c4 && g4.push("<g ", a4, this.getSvgCommons(), " >\n"), g4.push("<g ", this.getSvgTransform(false), c4 ? "" : a4 + this.getSvgCommons(), " >\n"), i3 = [o4, l4, n4 ? "" : this.addPaintOrder(), " ", m4 ? 'transform="' + m4 + '" ' : ""].join(""), t4[p4] = i3, d4 && d4.toLive && g4.push(d4.toSVG(this)), u4 && u4.toLive && g4.push(u4.toSVG(this)), f4 && g4.push(f4.toSVG(this)), h4 && g4.push(r4), g4.push(t4.join("")), g4.push("</g>\n"), c4 && g4.push("</g>\n"), s4 ? s4(g4.join("")) : g4.join("");
    }, addPaintOrder: function() {
      return "fill" !== this.paintFirst ? ' paint-order="' + this.paintFirst + '" ' : "";
    } });
  }(), function() {
    var t3 = x3.util.object.extend, e3 = "stateProperties";
    function i3(e4, i4, r5) {
      var n4 = {};
      r5.forEach(function(t4) {
        n4[t4] = e4[t4];
      }), t3(e4[i4], n4, true);
    }
    function r4(t4, e4, i4) {
      if (t4 === e4) return true;
      if (Array.isArray(t4)) {
        if (!Array.isArray(e4) || t4.length !== e4.length) return false;
        for (var n4 = 0, s4 = t4.length; n4 < s4; n4++) if (!r4(t4[n4], e4[n4])) return false;
        return true;
      }
      if (t4 && "object" == typeof t4) {
        var o4, a4 = Object.keys(t4);
        if (!e4 || "object" != typeof e4 || !i4 && a4.length !== Object.keys(e4).length) return false;
        for (n4 = 0, s4 = a4.length; n4 < s4; n4++) if ("canvas" !== (o4 = a4[n4]) && "group" !== o4 && !r4(t4[o4], e4[o4])) return false;
        return true;
      }
    }
    x3.util.object.extend(x3.Object.prototype, { hasStateChanged: function(t4) {
      var i4 = "_" + (t4 = t4 || e3);
      return Object.keys(this[i4]).length < this[t4].length || !r4(this[i4], this, true);
    }, saveState: function(t4) {
      var r5 = t4 && t4.propertySet || e3, n4 = "_" + r5;
      return this[n4] ? (i3(this, n4, this[r5]), t4 && t4.stateProperties && i3(this, n4, t4.stateProperties), this) : this.setupState(t4);
    }, setupState: function(t4) {
      var i4 = (t4 = t4 || {}).propertySet || e3;
      return t4.propertySet = i4, this["_" + i4] = {}, this.saveState(t4), this;
    } });
  }(), function() {
    var t3 = x3.util.degreesToRadians;
    x3.util.object.extend(x3.Object.prototype, { _findTargetCorner: function(t4, e3) {
      if (!this.hasControls || this.group || !this.canvas || this.canvas._activeObject !== this) return false;
      var i3, r4, n4, s4 = t4.x, o4 = t4.y, a4 = Object.keys(this.oCoords), h4 = a4.length - 1;
      for (this.__corner = 0; h4 >= 0; h4--) if (n4 = a4[h4], this.isControlVisible(n4) && (r4 = this._getImageLines(e3 ? this.oCoords[n4].touchCorner : this.oCoords[n4].corner), 0 !== (i3 = this._findCrossPoints({ x: s4, y: o4 }, r4)) && i3 % 2 == 1)) return this.__corner = n4, n4;
      return false;
    }, forEachControl: function(t4) {
      for (var e3 in this.controls) t4(this.controls[e3], e3, this);
    }, _setCornerCoords: function() {
      var t4 = this.oCoords;
      for (var e3 in t4) {
        var i3 = this.controls[e3];
        t4[e3].corner = i3.calcCornerCoords(this.angle, this.cornerSize, t4[e3].x, t4[e3].y, false), t4[e3].touchCorner = i3.calcCornerCoords(this.angle, this.touchCornerSize, t4[e3].x, t4[e3].y, true);
      }
    }, drawSelectionBackground: function(e3) {
      if (!this.selectionBackgroundColor || this.canvas && !this.canvas.interactive || this.canvas && this.canvas._activeObject !== this) return this;
      e3.save();
      var i3 = this.getCenterPoint(), r4 = this._calculateCurrentDimensions(), n4 = this.canvas.viewportTransform;
      return e3.translate(i3.x, i3.y), e3.scale(1 / n4[0], 1 / n4[3]), e3.rotate(t3(this.angle)), e3.fillStyle = this.selectionBackgroundColor, e3.fillRect(-r4.x / 2, -r4.y / 2, r4.x, r4.y), e3.restore(), this;
    }, drawBorders: function(t4, e3) {
      e3 = e3 || {};
      var i3 = this._calculateCurrentDimensions(), r4 = this.borderScaleFactor, n4 = i3.x + r4, s4 = i3.y + r4, o4 = void 0 !== e3.hasControls ? e3.hasControls : this.hasControls, a4 = false;
      return t4.save(), t4.strokeStyle = e3.borderColor || this.borderColor, this._setLineDash(t4, e3.borderDashArray || this.borderDashArray), t4.strokeRect(-n4 / 2, -s4 / 2, n4, s4), o4 && (t4.beginPath(), this.forEachControl(function(e4, i4, r5) {
        e4.withConnection && e4.getVisibility(r5, i4) && (a4 = true, t4.moveTo(e4.x * n4, e4.y * s4), t4.lineTo(e4.x * n4 + e4.offsetX, e4.y * s4 + e4.offsetY));
      }), a4 && t4.stroke()), t4.restore(), this;
    }, drawBordersInGroup: function(t4, e3, i3) {
      i3 = i3 || {};
      var r4 = x3.util.sizeAfterTransform(this.width, this.height, e3), n4 = this.strokeWidth, s4 = this.strokeUniform, o4 = this.borderScaleFactor, a4 = r4.x + n4 * (s4 ? this.canvas.getZoom() : e3.scaleX) + o4, h4 = r4.y + n4 * (s4 ? this.canvas.getZoom() : e3.scaleY) + o4;
      return t4.save(), this._setLineDash(t4, i3.borderDashArray || this.borderDashArray), t4.strokeStyle = i3.borderColor || this.borderColor, t4.strokeRect(-a4 / 2, -h4 / 2, a4, h4), t4.restore(), this;
    }, drawControls: function(t4, e3) {
      e3 = e3 || {}, t4.save();
      var i3, r4, n4 = this.canvas.getRetinaScaling();
      return t4.setTransform(n4, 0, 0, n4, 0, 0), t4.strokeStyle = t4.fillStyle = e3.cornerColor || this.cornerColor, this.transparentCorners || (t4.strokeStyle = e3.cornerStrokeColor || this.cornerStrokeColor), this._setLineDash(t4, e3.cornerDashArray || this.cornerDashArray), this.setCoords(), this.group && (i3 = this.group.calcTransformMatrix()), this.forEachControl(function(n5, s4, o4) {
        r4 = o4.oCoords[s4], n5.getVisibility(o4, s4) && (i3 && (r4 = x3.util.transformPoint(r4, i3)), n5.render(t4, r4.x, r4.y, e3, o4));
      }), t4.restore(), this;
    }, isControlVisible: function(t4) {
      return this.controls[t4] && this.controls[t4].getVisibility(this, t4);
    }, setControlVisible: function(t4, e3) {
      return this._controlsVisibility || (this._controlsVisibility = {}), this._controlsVisibility[t4] = e3, this;
    }, setControlsVisibility: function(t4) {
      for (var e3 in t4 || (t4 = {}), t4) this.setControlVisible(e3, t4[e3]);
      return this;
    }, onDeselect: function() {
    }, onSelect: function() {
    } });
  }(), x3.util.object.extend(x3.StaticCanvas.prototype, { FX_DURATION: 500, fxCenterObjectH: function(t3, e3) {
    var i3 = function() {
    }, r4 = (e3 = e3 || {}).onComplete || i3, n4 = e3.onChange || i3, s4 = this;
    return x3.util.animate({ target: this, startValue: t3.left, endValue: this.getCenterPoint().x, duration: this.FX_DURATION, onChange: function(e4) {
      t3.set("left", e4), s4.requestRenderAll(), n4();
    }, onComplete: function() {
      t3.setCoords(), r4();
    } });
  }, fxCenterObjectV: function(t3, e3) {
    var i3 = function() {
    }, r4 = (e3 = e3 || {}).onComplete || i3, n4 = e3.onChange || i3, s4 = this;
    return x3.util.animate({ target: this, startValue: t3.top, endValue: this.getCenterPoint().y, duration: this.FX_DURATION, onChange: function(e4) {
      t3.set("top", e4), s4.requestRenderAll(), n4();
    }, onComplete: function() {
      t3.setCoords(), r4();
    } });
  }, fxRemove: function(t3, e3) {
    var i3 = function() {
    }, r4 = (e3 = e3 || {}).onComplete || i3, n4 = e3.onChange || i3, s4 = this;
    return x3.util.animate({ target: this, startValue: t3.opacity, endValue: 0, duration: this.FX_DURATION, onChange: function(e4) {
      t3.set("opacity", e4), s4.requestRenderAll(), n4();
    }, onComplete: function() {
      s4.remove(t3), r4();
    } });
  } }), x3.util.object.extend(x3.Object.prototype, { animate: function() {
    if (arguments[0] && "object" == typeof arguments[0]) {
      var t3, e3, i3 = [], r4 = [];
      for (t3 in arguments[0]) i3.push(t3);
      for (var n4 = 0, s4 = i3.length; n4 < s4; n4++) t3 = i3[n4], e3 = n4 !== s4 - 1, r4.push(this._animate(t3, arguments[0][t3], arguments[1], e3));
      return r4;
    }
    return this._animate.apply(this, arguments);
  }, _animate: function(t3, e3, i3, r4) {
    var n4, s4 = this;
    e3 = e3.toString(), i3 = i3 ? x3.util.object.clone(i3) : {}, ~t3.indexOf(".") && (n4 = t3.split("."));
    var o4 = s4.colorProperties.indexOf(t3) > -1 || n4 && s4.colorProperties.indexOf(n4[1]) > -1, a4 = n4 ? this.get(n4[0])[n4[1]] : this.get(t3);
    "from" in i3 || (i3.from = a4), o4 || (e3 = ~e3.indexOf("=") ? a4 + parseFloat(e3.replace("=", "")) : parseFloat(e3));
    var h4 = { target: this, startValue: i3.from, endValue: e3, byValue: i3.by, easing: i3.easing, duration: i3.duration, abort: i3.abort && function(t4, e4, r5) {
      return i3.abort.call(s4, t4, e4, r5);
    }, onChange: function(e4, o5, a5) {
      n4 ? s4[n4[0]][n4[1]] = e4 : s4.set(t3, e4), r4 || i3.onChange && i3.onChange(e4, o5, a5);
    }, onComplete: function(t4, e4, n5) {
      r4 || (s4.setCoords(), i3.onComplete && i3.onComplete(t4, e4, n5));
    } };
    return o4 ? x3.util.animateColor(h4.startValue, h4.endValue, h4.duration, h4) : x3.util.animate(h4);
  } }), function(t3) {
    var e3 = t3.fabric || (t3.fabric = {}), i3 = e3.util.object.extend, r4 = e3.util.object.clone, n4 = { x1: 1, x2: 1, y1: 1, y2: 1 };
    function s4(t4, e4) {
      var i4 = t4.origin, r5 = t4.axis1, n5 = t4.axis2, s5 = t4.dimension, o4 = e4.nearest, a4 = e4.center, h4 = e4.farthest;
      return function() {
        switch (this.get(i4)) {
          case o4:
            return Math.min(this.get(r5), this.get(n5));
          case a4:
            return Math.min(this.get(r5), this.get(n5)) + 0.5 * this.get(s5);
          case h4:
            return Math.max(this.get(r5), this.get(n5));
        }
      };
    }
    e3.Line ? e3.warn("fabric.Line is already defined") : (e3.Line = e3.util.createClass(e3.Object, { type: "line", x1: 0, y1: 0, x2: 0, y2: 0, cacheProperties: e3.Object.prototype.cacheProperties.concat("x1", "x2", "y1", "y2"), initialize: function(t4, e4) {
      t4 || (t4 = [0, 0, 0, 0]), this.callSuper("initialize", e4), this.set("x1", t4[0]), this.set("y1", t4[1]), this.set("x2", t4[2]), this.set("y2", t4[3]), this._setWidthHeight(e4);
    }, _setWidthHeight: function(t4) {
      t4 || (t4 = {}), this.width = Math.abs(this.x2 - this.x1), this.height = Math.abs(this.y2 - this.y1), this.left = "left" in t4 ? t4.left : this._getLeftToOriginX(), this.top = "top" in t4 ? t4.top : this._getTopToOriginY();
    }, _set: function(t4, e4) {
      return this.callSuper("_set", t4, e4), void 0 !== n4[t4] && this._setWidthHeight(), this;
    }, _getLeftToOriginX: s4({ origin: "originX", axis1: "x1", axis2: "x2", dimension: "width" }, { nearest: "left", center: "center", farthest: "right" }), _getTopToOriginY: s4({ origin: "originY", axis1: "y1", axis2: "y2", dimension: "height" }, { nearest: "top", center: "center", farthest: "bottom" }), _render: function(t4) {
      t4.beginPath();
      var e4 = this.calcLinePoints();
      t4.moveTo(e4.x1, e4.y1), t4.lineTo(e4.x2, e4.y2), t4.lineWidth = this.strokeWidth;
      var i4 = t4.strokeStyle;
      t4.strokeStyle = this.stroke || t4.fillStyle, this.stroke && this._renderStroke(t4), t4.strokeStyle = i4;
    }, _findCenterFromElement: function() {
      return { x: (this.x1 + this.x2) / 2, y: (this.y1 + this.y2) / 2 };
    }, toObject: function(t4) {
      return i3(this.callSuper("toObject", t4), this.calcLinePoints());
    }, _getNonTransformedDimensions: function() {
      var t4 = this.callSuper("_getNonTransformedDimensions");
      return "butt" === this.strokeLineCap && (0 === this.width && (t4.y -= this.strokeWidth), 0 === this.height && (t4.x -= this.strokeWidth)), t4;
    }, calcLinePoints: function() {
      var t4 = this.x1 <= this.x2 ? -1 : 1, e4 = this.y1 <= this.y2 ? -1 : 1, i4 = t4 * this.width * 0.5, r5 = e4 * this.height * 0.5;
      return { x1: i4, x2: t4 * this.width * -0.5, y1: r5, y2: e4 * this.height * -0.5 };
    }, _toSVG: function() {
      var t4 = this.calcLinePoints();
      return ["<line ", "COMMON_PARTS", 'x1="', t4.x1, '" y1="', t4.y1, '" x2="', t4.x2, '" y2="', t4.y2, '" />\n'];
    } }), e3.Line.ATTRIBUTE_NAMES = e3.SHARED_ATTRIBUTES.concat("x1 y1 x2 y2".split(" ")), e3.Line.fromElement = function(t4, r5, n5) {
      n5 = n5 || {};
      var s5 = e3.parseAttributes(t4, e3.Line.ATTRIBUTE_NAMES), o4 = [s5.x1 || 0, s5.y1 || 0, s5.x2 || 0, s5.y2 || 0];
      r5(new e3.Line(o4, i3(s5, n5)));
    }, e3.Line.fromObject = function(t4, i4) {
      var n5 = r4(t4, true);
      n5.points = [t4.x1, t4.y1, t4.x2, t4.y2], e3.Object._fromObject("Line", n5, function(t5) {
        delete t5.points, i4 && i4(t5);
      }, "points");
    });
  }(e2), function(t3) {
    var e3 = t3.fabric || (t3.fabric = {}), i3 = e3.util.degreesToRadians;
    e3.Circle ? e3.warn("fabric.Circle is already defined.") : (e3.Circle = e3.util.createClass(e3.Object, { type: "circle", radius: 0, startAngle: 0, endAngle: 360, cacheProperties: e3.Object.prototype.cacheProperties.concat("radius", "startAngle", "endAngle"), _set: function(t4, e4) {
      return this.callSuper("_set", t4, e4), "radius" === t4 && this.setRadius(e4), this;
    }, toObject: function(t4) {
      return this.callSuper("toObject", ["radius", "startAngle", "endAngle"].concat(t4));
    }, _toSVG: function() {
      var t4, r4 = (this.endAngle - this.startAngle) % 360;
      if (0 === r4) t4 = ["<circle ", "COMMON_PARTS", 'cx="0" cy="0" ', 'r="', this.radius, '" />\n'];
      else {
        var n4 = i3(this.startAngle), s4 = i3(this.endAngle), o4 = this.radius;
        t4 = ['<path d="M ' + e3.util.cos(n4) * o4 + " " + e3.util.sin(n4) * o4, " A " + o4 + " " + o4, " 0 ", +(r4 > 180 ? "1" : "0") + " 1", " " + e3.util.cos(s4) * o4 + " " + e3.util.sin(s4) * o4, '" ', "COMMON_PARTS", " />\n"];
      }
      return t4;
    }, _render: function(t4) {
      t4.beginPath(), t4.arc(0, 0, this.radius, i3(this.startAngle), i3(this.endAngle), false), this._renderPaintInOrder(t4);
    }, getRadiusX: function() {
      return this.get("radius") * this.get("scaleX");
    }, getRadiusY: function() {
      return this.get("radius") * this.get("scaleY");
    }, setRadius: function(t4) {
      return this.radius = t4, this.set("width", 2 * t4).set("height", 2 * t4);
    } }), e3.Circle.ATTRIBUTE_NAMES = e3.SHARED_ATTRIBUTES.concat("cx cy r".split(" ")), e3.Circle.fromElement = function(t4, i4) {
      var r4, n4 = e3.parseAttributes(t4, e3.Circle.ATTRIBUTE_NAMES);
      if (!("radius" in (r4 = n4) && r4.radius >= 0)) throw new Error("value of `r` attribute is required and can not be negative");
      n4.left = (n4.left || 0) - n4.radius, n4.top = (n4.top || 0) - n4.radius, i4(new e3.Circle(n4));
    }, e3.Circle.fromObject = function(t4, i4) {
      e3.Object._fromObject("Circle", t4, i4);
    });
  }(e2), function(t3) {
    var e3 = t3.fabric || (t3.fabric = {});
    e3.Triangle ? e3.warn("fabric.Triangle is already defined") : (e3.Triangle = e3.util.createClass(e3.Object, { type: "triangle", width: 100, height: 100, _render: function(t4) {
      var e4 = this.width / 2, i3 = this.height / 2;
      t4.beginPath(), t4.moveTo(-e4, i3), t4.lineTo(0, -i3), t4.lineTo(e4, i3), t4.closePath(), this._renderPaintInOrder(t4);
    }, _toSVG: function() {
      var t4 = this.width / 2, e4 = this.height / 2;
      return ["<polygon ", "COMMON_PARTS", 'points="', [-t4 + " " + e4, "0 " + -e4, t4 + " " + e4].join(","), '" />'];
    } }), e3.Triangle.fromObject = function(t4, i3) {
      return e3.Object._fromObject("Triangle", t4, i3);
    });
  }(e2), function(t3) {
    var e3 = t3.fabric || (t3.fabric = {}), i3 = 2 * Math.PI;
    e3.Ellipse ? e3.warn("fabric.Ellipse is already defined.") : (e3.Ellipse = e3.util.createClass(e3.Object, { type: "ellipse", rx: 0, ry: 0, cacheProperties: e3.Object.prototype.cacheProperties.concat("rx", "ry"), initialize: function(t4) {
      this.callSuper("initialize", t4), this.set("rx", t4 && t4.rx || 0), this.set("ry", t4 && t4.ry || 0);
    }, _set: function(t4, e4) {
      switch (this.callSuper("_set", t4, e4), t4) {
        case "rx":
          this.rx = e4, this.set("width", 2 * e4);
          break;
        case "ry":
          this.ry = e4, this.set("height", 2 * e4);
      }
      return this;
    }, getRx: function() {
      return this.get("rx") * this.get("scaleX");
    }, getRy: function() {
      return this.get("ry") * this.get("scaleY");
    }, toObject: function(t4) {
      return this.callSuper("toObject", ["rx", "ry"].concat(t4));
    }, _toSVG: function() {
      return ["<ellipse ", "COMMON_PARTS", 'cx="0" cy="0" ', 'rx="', this.rx, '" ry="', this.ry, '" />\n'];
    }, _render: function(t4) {
      t4.beginPath(), t4.save(), t4.transform(1, 0, 0, this.ry / this.rx, 0, 0), t4.arc(0, 0, this.rx, 0, i3, false), t4.restore(), this._renderPaintInOrder(t4);
    } }), e3.Ellipse.ATTRIBUTE_NAMES = e3.SHARED_ATTRIBUTES.concat("cx cy rx ry".split(" ")), e3.Ellipse.fromElement = function(t4, i4) {
      var r4 = e3.parseAttributes(t4, e3.Ellipse.ATTRIBUTE_NAMES);
      r4.left = (r4.left || 0) - r4.rx, r4.top = (r4.top || 0) - r4.ry, i4(new e3.Ellipse(r4));
    }, e3.Ellipse.fromObject = function(t4, i4) {
      e3.Object._fromObject("Ellipse", t4, i4);
    });
  }(e2), function(t3) {
    var e3 = t3.fabric || (t3.fabric = {}), i3 = e3.util.object.extend;
    e3.Rect ? e3.warn("fabric.Rect is already defined") : (e3.Rect = e3.util.createClass(e3.Object, { stateProperties: e3.Object.prototype.stateProperties.concat("rx", "ry"), type: "rect", rx: 0, ry: 0, cacheProperties: e3.Object.prototype.cacheProperties.concat("rx", "ry"), initialize: function(t4) {
      this.callSuper("initialize", t4), this._initRxRy();
    }, _initRxRy: function() {
      this.rx && !this.ry ? this.ry = this.rx : this.ry && !this.rx && (this.rx = this.ry);
    }, _render: function(t4) {
      var e4 = this.rx ? Math.min(this.rx, this.width / 2) : 0, i4 = this.ry ? Math.min(this.ry, this.height / 2) : 0, r4 = this.width, n4 = this.height, s4 = -this.width / 2, o4 = -this.height / 2, a4 = 0 !== e4 || 0 !== i4, h4 = 0.4477152502;
      t4.beginPath(), t4.moveTo(s4 + e4, o4), t4.lineTo(s4 + r4 - e4, o4), a4 && t4.bezierCurveTo(s4 + r4 - h4 * e4, o4, s4 + r4, o4 + h4 * i4, s4 + r4, o4 + i4), t4.lineTo(s4 + r4, o4 + n4 - i4), a4 && t4.bezierCurveTo(s4 + r4, o4 + n4 - h4 * i4, s4 + r4 - h4 * e4, o4 + n4, s4 + r4 - e4, o4 + n4), t4.lineTo(s4 + e4, o4 + n4), a4 && t4.bezierCurveTo(s4 + h4 * e4, o4 + n4, s4, o4 + n4 - h4 * i4, s4, o4 + n4 - i4), t4.lineTo(s4, o4 + i4), a4 && t4.bezierCurveTo(s4, o4 + h4 * i4, s4 + h4 * e4, o4, s4 + e4, o4), t4.closePath(), this._renderPaintInOrder(t4);
    }, toObject: function(t4) {
      return this.callSuper("toObject", ["rx", "ry"].concat(t4));
    }, _toSVG: function() {
      return ["<rect ", "COMMON_PARTS", 'x="', -this.width / 2, '" y="', -this.height / 2, '" rx="', this.rx, '" ry="', this.ry, '" width="', this.width, '" height="', this.height, '" />\n'];
    } }), e3.Rect.ATTRIBUTE_NAMES = e3.SHARED_ATTRIBUTES.concat("x y rx ry width height".split(" ")), e3.Rect.fromElement = function(t4, r4, n4) {
      if (!t4) return r4(null);
      n4 = n4 || {};
      var s4 = e3.parseAttributes(t4, e3.Rect.ATTRIBUTE_NAMES);
      s4.left = s4.left || 0, s4.top = s4.top || 0, s4.height = s4.height || 0, s4.width = s4.width || 0;
      var o4 = new e3.Rect(i3(n4 ? e3.util.object.clone(n4) : {}, s4));
      o4.visible = o4.visible && o4.width > 0 && o4.height > 0, r4(o4);
    }, e3.Rect.fromObject = function(t4, i4) {
      return e3.Object._fromObject("Rect", t4, i4);
    });
  }(e2), function(t3) {
    var e3 = t3.fabric || (t3.fabric = {}), i3 = e3.util.object.extend, r4 = e3.util.array.min, n4 = e3.util.array.max, s4 = e3.util.toFixed, o4 = e3.util.projectStrokeOnPoints;
    e3.Polyline ? e3.warn("fabric.Polyline is already defined") : (e3.Polyline = e3.util.createClass(e3.Object, { type: "polyline", points: null, exactBoundingBox: false, cacheProperties: e3.Object.prototype.cacheProperties.concat("points"), initialize: function(t4, e4) {
      e4 = e4 || {}, this.points = t4 || [], this.callSuper("initialize", e4), this._setPositionDimensions(e4);
    }, _projectStrokeOnPoints: function() {
      return o4(this.points, this, true);
    }, _setPositionDimensions: function(t4) {
      var e4, i4 = this._calcDimensions(t4), r5 = this.exactBoundingBox ? this.strokeWidth : 0;
      this.width = i4.width - r5, this.height = i4.height - r5, t4.fromSVG || (e4 = this.translateToGivenOrigin({ x: i4.left - this.strokeWidth / 2 + r5 / 2, y: i4.top - this.strokeWidth / 2 + r5 / 2 }, "left", "top", this.originX, this.originY)), void 0 === t4.left && (this.left = t4.fromSVG ? i4.left : e4.x), void 0 === t4.top && (this.top = t4.fromSVG ? i4.top : e4.y), this.pathOffset = { x: i4.left + this.width / 2 + r5 / 2, y: i4.top + this.height / 2 + r5 / 2 };
    }, _calcDimensions: function() {
      var t4 = this.exactBoundingBox ? this._projectStrokeOnPoints() : this.points, e4 = r4(t4, "x") || 0, i4 = r4(t4, "y") || 0;
      return { left: e4, top: i4, width: (n4(t4, "x") || 0) - e4, height: (n4(t4, "y") || 0) - i4 };
    }, toObject: function(t4) {
      return i3(this.callSuper("toObject", t4), { points: this.points.concat() });
    }, _toSVG: function() {
      for (var t4 = [], i4 = this.pathOffset.x, r5 = this.pathOffset.y, n5 = e3.Object.NUM_FRACTION_DIGITS, o5 = 0, a4 = this.points.length; o5 < a4; o5++) t4.push(s4(this.points[o5].x - i4, n5), ",", s4(this.points[o5].y - r5, n5), " ");
      return ["<" + this.type + " ", "COMMON_PARTS", 'points="', t4.join(""), '" />\n'];
    }, commonRender: function(t4) {
      var e4, i4 = this.points.length, r5 = this.pathOffset.x, n5 = this.pathOffset.y;
      if (!i4 || isNaN(this.points[i4 - 1].y)) return false;
      t4.beginPath(), t4.moveTo(this.points[0].x - r5, this.points[0].y - n5);
      for (var s5 = 0; s5 < i4; s5++) e4 = this.points[s5], t4.lineTo(e4.x - r5, e4.y - n5);
      return true;
    }, _render: function(t4) {
      this.commonRender(t4) && this._renderPaintInOrder(t4);
    }, complexity: function() {
      return this.get("points").length;
    } }), e3.Polyline.ATTRIBUTE_NAMES = e3.SHARED_ATTRIBUTES.concat(), e3.Polyline.fromElementGenerator = function(t4) {
      return function(r5, n5, s5) {
        if (!r5) return n5(null);
        s5 || (s5 = {});
        var o5 = e3.parsePointsAttribute(r5.getAttribute("points")), a4 = e3.parseAttributes(r5, e3[t4].ATTRIBUTE_NAMES);
        a4.fromSVG = true, n5(new e3[t4](o5, i3(a4, s5)));
      };
    }, e3.Polyline.fromElement = e3.Polyline.fromElementGenerator("Polyline"), e3.Polyline.fromObject = function(t4, i4) {
      return e3.Object._fromObject("Polyline", t4, i4, "points");
    });
  }(e2), function(t3) {
    var e3 = t3.fabric || (t3.fabric = {}), i3 = e3.util.projectStrokeOnPoints;
    e3.Polygon ? e3.warn("fabric.Polygon is already defined") : (e3.Polygon = e3.util.createClass(e3.Polyline, { type: "polygon", _projectStrokeOnPoints: function() {
      return i3(this.points, this);
    }, _render: function(t4) {
      this.commonRender(t4) && (t4.closePath(), this._renderPaintInOrder(t4));
    } }), e3.Polygon.ATTRIBUTE_NAMES = e3.SHARED_ATTRIBUTES.concat(), e3.Polygon.fromElement = e3.Polyline.fromElementGenerator("Polygon"), e3.Polygon.fromObject = function(t4, i4) {
      e3.Object._fromObject("Polygon", t4, i4, "points");
    });
  }(e2), function(t3) {
    var e3 = t3.fabric || (t3.fabric = {}), i3 = e3.util.array.min, r4 = e3.util.array.max, n4 = e3.util.object.extend, s4 = e3.util.object.clone, o4 = e3.util.toFixed;
    e3.Path ? e3.warn("fabric.Path is already defined") : (e3.Path = e3.util.createClass(e3.Object, { type: "path", path: null, cacheProperties: e3.Object.prototype.cacheProperties.concat("path", "fillRule"), stateProperties: e3.Object.prototype.stateProperties.concat("path"), initialize: function(t4, e4) {
      delete (e4 = s4(e4 || {})).path, this.callSuper("initialize", e4), this._setPath(t4 || [], e4);
    }, _setPath: function(t4, i4) {
      this.path = e3.util.makePathSimpler(Array.isArray(t4) ? t4 : e3.util.parsePath(t4)), e3.Polyline.prototype._setPositionDimensions.call(this, i4 || {});
    }, _renderPathCommands: function(t4) {
      var e4, i4 = 0, r5 = 0, n5 = 0, s5 = 0, o5 = 0, a4 = 0, h4 = -this.pathOffset.x, l4 = -this.pathOffset.y;
      t4.beginPath();
      for (var c4 = 0, u4 = this.path.length; c4 < u4; ++c4) switch ((e4 = this.path[c4])[0]) {
        case "L":
          n5 = e4[1], s5 = e4[2], t4.lineTo(n5 + h4, s5 + l4);
          break;
        case "M":
          i4 = n5 = e4[1], r5 = s5 = e4[2], t4.moveTo(n5 + h4, s5 + l4);
          break;
        case "C":
          n5 = e4[5], s5 = e4[6], o5 = e4[3], a4 = e4[4], t4.bezierCurveTo(e4[1] + h4, e4[2] + l4, o5 + h4, a4 + l4, n5 + h4, s5 + l4);
          break;
        case "Q":
          t4.quadraticCurveTo(e4[1] + h4, e4[2] + l4, e4[3] + h4, e4[4] + l4), n5 = e4[3], s5 = e4[4], o5 = e4[1], a4 = e4[2];
          break;
        case "z":
        case "Z":
          n5 = i4, s5 = r5, t4.closePath();
      }
    }, _render: function(t4) {
      this._renderPathCommands(t4), this._renderPaintInOrder(t4);
    }, toString: function() {
      return "#<fabric.Path (" + this.complexity() + '): { "top": ' + this.top + ', "left": ' + this.left + " }>";
    }, toObject: function(t4) {
      return n4(this.callSuper("toObject", t4), { path: this.path.map(function(t5) {
        return t5.slice();
      }) });
    }, toDatalessObject: function(t4) {
      var e4 = this.toObject(["sourcePath"].concat(t4));
      return e4.sourcePath && delete e4.path, e4;
    }, _toSVG: function() {
      return ["<path ", "COMMON_PARTS", 'd="', e3.util.joinPath(this.path), '" stroke-linecap="round" ', "/>\n"];
    }, _getOffsetTransform: function() {
      var t4 = e3.Object.NUM_FRACTION_DIGITS;
      return " translate(" + o4(-this.pathOffset.x, t4) + ", " + o4(-this.pathOffset.y, t4) + ")";
    }, toClipPathSVG: function(t4) {
      var e4 = this._getOffsetTransform();
      return "	" + this._createBaseClipPathSVGMarkup(this._toSVG(), { reviver: t4, additionalTransform: e4 });
    }, toSVG: function(t4) {
      var e4 = this._getOffsetTransform();
      return this._createBaseSVGMarkup(this._toSVG(), { reviver: t4, additionalTransform: e4 });
    }, complexity: function() {
      return this.path.length;
    }, _calcDimensions: function() {
      for (var t4, n5, s5 = [], o5 = [], a4 = 0, h4 = 0, l4 = 0, c4 = 0, u4 = 0, d4 = this.path.length; u4 < d4; ++u4) {
        switch ((t4 = this.path[u4])[0]) {
          case "L":
            l4 = t4[1], c4 = t4[2], n5 = [];
            break;
          case "M":
            a4 = l4 = t4[1], h4 = c4 = t4[2], n5 = [];
            break;
          case "C":
            n5 = e3.util.getBoundsOfCurve(l4, c4, t4[1], t4[2], t4[3], t4[4], t4[5], t4[6]), l4 = t4[5], c4 = t4[6];
            break;
          case "Q":
            n5 = e3.util.getBoundsOfCurve(l4, c4, t4[1], t4[2], t4[1], t4[2], t4[3], t4[4]), l4 = t4[3], c4 = t4[4];
            break;
          case "z":
          case "Z":
            l4 = a4, c4 = h4;
        }
        n5.forEach(function(t5) {
          s5.push(t5.x), o5.push(t5.y);
        }), s5.push(l4), o5.push(c4);
      }
      var f4 = i3(s5) || 0, g4 = i3(o5) || 0;
      return { left: f4, top: g4, width: (r4(s5) || 0) - f4, height: (r4(o5) || 0) - g4 };
    } }), e3.Path.fromObject = function(t4, i4) {
      if ("string" == typeof t4.sourcePath) {
        var r5 = t4.sourcePath;
        e3.loadSVGFromURL(r5, function(e4) {
          var r6 = e4[0];
          r6.setOptions(t4), i4 && i4(r6);
        });
      } else e3.Object._fromObject("Path", t4, i4, "path");
    }, e3.Path.ATTRIBUTE_NAMES = e3.SHARED_ATTRIBUTES.concat(["d"]), e3.Path.fromElement = function(t4, i4, r5) {
      var s5 = e3.parseAttributes(t4, e3.Path.ATTRIBUTE_NAMES);
      s5.fromSVG = true, i4(new e3.Path(s5.d, n4(s5, r5)));
    });
  }(e2), function(t3) {
    var e3 = t3.fabric || (t3.fabric = {}), i3 = e3.util.array.min, r4 = e3.util.array.max;
    e3.Group || (e3.Group = e3.util.createClass(e3.Object, e3.Collection, { type: "group", strokeWidth: 0, subTargetCheck: false, cacheProperties: [], useSetOnGroup: false, initialize: function(t4, e4, i4) {
      e4 = e4 || {}, this._objects = [], i4 && this.callSuper("initialize", e4), this._objects = t4 || [];
      for (var r5 = this._objects.length; r5--; ) this._objects[r5].group = this;
      if (i4) this._updateObjectsACoords();
      else {
        var n4 = e4 && e4.centerPoint;
        void 0 !== e4.originX && (this.originX = e4.originX), void 0 !== e4.originY && (this.originY = e4.originY), n4 || this._calcBounds(), this._updateObjectsCoords(n4), delete e4.centerPoint, this.callSuper("initialize", e4);
      }
      this.setCoords();
    }, _updateObjectsACoords: function() {
      for (var t4 = this._objects.length; t4--; ) this._objects[t4].setCoords(true);
    }, _updateObjectsCoords: function(t4) {
      t4 = t4 || this.getCenterPoint();
      for (var e4 = this._objects.length; e4--; ) this._updateObjectCoords(this._objects[e4], t4);
    }, _updateObjectCoords: function(t4, e4) {
      var i4 = t4.left, r5 = t4.top;
      t4.set({ left: i4 - e4.x, top: r5 - e4.y }), t4.group = this, t4.setCoords(true);
    }, toString: function() {
      return "#<fabric.Group: (" + this.complexity() + ")>";
    }, addWithUpdate: function(t4) {
      var i4 = !!this.group;
      return this._restoreObjectsState(), e3.util.resetObjectTransform(this), t4 && (i4 && e3.util.removeTransformFromObject(t4, this.group.calcTransformMatrix()), this._objects.push(t4), t4.group = this, t4._set("canvas", this.canvas)), this._calcBounds(), this._updateObjectsCoords(), this.dirty = true, i4 ? this.group.addWithUpdate() : this.setCoords(), this;
    }, removeWithUpdate: function(t4) {
      return this._restoreObjectsState(), e3.util.resetObjectTransform(this), this.remove(t4), this._calcBounds(), this._updateObjectsCoords(), this.setCoords(), this.dirty = true, this;
    }, _onObjectAdded: function(t4) {
      this.dirty = true, t4.group = this, t4._set("canvas", this.canvas);
    }, _onObjectRemoved: function(t4) {
      this.dirty = true, delete t4.group;
    }, _set: function(t4, i4) {
      var r5 = this._objects.length;
      if (this.useSetOnGroup) for (; r5--; ) this._objects[r5].setOnGroup(t4, i4);
      if ("canvas" === t4) for (; r5--; ) this._objects[r5]._set(t4, i4);
      e3.Object.prototype._set.call(this, t4, i4);
    }, toObject: function(t4) {
      var i4 = this.includeDefaultValues, r5 = this._objects.filter(function(t5) {
        return !t5.excludeFromExport;
      }).map(function(e4) {
        var r6 = e4.includeDefaultValues;
        e4.includeDefaultValues = i4;
        var n5 = e4.toObject(t4);
        return e4.includeDefaultValues = r6, n5;
      }), n4 = e3.Object.prototype.toObject.call(this, t4);
      return n4.objects = r5, n4;
    }, toDatalessObject: function(t4) {
      var i4, r5 = this.sourcePath;
      if (r5) i4 = r5;
      else {
        var n4 = this.includeDefaultValues;
        i4 = this._objects.map(function(e4) {
          var i5 = e4.includeDefaultValues;
          e4.includeDefaultValues = n4;
          var r6 = e4.toDatalessObject(t4);
          return e4.includeDefaultValues = i5, r6;
        });
      }
      var s4 = e3.Object.prototype.toDatalessObject.call(this, t4);
      return s4.objects = i4, s4;
    }, render: function(t4) {
      this._transformDone = true, this.callSuper("render", t4), this._transformDone = false;
    }, shouldCache: function() {
      var t4 = e3.Object.prototype.shouldCache.call(this);
      if (t4) {
        for (var i4 = 0, r5 = this._objects.length; i4 < r5; i4++) if (this._objects[i4].willDrawShadow()) return this.ownCaching = false, false;
      }
      return t4;
    }, willDrawShadow: function() {
      if (e3.Object.prototype.willDrawShadow.call(this)) return true;
      for (var t4 = 0, i4 = this._objects.length; t4 < i4; t4++) if (this._objects[t4].willDrawShadow()) return true;
      return false;
    }, isOnACache: function() {
      return this.ownCaching || this.group && this.group.isOnACache();
    }, drawObject: function(t4) {
      for (var e4 = 0, i4 = this._objects.length; e4 < i4; e4++) this._objects[e4].render(t4);
      this._drawClipPath(t4, this.clipPath);
    }, isCacheDirty: function(t4) {
      if (this.callSuper("isCacheDirty", t4)) return true;
      if (!this.statefullCache) return false;
      for (var e4 = 0, i4 = this._objects.length; e4 < i4; e4++) if (this._objects[e4].isCacheDirty(true)) {
        if (this._cacheCanvas) {
          var r5 = this.cacheWidth / this.zoomX, n4 = this.cacheHeight / this.zoomY;
          this._cacheContext.clearRect(-r5 / 2, -n4 / 2, r5, n4);
        }
        return true;
      }
      return false;
    }, _restoreObjectsState: function() {
      var t4 = this.calcOwnMatrix();
      return this._objects.forEach(function(i4) {
        e3.util.addTransformToObject(i4, t4), delete i4.group, i4.setCoords();
      }), this;
    }, destroy: function() {
      return this._objects.forEach(function(t4) {
        t4.set("dirty", true);
      }), this._restoreObjectsState();
    }, dispose: function() {
      this.callSuper("dispose"), this.forEachObject(function(t4) {
        t4.dispose && t4.dispose();
      }), this._objects = [];
    }, toActiveSelection: function() {
      if (this.canvas) {
        var t4 = this._objects, i4 = this.canvas;
        this._objects = [];
        var r5 = this.toObject();
        delete r5.objects;
        var n4 = new e3.ActiveSelection([]);
        return n4.set(r5), n4.type = "activeSelection", i4.remove(this), t4.forEach(function(t5) {
          t5.group = n4, t5.dirty = true, i4.add(t5);
        }), n4.canvas = i4, n4._objects = t4, i4._activeObject = n4, n4.setCoords(), n4;
      }
    }, ungroupOnCanvas: function() {
      return this._restoreObjectsState();
    }, setObjectsCoords: function() {
      return this.forEachObject(function(t4) {
        t4.setCoords(true);
      }), this;
    }, _calcBounds: function(t4) {
      for (var e4, i4, r5, n4, s4 = [], o4 = [], a4 = ["tr", "br", "bl", "tl"], h4 = 0, l4 = this._objects.length, c4 = a4.length; h4 < l4; ++h4) {
        for (r5 = (e4 = this._objects[h4]).calcACoords(), n4 = 0; n4 < c4; n4++) i4 = a4[n4], s4.push(r5[i4].x), o4.push(r5[i4].y);
        e4.aCoords = r5;
      }
      this._getBounds(s4, o4, t4);
    }, _getBounds: function(t4, n4, s4) {
      var o4 = new e3.Point(i3(t4), i3(n4)), a4 = new e3.Point(r4(t4), r4(n4)), h4 = o4.y || 0, l4 = o4.x || 0, c4 = a4.x - o4.x || 0, u4 = a4.y - o4.y || 0;
      this.width = c4, this.height = u4, s4 || this.setPositionByOrigin({ x: l4, y: h4 }, "left", "top");
    }, _toSVG: function(t4) {
      for (var e4 = ["<g ", "COMMON_PARTS", " >\n"], i4 = 0, r5 = this._objects.length; i4 < r5; i4++) e4.push("		", this._objects[i4].toSVG(t4));
      return e4.push("</g>\n"), e4;
    }, getSvgStyles: function() {
      var t4 = void 0 !== this.opacity && 1 !== this.opacity ? "opacity: " + this.opacity + ";" : "", e4 = this.visible ? "" : " visibility: hidden;";
      return [t4, this.getSvgFilter(), e4].join("");
    }, toClipPathSVG: function(t4) {
      for (var e4 = [], i4 = 0, r5 = this._objects.length; i4 < r5; i4++) e4.push("	", this._objects[i4].toClipPathSVG(t4));
      return this._createBaseClipPathSVGMarkup(e4, { reviver: t4 });
    } }), e3.Group.fromObject = function(t4, i4) {
      var r5 = t4.objects, n4 = e3.util.object.clone(t4, true);
      delete n4.objects, "string" != typeof r5 ? e3.util.enlivenObjects(r5, function(r6) {
        var n5 = e3.util.object.clone(t4, true);
        delete n5.objects, e3.util.enlivenObjectEnlivables(t4, n5, function() {
          i4 && i4(new e3.Group(r6, n5, true));
        });
      }) : e3.loadSVGFromURL(r5, function(s4) {
        var o4 = e3.util.groupSVGElements(s4, t4, r5);
        o4.set(n4), i4 && i4(o4);
      });
    });
  }(e2), function(t3) {
    var e3 = t3.fabric || (t3.fabric = {});
    e3.ActiveSelection || (e3.ActiveSelection = e3.util.createClass(e3.Group, { type: "activeSelection", initialize: function(t4, i3) {
      i3 = i3 || {}, this._objects = t4 || [];
      for (var r4 = this._objects.length; r4--; ) this._objects[r4].group = this;
      i3.originX && (this.originX = i3.originX), i3.originY && (this.originY = i3.originY), this._calcBounds(), this._updateObjectsCoords(), e3.Object.prototype.initialize.call(this, i3), this.setCoords();
    }, toGroup: function() {
      var t4 = this._objects.concat();
      this._objects = [];
      var i3 = e3.Object.prototype.toObject.call(this), r4 = new e3.Group([]);
      if (delete i3.type, r4.set(i3), t4.forEach(function(t5) {
        t5.canvas.remove(t5), t5.group = r4;
      }), r4._objects = t4, !this.canvas) return r4;
      var n4 = this.canvas;
      return n4.add(r4), n4._activeObject = r4, r4.setCoords(), r4;
    }, onDeselect: function() {
      return this.destroy(), false;
    }, toString: function() {
      return "#<fabric.ActiveSelection: (" + this.complexity() + ")>";
    }, shouldCache: function() {
      return false;
    }, isOnACache: function() {
      return false;
    }, _renderControls: function(t4, e4, i3) {
      t4.save(), t4.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1, this.callSuper("_renderControls", t4, e4), void 0 === (i3 = i3 || {}).hasControls && (i3.hasControls = false), i3.forActiveSelection = true;
      for (var r4 = 0, n4 = this._objects.length; r4 < n4; r4++) this._objects[r4]._renderControls(t4, i3);
      t4.restore();
    } }), e3.ActiveSelection.fromObject = function(t4, i3) {
      e3.util.enlivenObjects(t4.objects, function(r4) {
        delete t4.objects, i3 && i3(new e3.ActiveSelection(r4, t4, true));
      });
    });
  }(e2), function(t3) {
    var e3 = x3.util.object.extend;
    t3.fabric || (t3.fabric = {}), t3.fabric.Image ? x3.warn("fabric.Image is already defined.") : (x3.Image = x3.util.createClass(x3.Object, { type: "image", strokeWidth: 0, srcFromAttribute: false, _lastScaleX: 1, _lastScaleY: 1, _filterScalingX: 1, _filterScalingY: 1, minimumScaleTrigger: 0.5, stateProperties: x3.Object.prototype.stateProperties.concat("cropX", "cropY"), cacheProperties: x3.Object.prototype.cacheProperties.concat("cropX", "cropY"), cacheKey: "", cropX: 0, cropY: 0, imageSmoothing: true, initialize: function(t4, e4) {
      e4 || (e4 = {}), this.filters = [], this.cacheKey = "texture" + x3.Object.__uid++, this.callSuper("initialize", e4), this._initElement(t4, e4);
    }, getElement: function() {
      return this._element || {};
    }, setElement: function(t4, e4) {
      return this.removeTexture(this.cacheKey), this.removeTexture(this.cacheKey + "_filtered"), this._element = t4, this._originalElement = t4, this._initConfig(e4), 0 !== this.filters.length && this.applyFilters(), this.resizeFilter && this.applyResizeFilters(), this;
    }, removeTexture: function(t4) {
      var e4 = x3.filterBackend;
      e4 && e4.evictCachesForKey && e4.evictCachesForKey(t4);
    }, dispose: function() {
      this.callSuper("dispose"), this.removeTexture(this.cacheKey), this.removeTexture(this.cacheKey + "_filtered"), this._cacheContext = void 0, ["_originalElement", "_element", "_filteredEl", "_cacheCanvas"].forEach((function(t4) {
        x3.util.cleanUpJsdomNode(this[t4]), this[t4] = void 0;
      }).bind(this));
    }, getCrossOrigin: function() {
      return this._originalElement && (this._originalElement.crossOrigin || null);
    }, getOriginalSize: function() {
      var t4 = this.getElement();
      return { width: t4.naturalWidth || t4.width, height: t4.naturalHeight || t4.height };
    }, _stroke: function(t4) {
      if (this.stroke && 0 !== this.strokeWidth) {
        var e4 = this.width / 2, i3 = this.height / 2;
        t4.beginPath(), t4.moveTo(-e4, -i3), t4.lineTo(e4, -i3), t4.lineTo(e4, i3), t4.lineTo(-e4, i3), t4.lineTo(-e4, -i3), t4.closePath();
      }
    }, toObject: function(t4) {
      var i3 = [];
      this.filters.forEach(function(t5) {
        t5 && i3.push(t5.toObject());
      });
      var r4 = e3(this.callSuper("toObject", ["cropX", "cropY"].concat(t4)), { src: this.getSrc(), crossOrigin: this.getCrossOrigin(), filters: i3 });
      return this.resizeFilter && (r4.resizeFilter = this.resizeFilter.toObject()), r4;
    }, hasCrop: function() {
      return this.cropX || this.cropY || this.width < this._element.width || this.height < this._element.height;
    }, _toSVG: function() {
      var t4, e4 = [], i3 = [], r4 = this._element, n4 = -this.width / 2, s4 = -this.height / 2, o4 = "", a4 = "";
      if (!r4) return [];
      if (this.hasCrop()) {
        var h4 = x3.Object.__uid++;
        e4.push('<clipPath id="imageCrop_' + h4 + '">\n', '	<rect x="' + n4 + '" y="' + s4 + '" width="' + this.width + '" height="' + this.height + '" />\n', "</clipPath>\n"), o4 = ' clip-path="url(#imageCrop_' + h4 + ')" ';
      }
      if (this.imageSmoothing || (a4 = '" image-rendering="optimizeSpeed'), i3.push("	<image ", "COMMON_PARTS", 'xlink:href="', this.getSvgSrc(true), '" x="', n4 - this.cropX, '" y="', s4 - this.cropY, '" width="', r4.width || r4.naturalWidth, '" height="', r4.height || r4.height, a4, '"', o4, "></image>\n"), this.stroke || this.strokeDashArray) {
        var l4 = this.fill;
        this.fill = null, t4 = ["	<rect ", 'x="', n4, '" y="', s4, '" width="', this.width, '" height="', this.height, '" style="', this.getSvgStyles(), '"/>\n'], this.fill = l4;
      }
      return "fill" !== this.paintFirst ? e4.concat(t4, i3) : e4.concat(i3, t4);
    }, getSrc: function(t4) {
      var e4 = t4 ? this._element : this._originalElement;
      return e4 ? e4.toDataURL ? e4.toDataURL() : this.srcFromAttribute ? e4.getAttribute("src") : e4.src : this.src || "";
    }, setSrc: function(t4, e4, i3) {
      return x3.util.loadImage(t4, function(t5, r4) {
        this.setElement(t5, i3), this._setWidthHeight(), e4 && e4(this, r4);
      }, this, i3 && i3.crossOrigin), this;
    }, toString: function() {
      return '#<fabric.Image: { src: "' + this.getSrc() + '" }>';
    }, applyResizeFilters: function() {
      var t4 = this.resizeFilter, e4 = this.minimumScaleTrigger, i3 = this.getTotalObjectScaling(), r4 = i3.scaleX, n4 = i3.scaleY, s4 = this._filteredEl || this._originalElement;
      if (this.group && this.set("dirty", true), !t4 || r4 > e4 && n4 > e4) return this._element = s4, this._filterScalingX = 1, this._filterScalingY = 1, this._lastScaleX = r4, void (this._lastScaleY = n4);
      x3.filterBackend || (x3.filterBackend = x3.initFilterBackend());
      var o4 = x3.util.createCanvasElement(), a4 = this._filteredEl ? this.cacheKey + "_filtered" : this.cacheKey, h4 = s4.width, l4 = s4.height;
      o4.width = h4, o4.height = l4, this._element = o4, this._lastScaleX = t4.scaleX = r4, this._lastScaleY = t4.scaleY = n4, x3.filterBackend.applyFilters([t4], s4, h4, l4, this._element, a4), this._filterScalingX = o4.width / this._originalElement.width, this._filterScalingY = o4.height / this._originalElement.height;
    }, applyFilters: function(t4) {
      if (t4 = (t4 = t4 || this.filters || []).filter(function(t5) {
        return t5 && !t5.isNeutralState();
      }), this.set("dirty", true), this.removeTexture(this.cacheKey + "_filtered"), 0 === t4.length) return this._element = this._originalElement, this._filteredEl = null, this._filterScalingX = 1, this._filterScalingY = 1, this;
      var e4 = this._originalElement, i3 = e4.naturalWidth || e4.width, r4 = e4.naturalHeight || e4.height;
      if (this._element === this._originalElement) {
        var n4 = x3.util.createCanvasElement();
        n4.width = i3, n4.height = r4, this._element = n4, this._filteredEl = n4;
      } else this._element = this._filteredEl, this._filteredEl.getContext("2d").clearRect(0, 0, i3, r4), this._lastScaleX = 1, this._lastScaleY = 1;
      return x3.filterBackend || (x3.filterBackend = x3.initFilterBackend()), x3.filterBackend.applyFilters(t4, this._originalElement, i3, r4, this._element, this.cacheKey), this._originalElement.width === this._element.width && this._originalElement.height === this._element.height || (this._filterScalingX = this._element.width / this._originalElement.width, this._filterScalingY = this._element.height / this._originalElement.height), this;
    }, _render: function(t4) {
      x3.util.setImageSmoothing(t4, this.imageSmoothing), true !== this.isMoving && this.resizeFilter && this._needsResize() && this.applyResizeFilters(), this._stroke(t4), this._renderPaintInOrder(t4);
    }, drawCacheOnCanvas: function(t4) {
      x3.util.setImageSmoothing(t4, this.imageSmoothing), x3.Object.prototype.drawCacheOnCanvas.call(this, t4);
    }, shouldCache: function() {
      return this.needsItsOwnCache();
    }, _renderFill: function(t4) {
      var e4 = this._element;
      if (e4) {
        var i3 = this._filterScalingX, r4 = this._filterScalingY, n4 = this.width, s4 = this.height, o4 = Math.min, a4 = Math.max, h4 = a4(this.cropX, 0), l4 = a4(this.cropY, 0), c4 = e4.naturalWidth || e4.width, u4 = e4.naturalHeight || e4.height, d4 = h4 * i3, f4 = l4 * r4, g4 = o4(n4 * i3, c4 - d4), p4 = o4(s4 * r4, u4 - f4), m4 = -n4 / 2, v4 = -s4 / 2, _4 = o4(n4, c4 / i3 - h4), y4 = o4(s4, u4 / r4 - l4);
        e4 && t4.drawImage(e4, d4, f4, g4, p4, m4, v4, _4, y4);
      }
    }, _needsResize: function() {
      var t4 = this.getTotalObjectScaling();
      return t4.scaleX !== this._lastScaleX || t4.scaleY !== this._lastScaleY;
    }, _resetWidthHeight: function() {
      this.set(this.getOriginalSize());
    }, _initElement: function(t4, e4) {
      this.setElement(x3.util.getById(t4), e4), x3.util.addClass(this.getElement(), x3.Image.CSS_CANVAS);
    }, _initConfig: function(t4) {
      t4 || (t4 = {}), this.setOptions(t4), this._setWidthHeight(t4);
    }, _initFilters: function(t4, e4) {
      t4 && t4.length ? x3.util.enlivenObjects(t4, function(t5) {
        e4 && e4(t5);
      }, "fabric.Image.filters") : e4 && e4();
    }, _setWidthHeight: function(t4) {
      t4 || (t4 = {});
      var e4 = this.getElement();
      this.width = t4.width || e4.naturalWidth || e4.width || 0, this.height = t4.height || e4.naturalHeight || e4.height || 0;
    }, parsePreserveAspectRatioAttribute: function() {
      var t4, e4 = x3.util.parsePreserveAspectRatioAttribute(this.preserveAspectRatio || ""), i3 = this._element.width, r4 = this._element.height, n4 = 1, s4 = 1, o4 = 0, a4 = 0, h4 = 0, l4 = 0, c4 = this.width, u4 = this.height, d4 = { width: c4, height: u4 };
      return !e4 || "none" === e4.alignX && "none" === e4.alignY ? (n4 = c4 / i3, s4 = u4 / r4) : ("meet" === e4.meetOrSlice && (t4 = (c4 - i3 * (n4 = s4 = x3.util.findScaleToFit(this._element, d4))) / 2, "Min" === e4.alignX && (o4 = -t4), "Max" === e4.alignX && (o4 = t4), t4 = (u4 - r4 * s4) / 2, "Min" === e4.alignY && (a4 = -t4), "Max" === e4.alignY && (a4 = t4)), "slice" === e4.meetOrSlice && (t4 = i3 - c4 / (n4 = s4 = x3.util.findScaleToCover(this._element, d4)), "Mid" === e4.alignX && (h4 = t4 / 2), "Max" === e4.alignX && (h4 = t4), t4 = r4 - u4 / s4, "Mid" === e4.alignY && (l4 = t4 / 2), "Max" === e4.alignY && (l4 = t4), i3 = c4 / n4, r4 = u4 / s4)), { width: i3, height: r4, scaleX: n4, scaleY: s4, offsetLeft: o4, offsetTop: a4, cropX: h4, cropY: l4 };
    } }), x3.Image.CSS_CANVAS = "canvas-img", x3.Image.prototype.getSvgSrc = x3.Image.prototype.getSrc, x3.Image.fromObject = function(t4, e4) {
      var i3 = x3.util.object.clone(t4);
      x3.util.loadImage(i3.src, function(t5, r4) {
        r4 ? e4 && e4(null, true) : x3.Image.prototype._initFilters.call(i3, i3.filters, function(r5) {
          i3.filters = r5 || [], x3.Image.prototype._initFilters.call(i3, [i3.resizeFilter], function(r6) {
            i3.resizeFilter = r6[0], x3.util.enlivenObjectEnlivables(i3, i3, function() {
              var r7 = new x3.Image(t5, i3);
              e4(r7, false);
            });
          });
        });
      }, null, i3.crossOrigin);
    }, x3.Image.fromURL = function(t4, e4, i3) {
      x3.util.loadImage(t4, function(t5, r4) {
        e4 && e4(new x3.Image(t5, i3), r4);
      }, null, i3 && i3.crossOrigin);
    }, x3.Image.ATTRIBUTE_NAMES = x3.SHARED_ATTRIBUTES.concat("x y width height preserveAspectRatio xlink:href crossOrigin image-rendering".split(" ")), x3.Image.fromElement = function(t4, i3, r4) {
      var n4 = x3.parseAttributes(t4, x3.Image.ATTRIBUTE_NAMES);
      x3.Image.fromURL(n4["xlink:href"], i3, e3(r4 ? x3.util.object.clone(r4) : {}, n4));
    });
  }(e2), x3.util.object.extend(x3.Object.prototype, { _getAngleValueForStraighten: function() {
    var t3 = this.angle % 360;
    return t3 > 0 ? 90 * Math.round((t3 - 1) / 90) : 90 * Math.round(t3 / 90);
  }, straighten: function() {
    return this.rotate(this._getAngleValueForStraighten());
  }, fxStraighten: function(t3) {
    var e3 = function() {
    }, i3 = (t3 = t3 || {}).onComplete || e3, r4 = t3.onChange || e3, n4 = this;
    return x3.util.animate({ target: this, startValue: this.get("angle"), endValue: this._getAngleValueForStraighten(), duration: this.FX_DURATION, onChange: function(t4) {
      n4.rotate(t4), r4();
    }, onComplete: function() {
      n4.setCoords(), i3();
    } });
  } }), x3.util.object.extend(x3.StaticCanvas.prototype, { straightenObject: function(t3) {
    return t3.straighten(), this.requestRenderAll(), this;
  }, fxStraightenObject: function(t3) {
    return t3.fxStraighten({ onChange: this.requestRenderAllBound });
  } }), function() {
    function t3(t4, e4) {
      var i3 = "precision " + e4 + " float;\nvoid main(){}", r4 = t4.createShader(t4.FRAGMENT_SHADER);
      return t4.shaderSource(r4, i3), t4.compileShader(r4), !!t4.getShaderParameter(r4, t4.COMPILE_STATUS);
    }
    function e3(t4) {
      t4 && t4.tileSize && (this.tileSize = t4.tileSize), this.setupGLContext(this.tileSize, this.tileSize), this.captureGPUInfo();
    }
    x3.isWebglSupported = function(e4) {
      if (x3.isLikelyNode) return false;
      e4 = e4 || x3.WebglFilterBackend.prototype.tileSize;
      var i3 = document.createElement("canvas"), r4 = i3.getContext("webgl") || i3.getContext("experimental-webgl"), n4 = false;
      if (r4) {
        x3.maxTextureSize = r4.getParameter(r4.MAX_TEXTURE_SIZE), n4 = x3.maxTextureSize >= e4;
        for (var s4 = ["highp", "mediump", "lowp"], o4 = 0; o4 < 3; o4++) if (t3(r4, s4[o4])) {
          x3.webGlPrecision = s4[o4];
          break;
        }
      }
      return this.isSupported = n4, n4;
    }, x3.WebglFilterBackend = e3, e3.prototype = { tileSize: 2048, resources: {}, setupGLContext: function(t4, e4) {
      this.dispose(), this.createWebGLCanvas(t4, e4), this.aPosition = new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]), this.chooseFastestCopyGLTo2DMethod(t4, e4);
    }, chooseFastestCopyGLTo2DMethod: function(t4, e4) {
      var i3, r4 = void 0 !== window.performance;
      try {
        new ImageData(1, 1), i3 = true;
      } catch (t5) {
        i3 = false;
      }
      var n4 = "undefined" != typeof ArrayBuffer, s4 = "undefined" != typeof Uint8ClampedArray;
      if (r4 && i3 && n4 && s4) {
        var o4 = x3.util.createCanvasElement(), a4 = new ArrayBuffer(t4 * e4 * 4);
        if (x3.forceGLPutImageData) return this.imageBuffer = a4, void (this.copyGLTo2D = E3);
        var h4, l4, c4 = { imageBuffer: a4, destinationWidth: t4, destinationHeight: e4, targetCanvas: o4 };
        o4.width = t4, o4.height = e4, h4 = window.performance.now(), O3.call(c4, this.gl, c4), l4 = window.performance.now() - h4, h4 = window.performance.now(), E3.call(c4, this.gl, c4), l4 > window.performance.now() - h4 ? (this.imageBuffer = a4, this.copyGLTo2D = E3) : this.copyGLTo2D = O3;
      }
    }, createWebGLCanvas: function(t4, e4) {
      var i3 = x3.util.createCanvasElement();
      i3.width = t4, i3.height = e4;
      var r4 = { alpha: true, premultipliedAlpha: false, depth: false, stencil: false, antialias: false }, n4 = i3.getContext("webgl", r4);
      n4 || (n4 = i3.getContext("experimental-webgl", r4)), n4 && (n4.clearColor(0, 0, 0, 0), this.canvas = i3, this.gl = n4);
    }, applyFilters: function(t4, e4, i3, r4, n4, s4) {
      var o4, a4 = this.gl;
      s4 && (o4 = this.getCachedTexture(s4, e4));
      var h4 = { originalWidth: e4.width || e4.originalWidth, originalHeight: e4.height || e4.originalHeight, sourceWidth: i3, sourceHeight: r4, destinationWidth: i3, destinationHeight: r4, context: a4, sourceTexture: this.createTexture(a4, i3, r4, !o4 && e4), targetTexture: this.createTexture(a4, i3, r4), originalTexture: o4 || this.createTexture(a4, i3, r4, !o4 && e4), passes: t4.length, webgl: true, aPosition: this.aPosition, programCache: this.programCache, pass: 0, filterBackend: this, targetCanvas: n4 }, l4 = a4.createFramebuffer();
      return a4.bindFramebuffer(a4.FRAMEBUFFER, l4), t4.forEach(function(t5) {
        t5 && t5.applyTo(h4);
      }), function(t5) {
        var e5 = t5.targetCanvas, i4 = e5.width, r5 = e5.height, n5 = t5.destinationWidth, s5 = t5.destinationHeight;
        i4 === n5 && r5 === s5 || (e5.width = n5, e5.height = s5);
      }(h4), this.copyGLTo2D(a4, h4), a4.bindTexture(a4.TEXTURE_2D, null), a4.deleteTexture(h4.sourceTexture), a4.deleteTexture(h4.targetTexture), a4.deleteFramebuffer(l4), n4.getContext("2d").setTransform(1, 0, 0, 1, 0, 0), h4;
    }, dispose: function() {
      this.canvas && (this.canvas = null, this.gl = null), this.clearWebGLCaches();
    }, clearWebGLCaches: function() {
      this.programCache = {}, this.textureCache = {};
    }, createTexture: function(t4, e4, i3, r4) {
      var n4 = t4.createTexture();
      return t4.bindTexture(t4.TEXTURE_2D, n4), t4.texParameteri(t4.TEXTURE_2D, t4.TEXTURE_MAG_FILTER, t4.NEAREST), t4.texParameteri(t4.TEXTURE_2D, t4.TEXTURE_MIN_FILTER, t4.NEAREST), t4.texParameteri(t4.TEXTURE_2D, t4.TEXTURE_WRAP_S, t4.CLAMP_TO_EDGE), t4.texParameteri(t4.TEXTURE_2D, t4.TEXTURE_WRAP_T, t4.CLAMP_TO_EDGE), r4 ? t4.texImage2D(t4.TEXTURE_2D, 0, t4.RGBA, t4.RGBA, t4.UNSIGNED_BYTE, r4) : t4.texImage2D(t4.TEXTURE_2D, 0, t4.RGBA, e4, i3, 0, t4.RGBA, t4.UNSIGNED_BYTE, null), n4;
    }, getCachedTexture: function(t4, e4) {
      if (this.textureCache[t4]) return this.textureCache[t4];
      var i3 = this.createTexture(this.gl, e4.width, e4.height, e4);
      return this.textureCache[t4] = i3, i3;
    }, evictCachesForKey: function(t4) {
      this.textureCache[t4] && (this.gl.deleteTexture(this.textureCache[t4]), delete this.textureCache[t4]);
    }, copyGLTo2D: O3, captureGPUInfo: function() {
      if (this.gpuInfo) return this.gpuInfo;
      var t4 = this.gl, e4 = { renderer: "", vendor: "" };
      if (!t4) return e4;
      var i3 = t4.getExtension("WEBGL_debug_renderer_info");
      if (i3) {
        var r4 = t4.getParameter(i3.UNMASKED_RENDERER_WEBGL), n4 = t4.getParameter(i3.UNMASKED_VENDOR_WEBGL);
        r4 && (e4.renderer = r4.toLowerCase()), n4 && (e4.vendor = n4.toLowerCase());
      }
      return this.gpuInfo = e4, e4;
    } };
  }(), function() {
    var t3 = function() {
    };
    function e3() {
    }
    x3.Canvas2dFilterBackend = e3, e3.prototype = { evictCachesForKey: t3, dispose: t3, clearWebGLCaches: t3, resources: {}, applyFilters: function(t4, e4, i3, r4, n4) {
      var s4 = n4.getContext("2d");
      s4.drawImage(e4, 0, 0, i3, r4);
      var o4 = { sourceWidth: i3, sourceHeight: r4, imageData: s4.getImageData(0, 0, i3, r4), originalEl: e4, originalImageData: s4.getImageData(0, 0, i3, r4), canvasEl: n4, ctx: s4, filterBackend: this };
      return t4.forEach(function(t5) {
        t5.applyTo(o4);
      }), o4.imageData.width === i3 && o4.imageData.height === r4 || (n4.width = o4.imageData.width, n4.height = o4.imageData.height), s4.putImageData(o4.imageData, 0, 0), o4;
    } };
  }(), x3.Image = x3.Image || {}, x3.Image.filters = x3.Image.filters || {}, x3.Image.filters.BaseFilter = x3.util.createClass({ type: "BaseFilter", vertexSource: "attribute vec2 aPosition;\nvarying vec2 vTexCoord;\nvoid main() {\nvTexCoord = aPosition;\ngl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\n}", fragmentSource: "precision highp float;\nvarying vec2 vTexCoord;\nuniform sampler2D uTexture;\nvoid main() {\ngl_FragColor = texture2D(uTexture, vTexCoord);\n}", initialize: function(t3) {
    t3 && this.setOptions(t3);
  }, setOptions: function(t3) {
    for (var e3 in t3) this[e3] = t3[e3];
  }, createProgram: function(t3, e3, i3) {
    e3 = e3 || this.fragmentSource, i3 = i3 || this.vertexSource, "highp" !== x3.webGlPrecision && (e3 = e3.replace(/precision highp float/g, "precision " + x3.webGlPrecision + " float"));
    var r4 = t3.createShader(t3.VERTEX_SHADER);
    if (t3.shaderSource(r4, i3), t3.compileShader(r4), !t3.getShaderParameter(r4, t3.COMPILE_STATUS)) throw new Error("Vertex shader compile error for " + this.type + ": " + t3.getShaderInfoLog(r4));
    var n4 = t3.createShader(t3.FRAGMENT_SHADER);
    if (t3.shaderSource(n4, e3), t3.compileShader(n4), !t3.getShaderParameter(n4, t3.COMPILE_STATUS)) throw new Error("Fragment shader compile error for " + this.type + ": " + t3.getShaderInfoLog(n4));
    var s4 = t3.createProgram();
    if (t3.attachShader(s4, r4), t3.attachShader(s4, n4), t3.linkProgram(s4), !t3.getProgramParameter(s4, t3.LINK_STATUS)) throw new Error('Shader link error for "${this.type}" ' + t3.getProgramInfoLog(s4));
    var o4 = this.getAttributeLocations(t3, s4), a4 = this.getUniformLocations(t3, s4) || {};
    return a4.uStepW = t3.getUniformLocation(s4, "uStepW"), a4.uStepH = t3.getUniformLocation(s4, "uStepH"), { program: s4, attributeLocations: o4, uniformLocations: a4 };
  }, getAttributeLocations: function(t3, e3) {
    return { aPosition: t3.getAttribLocation(e3, "aPosition") };
  }, getUniformLocations: function() {
    return {};
  }, sendAttributeData: function(t3, e3, i3) {
    var r4 = e3.aPosition, n4 = t3.createBuffer();
    t3.bindBuffer(t3.ARRAY_BUFFER, n4), t3.enableVertexAttribArray(r4), t3.vertexAttribPointer(r4, 2, t3.FLOAT, false, 0, 0), t3.bufferData(t3.ARRAY_BUFFER, i3, t3.STATIC_DRAW);
  }, _setupFrameBuffer: function(t3) {
    var e3, i3, r4 = t3.context;
    t3.passes > 1 ? (e3 = t3.destinationWidth, i3 = t3.destinationHeight, t3.sourceWidth === e3 && t3.sourceHeight === i3 || (r4.deleteTexture(t3.targetTexture), t3.targetTexture = t3.filterBackend.createTexture(r4, e3, i3)), r4.framebufferTexture2D(r4.FRAMEBUFFER, r4.COLOR_ATTACHMENT0, r4.TEXTURE_2D, t3.targetTexture, 0)) : (r4.bindFramebuffer(r4.FRAMEBUFFER, null), r4.finish());
  }, _swapTextures: function(t3) {
    t3.passes--, t3.pass++;
    var e3 = t3.targetTexture;
    t3.targetTexture = t3.sourceTexture, t3.sourceTexture = e3;
  }, isNeutralState: function() {
    var t3 = this.mainParameter, e3 = x3.Image.filters[this.type].prototype;
    if (t3) {
      if (Array.isArray(e3[t3])) {
        for (var i3 = e3[t3].length; i3--; ) if (this[t3][i3] !== e3[t3][i3]) return false;
        return true;
      }
      return e3[t3] === this[t3];
    }
    return false;
  }, applyTo: function(t3) {
    t3.webgl ? (this._setupFrameBuffer(t3), this.applyToWebGL(t3), this._swapTextures(t3)) : this.applyTo2d(t3);
  }, retrieveShader: function(t3) {
    return t3.programCache.hasOwnProperty(this.type) || (t3.programCache[this.type] = this.createProgram(t3.context)), t3.programCache[this.type];
  }, applyToWebGL: function(t3) {
    var e3 = t3.context, i3 = this.retrieveShader(t3);
    0 === t3.pass && t3.originalTexture ? e3.bindTexture(e3.TEXTURE_2D, t3.originalTexture) : e3.bindTexture(e3.TEXTURE_2D, t3.sourceTexture), e3.useProgram(i3.program), this.sendAttributeData(e3, i3.attributeLocations, t3.aPosition), e3.uniform1f(i3.uniformLocations.uStepW, 1 / t3.sourceWidth), e3.uniform1f(i3.uniformLocations.uStepH, 1 / t3.sourceHeight), this.sendUniformData(e3, i3.uniformLocations), e3.viewport(0, 0, t3.destinationWidth, t3.destinationHeight), e3.drawArrays(e3.TRIANGLE_STRIP, 0, 4);
  }, bindAdditionalTexture: function(t3, e3, i3) {
    t3.activeTexture(i3), t3.bindTexture(t3.TEXTURE_2D, e3), t3.activeTexture(t3.TEXTURE0);
  }, unbindAdditionalTexture: function(t3, e3) {
    t3.activeTexture(e3), t3.bindTexture(t3.TEXTURE_2D, null), t3.activeTexture(t3.TEXTURE0);
  }, getMainParameter: function() {
    return this[this.mainParameter];
  }, setMainParameter: function(t3) {
    this[this.mainParameter] = t3;
  }, sendUniformData: function() {
  }, createHelpLayer: function(t3) {
    if (!t3.helpLayer) {
      var e3 = document.createElement("canvas");
      e3.width = t3.sourceWidth, e3.height = t3.sourceHeight, t3.helpLayer = e3;
    }
  }, toObject: function() {
    var t3 = { type: this.type }, e3 = this.mainParameter;
    return e3 && (t3[e3] = this[e3]), t3;
  }, toJSON: function() {
    return this.toObject();
  } }), x3.Image.filters.BaseFilter.fromObject = function(t3, e3) {
    var i3 = new x3.Image.filters[t3.type](t3);
    return e3 && e3(i3), i3;
  }, function(t3) {
    var e3 = t3.fabric || (t3.fabric = {}), i3 = e3.Image.filters, r4 = e3.util.createClass;
    i3.ColorMatrix = r4(i3.BaseFilter, { type: "ColorMatrix", fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nvarying vec2 vTexCoord;\nuniform mat4 uColorMatrix;\nuniform vec4 uConstants;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\ncolor *= uColorMatrix;\ncolor += uConstants;\ngl_FragColor = color;\n}", matrix: [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], mainParameter: "matrix", colorsOnly: true, initialize: function(t4) {
      this.callSuper("initialize", t4), this.matrix = this.matrix.slice(0);
    }, applyTo2d: function(t4) {
      var e4, i4, r5, n4, s4, o4 = t4.imageData.data, a4 = o4.length, h4 = this.matrix, l4 = this.colorsOnly;
      for (s4 = 0; s4 < a4; s4 += 4) e4 = o4[s4], i4 = o4[s4 + 1], r5 = o4[s4 + 2], l4 ? (o4[s4] = e4 * h4[0] + i4 * h4[1] + r5 * h4[2] + 255 * h4[4], o4[s4 + 1] = e4 * h4[5] + i4 * h4[6] + r5 * h4[7] + 255 * h4[9], o4[s4 + 2] = e4 * h4[10] + i4 * h4[11] + r5 * h4[12] + 255 * h4[14]) : (n4 = o4[s4 + 3], o4[s4] = e4 * h4[0] + i4 * h4[1] + r5 * h4[2] + n4 * h4[3] + 255 * h4[4], o4[s4 + 1] = e4 * h4[5] + i4 * h4[6] + r5 * h4[7] + n4 * h4[8] + 255 * h4[9], o4[s4 + 2] = e4 * h4[10] + i4 * h4[11] + r5 * h4[12] + n4 * h4[13] + 255 * h4[14], o4[s4 + 3] = e4 * h4[15] + i4 * h4[16] + r5 * h4[17] + n4 * h4[18] + 255 * h4[19]);
    }, getUniformLocations: function(t4, e4) {
      return { uColorMatrix: t4.getUniformLocation(e4, "uColorMatrix"), uConstants: t4.getUniformLocation(e4, "uConstants") };
    }, sendUniformData: function(t4, e4) {
      var i4 = this.matrix, r5 = [i4[0], i4[1], i4[2], i4[3], i4[5], i4[6], i4[7], i4[8], i4[10], i4[11], i4[12], i4[13], i4[15], i4[16], i4[17], i4[18]], n4 = [i4[4], i4[9], i4[14], i4[19]];
      t4.uniformMatrix4fv(e4.uColorMatrix, false, r5), t4.uniform4fv(e4.uConstants, n4);
    } }), e3.Image.filters.ColorMatrix.fromObject = e3.Image.filters.BaseFilter.fromObject;
  }(e2), function(t3) {
    var e3 = t3.fabric || (t3.fabric = {}), i3 = e3.Image.filters, r4 = e3.util.createClass;
    i3.Brightness = r4(i3.BaseFilter, { type: "Brightness", fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uBrightness;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\ncolor.rgb += uBrightness;\ngl_FragColor = color;\n}", brightness: 0, mainParameter: "brightness", applyTo2d: function(t4) {
      if (0 !== this.brightness) {
        var e4, i4 = t4.imageData.data, r5 = i4.length, n4 = Math.round(255 * this.brightness);
        for (e4 = 0; e4 < r5; e4 += 4) i4[e4] = i4[e4] + n4, i4[e4 + 1] = i4[e4 + 1] + n4, i4[e4 + 2] = i4[e4 + 2] + n4;
      }
    }, getUniformLocations: function(t4, e4) {
      return { uBrightness: t4.getUniformLocation(e4, "uBrightness") };
    }, sendUniformData: function(t4, e4) {
      t4.uniform1f(e4.uBrightness, this.brightness);
    } }), e3.Image.filters.Brightness.fromObject = e3.Image.filters.BaseFilter.fromObject;
  }(e2), function(t3) {
    var e3 = t3.fabric || (t3.fabric = {}), i3 = e3.util.object.extend, r4 = e3.Image.filters, n4 = e3.util.createClass;
    r4.Convolute = n4(r4.BaseFilter, { type: "Convolute", opaque: false, matrix: [0, 0, 0, 0, 1, 0, 0, 0, 0], fragmentSource: { Convolute_3_1: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[9];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 0);\nfor (float h = 0.0; h < 3.0; h+=1.0) {\nfor (float w = 0.0; w < 3.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 1), uStepH * (h - 1));\ncolor += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 3.0 + w)];\n}\n}\ngl_FragColor = color;\n}", Convolute_3_0: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[9];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 1);\nfor (float h = 0.0; h < 3.0; h+=1.0) {\nfor (float w = 0.0; w < 3.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 1.0), uStepH * (h - 1.0));\ncolor.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 3.0 + w)];\n}\n}\nfloat alpha = texture2D(uTexture, vTexCoord).a;\ngl_FragColor = color;\ngl_FragColor.a = alpha;\n}", Convolute_5_1: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[25];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 0);\nfor (float h = 0.0; h < 5.0; h+=1.0) {\nfor (float w = 0.0; w < 5.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\ncolor += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 5.0 + w)];\n}\n}\ngl_FragColor = color;\n}", Convolute_5_0: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[25];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 1);\nfor (float h = 0.0; h < 5.0; h+=1.0) {\nfor (float w = 0.0; w < 5.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\ncolor.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 5.0 + w)];\n}\n}\nfloat alpha = texture2D(uTexture, vTexCoord).a;\ngl_FragColor = color;\ngl_FragColor.a = alpha;\n}", Convolute_7_1: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[49];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 0);\nfor (float h = 0.0; h < 7.0; h+=1.0) {\nfor (float w = 0.0; w < 7.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\ncolor += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 7.0 + w)];\n}\n}\ngl_FragColor = color;\n}", Convolute_7_0: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[49];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 1);\nfor (float h = 0.0; h < 7.0; h+=1.0) {\nfor (float w = 0.0; w < 7.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\ncolor.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 7.0 + w)];\n}\n}\nfloat alpha = texture2D(uTexture, vTexCoord).a;\ngl_FragColor = color;\ngl_FragColor.a = alpha;\n}", Convolute_9_1: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[81];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 0);\nfor (float h = 0.0; h < 9.0; h+=1.0) {\nfor (float w = 0.0; w < 9.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\ncolor += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 9.0 + w)];\n}\n}\ngl_FragColor = color;\n}", Convolute_9_0: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[81];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 1);\nfor (float h = 0.0; h < 9.0; h+=1.0) {\nfor (float w = 0.0; w < 9.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\ncolor.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 9.0 + w)];\n}\n}\nfloat alpha = texture2D(uTexture, vTexCoord).a;\ngl_FragColor = color;\ngl_FragColor.a = alpha;\n}" }, retrieveShader: function(t4) {
      var e4 = Math.sqrt(this.matrix.length), i4 = this.type + "_" + e4 + "_" + (this.opaque ? 1 : 0), r5 = this.fragmentSource[i4];
      return t4.programCache.hasOwnProperty(i4) || (t4.programCache[i4] = this.createProgram(t4.context, r5)), t4.programCache[i4];
    }, applyTo2d: function(t4) {
      var e4, i4, r5, n5, s4, o4, a4, h4, l4, c4, u4, d4, f4, g4 = t4.imageData, p4 = g4.data, m4 = this.matrix, v4 = Math.round(Math.sqrt(m4.length)), _4 = Math.floor(v4 / 2), y4 = g4.width, b4 = g4.height, w4 = t4.ctx.createImageData(y4, b4), C4 = w4.data, S4 = this.opaque ? 1 : 0;
      for (u4 = 0; u4 < b4; u4++) for (c4 = 0; c4 < y4; c4++) {
        for (s4 = 4 * (u4 * y4 + c4), e4 = 0, i4 = 0, r5 = 0, n5 = 0, f4 = 0; f4 < v4; f4++) for (d4 = 0; d4 < v4; d4++) o4 = c4 + d4 - _4, (a4 = u4 + f4 - _4) < 0 || a4 >= b4 || o4 < 0 || o4 >= y4 || (h4 = 4 * (a4 * y4 + o4), l4 = m4[f4 * v4 + d4], e4 += p4[h4] * l4, i4 += p4[h4 + 1] * l4, r5 += p4[h4 + 2] * l4, S4 || (n5 += p4[h4 + 3] * l4));
        C4[s4] = e4, C4[s4 + 1] = i4, C4[s4 + 2] = r5, C4[s4 + 3] = S4 ? p4[s4 + 3] : n5;
      }
      t4.imageData = w4;
    }, getUniformLocations: function(t4, e4) {
      return { uMatrix: t4.getUniformLocation(e4, "uMatrix"), uOpaque: t4.getUniformLocation(e4, "uOpaque"), uHalfSize: t4.getUniformLocation(e4, "uHalfSize"), uSize: t4.getUniformLocation(e4, "uSize") };
    }, sendUniformData: function(t4, e4) {
      t4.uniform1fv(e4.uMatrix, this.matrix);
    }, toObject: function() {
      return i3(this.callSuper("toObject"), { opaque: this.opaque, matrix: this.matrix });
    } }), e3.Image.filters.Convolute.fromObject = e3.Image.filters.BaseFilter.fromObject;
  }(e2), function(t3) {
    var e3 = t3.fabric || (t3.fabric = {}), i3 = e3.Image.filters, r4 = e3.util.createClass;
    i3.Grayscale = r4(i3.BaseFilter, { type: "Grayscale", fragmentSource: { average: "precision highp float;\nuniform sampler2D uTexture;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nfloat average = (color.r + color.b + color.g) / 3.0;\ngl_FragColor = vec4(average, average, average, color.a);\n}", lightness: "precision highp float;\nuniform sampler2D uTexture;\nuniform int uMode;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 col = texture2D(uTexture, vTexCoord);\nfloat average = (max(max(col.r, col.g),col.b) + min(min(col.r, col.g),col.b)) / 2.0;\ngl_FragColor = vec4(average, average, average, col.a);\n}", luminosity: "precision highp float;\nuniform sampler2D uTexture;\nuniform int uMode;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 col = texture2D(uTexture, vTexCoord);\nfloat average = 0.21 * col.r + 0.72 * col.g + 0.07 * col.b;\ngl_FragColor = vec4(average, average, average, col.a);\n}" }, mode: "average", mainParameter: "mode", applyTo2d: function(t4) {
      var e4, i4, r5 = t4.imageData.data, n4 = r5.length, s4 = this.mode;
      for (e4 = 0; e4 < n4; e4 += 4) "average" === s4 ? i4 = (r5[e4] + r5[e4 + 1] + r5[e4 + 2]) / 3 : "lightness" === s4 ? i4 = (Math.min(r5[e4], r5[e4 + 1], r5[e4 + 2]) + Math.max(r5[e4], r5[e4 + 1], r5[e4 + 2])) / 2 : "luminosity" === s4 && (i4 = 0.21 * r5[e4] + 0.72 * r5[e4 + 1] + 0.07 * r5[e4 + 2]), r5[e4] = i4, r5[e4 + 1] = i4, r5[e4 + 2] = i4;
    }, retrieveShader: function(t4) {
      var e4 = this.type + "_" + this.mode;
      if (!t4.programCache.hasOwnProperty(e4)) {
        var i4 = this.fragmentSource[this.mode];
        t4.programCache[e4] = this.createProgram(t4.context, i4);
      }
      return t4.programCache[e4];
    }, getUniformLocations: function(t4, e4) {
      return { uMode: t4.getUniformLocation(e4, "uMode") };
    }, sendUniformData: function(t4, e4) {
      t4.uniform1i(e4.uMode, 1);
    }, isNeutralState: function() {
      return false;
    } }), e3.Image.filters.Grayscale.fromObject = e3.Image.filters.BaseFilter.fromObject;
  }(e2), function(t3) {
    var e3 = t3.fabric || (t3.fabric = {}), i3 = e3.Image.filters, r4 = e3.util.createClass;
    i3.Invert = r4(i3.BaseFilter, { type: "Invert", fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform int uInvert;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nif (uInvert == 1) {\ngl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,color.a);\n} else {\ngl_FragColor = color;\n}\n}", invert: true, mainParameter: "invert", applyTo2d: function(t4) {
      var e4, i4 = t4.imageData.data, r5 = i4.length;
      for (e4 = 0; e4 < r5; e4 += 4) i4[e4] = 255 - i4[e4], i4[e4 + 1] = 255 - i4[e4 + 1], i4[e4 + 2] = 255 - i4[e4 + 2];
    }, isNeutralState: function() {
      return !this.invert;
    }, getUniformLocations: function(t4, e4) {
      return { uInvert: t4.getUniformLocation(e4, "uInvert") };
    }, sendUniformData: function(t4, e4) {
      t4.uniform1i(e4.uInvert, this.invert);
    } }), e3.Image.filters.Invert.fromObject = e3.Image.filters.BaseFilter.fromObject;
  }(e2), function(t3) {
    var e3 = t3.fabric || (t3.fabric = {}), i3 = e3.util.object.extend, r4 = e3.Image.filters, n4 = e3.util.createClass;
    r4.Noise = n4(r4.BaseFilter, { type: "Noise", fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uStepH;\nuniform float uNoise;\nuniform float uSeed;\nvarying vec2 vTexCoord;\nfloat rand(vec2 co, float seed, float vScale) {\nreturn fract(sin(dot(co.xy * vScale ,vec2(12.9898 , 78.233))) * 43758.5453 * (seed + 0.01) / 2.0);\n}\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\ncolor.rgb += (0.5 - rand(vTexCoord, uSeed, 0.1 / uStepH)) * uNoise;\ngl_FragColor = color;\n}", mainParameter: "noise", noise: 0, applyTo2d: function(t4) {
      if (0 !== this.noise) {
        var e4, i4, r5 = t4.imageData.data, n5 = r5.length, s4 = this.noise;
        for (e4 = 0, n5 = r5.length; e4 < n5; e4 += 4) i4 = (0.5 - Math.random()) * s4, r5[e4] += i4, r5[e4 + 1] += i4, r5[e4 + 2] += i4;
      }
    }, getUniformLocations: function(t4, e4) {
      return { uNoise: t4.getUniformLocation(e4, "uNoise"), uSeed: t4.getUniformLocation(e4, "uSeed") };
    }, sendUniformData: function(t4, e4) {
      t4.uniform1f(e4.uNoise, this.noise / 255), t4.uniform1f(e4.uSeed, Math.random());
    }, toObject: function() {
      return i3(this.callSuper("toObject"), { noise: this.noise });
    } }), e3.Image.filters.Noise.fromObject = e3.Image.filters.BaseFilter.fromObject;
  }(e2), function(t3) {
    var e3 = t3.fabric || (t3.fabric = {}), i3 = e3.Image.filters, r4 = e3.util.createClass;
    i3.Pixelate = r4(i3.BaseFilter, { type: "Pixelate", blocksize: 4, mainParameter: "blocksize", fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uBlocksize;\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nfloat blockW = uBlocksize * uStepW;\nfloat blockH = uBlocksize * uStepW;\nint posX = int(vTexCoord.x / blockW);\nint posY = int(vTexCoord.y / blockH);\nfloat fposX = float(posX);\nfloat fposY = float(posY);\nvec2 squareCoords = vec2(fposX * blockW, fposY * blockH);\nvec4 color = texture2D(uTexture, squareCoords);\ngl_FragColor = color;\n}", applyTo2d: function(t4) {
      var e4, i4, r5, n4, s4, o4, a4, h4, l4, c4, u4, d4 = t4.imageData, f4 = d4.data, g4 = d4.height, p4 = d4.width;
      for (i4 = 0; i4 < g4; i4 += this.blocksize) for (r5 = 0; r5 < p4; r5 += this.blocksize) for (n4 = f4[e4 = 4 * i4 * p4 + 4 * r5], s4 = f4[e4 + 1], o4 = f4[e4 + 2], a4 = f4[e4 + 3], c4 = Math.min(i4 + this.blocksize, g4), u4 = Math.min(r5 + this.blocksize, p4), h4 = i4; h4 < c4; h4++) for (l4 = r5; l4 < u4; l4++) f4[e4 = 4 * h4 * p4 + 4 * l4] = n4, f4[e4 + 1] = s4, f4[e4 + 2] = o4, f4[e4 + 3] = a4;
    }, isNeutralState: function() {
      return 1 === this.blocksize;
    }, getUniformLocations: function(t4, e4) {
      return { uBlocksize: t4.getUniformLocation(e4, "uBlocksize"), uStepW: t4.getUniformLocation(e4, "uStepW"), uStepH: t4.getUniformLocation(e4, "uStepH") };
    }, sendUniformData: function(t4, e4) {
      t4.uniform1f(e4.uBlocksize, this.blocksize);
    } }), e3.Image.filters.Pixelate.fromObject = e3.Image.filters.BaseFilter.fromObject;
  }(e2), function(t3) {
    var e3 = t3.fabric || (t3.fabric = {}), i3 = e3.util.object.extend, r4 = e3.Image.filters, n4 = e3.util.createClass;
    r4.RemoveColor = n4(r4.BaseFilter, { type: "RemoveColor", color: "#FFFFFF", fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform vec4 uLow;\nuniform vec4 uHigh;\nvarying vec2 vTexCoord;\nvoid main() {\ngl_FragColor = texture2D(uTexture, vTexCoord);\nif(all(greaterThan(gl_FragColor.rgb,uLow.rgb)) && all(greaterThan(uHigh.rgb,gl_FragColor.rgb))) {\ngl_FragColor.a = 0.0;\n}\n}", distance: 0.02, useAlpha: false, applyTo2d: function(t4) {
      var i4, r5, n5, s4, o4 = t4.imageData.data, a4 = 255 * this.distance, h4 = new e3.Color(this.color).getSource(), l4 = [h4[0] - a4, h4[1] - a4, h4[2] - a4], c4 = [h4[0] + a4, h4[1] + a4, h4[2] + a4];
      for (i4 = 0; i4 < o4.length; i4 += 4) r5 = o4[i4], n5 = o4[i4 + 1], s4 = o4[i4 + 2], r5 > l4[0] && n5 > l4[1] && s4 > l4[2] && r5 < c4[0] && n5 < c4[1] && s4 < c4[2] && (o4[i4 + 3] = 0);
    }, getUniformLocations: function(t4, e4) {
      return { uLow: t4.getUniformLocation(e4, "uLow"), uHigh: t4.getUniformLocation(e4, "uHigh") };
    }, sendUniformData: function(t4, i4) {
      var r5 = new e3.Color(this.color).getSource(), n5 = parseFloat(this.distance), s4 = [0 + r5[0] / 255 - n5, 0 + r5[1] / 255 - n5, 0 + r5[2] / 255 - n5, 1], o4 = [r5[0] / 255 + n5, r5[1] / 255 + n5, r5[2] / 255 + n5, 1];
      t4.uniform4fv(i4.uLow, s4), t4.uniform4fv(i4.uHigh, o4);
    }, toObject: function() {
      return i3(this.callSuper("toObject"), { color: this.color, distance: this.distance });
    } }), e3.Image.filters.RemoveColor.fromObject = e3.Image.filters.BaseFilter.fromObject;
  }(e2), function(t3) {
    var e3 = t3.fabric || (t3.fabric = {}), i3 = e3.Image.filters, r4 = e3.util.createClass, n4 = { Brownie: [0.5997, 0.34553, -0.27082, 0, 0.186, -0.0377, 0.86095, 0.15059, 0, -0.1449, 0.24113, -0.07441, 0.44972, 0, -0.02965, 0, 0, 0, 1, 0], Vintage: [0.62793, 0.32021, -0.03965, 0, 0.03784, 0.02578, 0.64411, 0.03259, 0, 0.02926, 0.0466, -0.08512, 0.52416, 0, 0.02023, 0, 0, 0, 1, 0], Kodachrome: [1.12855, -0.39673, -0.03992, 0, 0.24991, -0.16404, 1.08352, -0.05498, 0, 0.09698, -0.16786, -0.56034, 1.60148, 0, 0.13972, 0, 0, 0, 1, 0], Technicolor: [1.91252, -0.85453, -0.09155, 0, 0.04624, -0.30878, 1.76589, -0.10601, 0, -0.27589, -0.2311, -0.75018, 1.84759, 0, 0.12137, 0, 0, 0, 1, 0], Polaroid: [1.438, -0.062, -0.062, 0, 0, -0.122, 1.378, -0.122, 0, 0, -0.016, -0.016, 1.483, 0, 0, 0, 0, 0, 1, 0], Sepia: [0.393, 0.769, 0.189, 0, 0, 0.349, 0.686, 0.168, 0, 0, 0.272, 0.534, 0.131, 0, 0, 0, 0, 0, 1, 0], BlackWhite: [1.5, 1.5, 1.5, 0, -1, 1.5, 1.5, 1.5, 0, -1, 1.5, 1.5, 1.5, 0, -1, 0, 0, 0, 1, 0] };
    for (var s4 in n4) i3[s4] = r4(i3.ColorMatrix, { type: s4, matrix: n4[s4], mainParameter: false, colorsOnly: true }), e3.Image.filters[s4].fromObject = e3.Image.filters.BaseFilter.fromObject;
  }(e2), function(t3) {
    var e3 = t3.fabric, i3 = e3.Image.filters, r4 = e3.util.createClass;
    i3.BlendColor = r4(i3.BaseFilter, { type: "BlendColor", color: "#F95C63", mode: "multiply", alpha: 1, fragmentSource: { multiply: "gl_FragColor.rgb *= uColor.rgb;\n", screen: "gl_FragColor.rgb = 1.0 - (1.0 - gl_FragColor.rgb) * (1.0 - uColor.rgb);\n", add: "gl_FragColor.rgb += uColor.rgb;\n", diff: "gl_FragColor.rgb = abs(gl_FragColor.rgb - uColor.rgb);\n", subtract: "gl_FragColor.rgb -= uColor.rgb;\n", lighten: "gl_FragColor.rgb = max(gl_FragColor.rgb, uColor.rgb);\n", darken: "gl_FragColor.rgb = min(gl_FragColor.rgb, uColor.rgb);\n", exclusion: "gl_FragColor.rgb += uColor.rgb - 2.0 * (uColor.rgb * gl_FragColor.rgb);\n", overlay: "if (uColor.r < 0.5) {\ngl_FragColor.r *= 2.0 * uColor.r;\n} else {\ngl_FragColor.r = 1.0 - 2.0 * (1.0 - gl_FragColor.r) * (1.0 - uColor.r);\n}\nif (uColor.g < 0.5) {\ngl_FragColor.g *= 2.0 * uColor.g;\n} else {\ngl_FragColor.g = 1.0 - 2.0 * (1.0 - gl_FragColor.g) * (1.0 - uColor.g);\n}\nif (uColor.b < 0.5) {\ngl_FragColor.b *= 2.0 * uColor.b;\n} else {\ngl_FragColor.b = 1.0 - 2.0 * (1.0 - gl_FragColor.b) * (1.0 - uColor.b);\n}\n", tint: "gl_FragColor.rgb *= (1.0 - uColor.a);\ngl_FragColor.rgb += uColor.rgb;\n" }, buildSource: function(t4) {
      return "precision highp float;\nuniform sampler2D uTexture;\nuniform vec4 uColor;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\ngl_FragColor = color;\nif (color.a > 0.0) {\n" + this.fragmentSource[t4] + "}\n}";
    }, retrieveShader: function(t4) {
      var e4, i4 = this.type + "_" + this.mode;
      return t4.programCache.hasOwnProperty(i4) || (e4 = this.buildSource(this.mode), t4.programCache[i4] = this.createProgram(t4.context, e4)), t4.programCache[i4];
    }, applyTo2d: function(t4) {
      var i4, r5, n4, s4, o4, a4, h4, l4 = t4.imageData.data, c4 = l4.length, u4 = 1 - this.alpha;
      i4 = (h4 = new e3.Color(this.color).getSource())[0] * this.alpha, r5 = h4[1] * this.alpha, n4 = h4[2] * this.alpha;
      for (var d4 = 0; d4 < c4; d4 += 4) switch (s4 = l4[d4], o4 = l4[d4 + 1], a4 = l4[d4 + 2], this.mode) {
        case "multiply":
          l4[d4] = s4 * i4 / 255, l4[d4 + 1] = o4 * r5 / 255, l4[d4 + 2] = a4 * n4 / 255;
          break;
        case "screen":
          l4[d4] = 255 - (255 - s4) * (255 - i4) / 255, l4[d4 + 1] = 255 - (255 - o4) * (255 - r5) / 255, l4[d4 + 2] = 255 - (255 - a4) * (255 - n4) / 255;
          break;
        case "add":
          l4[d4] = s4 + i4, l4[d4 + 1] = o4 + r5, l4[d4 + 2] = a4 + n4;
          break;
        case "diff":
        case "difference":
          l4[d4] = Math.abs(s4 - i4), l4[d4 + 1] = Math.abs(o4 - r5), l4[d4 + 2] = Math.abs(a4 - n4);
          break;
        case "subtract":
          l4[d4] = s4 - i4, l4[d4 + 1] = o4 - r5, l4[d4 + 2] = a4 - n4;
          break;
        case "darken":
          l4[d4] = Math.min(s4, i4), l4[d4 + 1] = Math.min(o4, r5), l4[d4 + 2] = Math.min(a4, n4);
          break;
        case "lighten":
          l4[d4] = Math.max(s4, i4), l4[d4 + 1] = Math.max(o4, r5), l4[d4 + 2] = Math.max(a4, n4);
          break;
        case "overlay":
          l4[d4] = i4 < 128 ? 2 * s4 * i4 / 255 : 255 - 2 * (255 - s4) * (255 - i4) / 255, l4[d4 + 1] = r5 < 128 ? 2 * o4 * r5 / 255 : 255 - 2 * (255 - o4) * (255 - r5) / 255, l4[d4 + 2] = n4 < 128 ? 2 * a4 * n4 / 255 : 255 - 2 * (255 - a4) * (255 - n4) / 255;
          break;
        case "exclusion":
          l4[d4] = i4 + s4 - 2 * i4 * s4 / 255, l4[d4 + 1] = r5 + o4 - 2 * r5 * o4 / 255, l4[d4 + 2] = n4 + a4 - 2 * n4 * a4 / 255;
          break;
        case "tint":
          l4[d4] = i4 + s4 * u4, l4[d4 + 1] = r5 + o4 * u4, l4[d4 + 2] = n4 + a4 * u4;
      }
    }, getUniformLocations: function(t4, e4) {
      return { uColor: t4.getUniformLocation(e4, "uColor") };
    }, sendUniformData: function(t4, i4) {
      var r5 = new e3.Color(this.color).getSource();
      r5[0] = this.alpha * r5[0] / 255, r5[1] = this.alpha * r5[1] / 255, r5[2] = this.alpha * r5[2] / 255, r5[3] = this.alpha, t4.uniform4fv(i4.uColor, r5);
    }, toObject: function() {
      return { type: this.type, color: this.color, mode: this.mode, alpha: this.alpha };
    } }), e3.Image.filters.BlendColor.fromObject = e3.Image.filters.BaseFilter.fromObject;
  }(e2), function(t3) {
    var e3 = t3.fabric, i3 = e3.Image.filters, r4 = e3.util.createClass;
    i3.BlendImage = r4(i3.BaseFilter, { type: "BlendImage", image: null, mode: "multiply", alpha: 1, vertexSource: "attribute vec2 aPosition;\nvarying vec2 vTexCoord;\nvarying vec2 vTexCoord2;\nuniform mat3 uTransformMatrix;\nvoid main() {\nvTexCoord = aPosition;\nvTexCoord2 = (uTransformMatrix * vec3(aPosition, 1.0)).xy;\ngl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\n}", fragmentSource: { multiply: "precision highp float;\nuniform sampler2D uTexture;\nuniform sampler2D uImage;\nuniform vec4 uColor;\nvarying vec2 vTexCoord;\nvarying vec2 vTexCoord2;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nvec4 color2 = texture2D(uImage, vTexCoord2);\ncolor.rgba *= color2.rgba;\ngl_FragColor = color;\n}", mask: "precision highp float;\nuniform sampler2D uTexture;\nuniform sampler2D uImage;\nuniform vec4 uColor;\nvarying vec2 vTexCoord;\nvarying vec2 vTexCoord2;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nvec4 color2 = texture2D(uImage, vTexCoord2);\ncolor.a = color2.a;\ngl_FragColor = color;\n}" }, retrieveShader: function(t4) {
      var e4 = this.type + "_" + this.mode, i4 = this.fragmentSource[this.mode];
      return t4.programCache.hasOwnProperty(e4) || (t4.programCache[e4] = this.createProgram(t4.context, i4)), t4.programCache[e4];
    }, applyToWebGL: function(t4) {
      var e4 = t4.context, i4 = this.createTexture(t4.filterBackend, this.image);
      this.bindAdditionalTexture(e4, i4, e4.TEXTURE1), this.callSuper("applyToWebGL", t4), this.unbindAdditionalTexture(e4, e4.TEXTURE1);
    }, createTexture: function(t4, e4) {
      return t4.getCachedTexture(e4.cacheKey, e4._element);
    }, calculateMatrix: function() {
      var t4 = this.image, e4 = t4._element.width, i4 = t4._element.height;
      return [1 / t4.scaleX, 0, 0, 0, 1 / t4.scaleY, 0, -t4.left / e4, -t4.top / i4, 1];
    }, applyTo2d: function(t4) {
      var i4, r5, n4, s4, o4, a4, h4, l4, c4, u4, d4, f4 = t4.imageData, g4 = t4.filterBackend.resources, p4 = f4.data, m4 = p4.length, v4 = f4.width, _4 = f4.height, y4 = this.image;
      g4.blendImage || (g4.blendImage = e3.util.createCanvasElement()), u4 = (c4 = g4.blendImage).getContext("2d"), c4.width !== v4 || c4.height !== _4 ? (c4.width = v4, c4.height = _4) : u4.clearRect(0, 0, v4, _4), u4.setTransform(y4.scaleX, 0, 0, y4.scaleY, y4.left, y4.top), u4.drawImage(y4._element, 0, 0, v4, _4), d4 = u4.getImageData(0, 0, v4, _4).data;
      for (var b4 = 0; b4 < m4; b4 += 4) switch (o4 = p4[b4], a4 = p4[b4 + 1], h4 = p4[b4 + 2], l4 = p4[b4 + 3], i4 = d4[b4], r5 = d4[b4 + 1], n4 = d4[b4 + 2], s4 = d4[b4 + 3], this.mode) {
        case "multiply":
          p4[b4] = o4 * i4 / 255, p4[b4 + 1] = a4 * r5 / 255, p4[b4 + 2] = h4 * n4 / 255, p4[b4 + 3] = l4 * s4 / 255;
          break;
        case "mask":
          p4[b4 + 3] = s4;
      }
    }, getUniformLocations: function(t4, e4) {
      return { uTransformMatrix: t4.getUniformLocation(e4, "uTransformMatrix"), uImage: t4.getUniformLocation(e4, "uImage") };
    }, sendUniformData: function(t4, e4) {
      var i4 = this.calculateMatrix();
      t4.uniform1i(e4.uImage, 1), t4.uniformMatrix3fv(e4.uTransformMatrix, false, i4);
    }, toObject: function() {
      return { type: this.type, image: this.image && this.image.toObject(), mode: this.mode, alpha: this.alpha };
    } }), e3.Image.filters.BlendImage.fromObject = function(t4, i4) {
      e3.Image.fromObject(t4.image, function(r5) {
        var n4 = e3.util.object.clone(t4);
        n4.image = r5, i4(new e3.Image.filters.BlendImage(n4));
      });
    };
  }(e2), function(t3) {
    var e3 = t3.fabric || (t3.fabric = {}), i3 = Math.pow, r4 = Math.floor, n4 = Math.sqrt, s4 = Math.abs, o4 = Math.round, a4 = Math.sin, h4 = Math.ceil, l4 = e3.Image.filters, c4 = e3.util.createClass;
    l4.Resize = c4(l4.BaseFilter, { type: "Resize", resizeType: "hermite", scaleX: 1, scaleY: 1, lanczosLobes: 3, getUniformLocations: function(t4, e4) {
      return { uDelta: t4.getUniformLocation(e4, "uDelta"), uTaps: t4.getUniformLocation(e4, "uTaps") };
    }, sendUniformData: function(t4, e4) {
      t4.uniform2fv(e4.uDelta, this.horizontal ? [1 / this.width, 0] : [0, 1 / this.height]), t4.uniform1fv(e4.uTaps, this.taps);
    }, retrieveShader: function(t4) {
      var e4 = this.getFilterWindow(), i4 = this.type + "_" + e4;
      if (!t4.programCache.hasOwnProperty(i4)) {
        var r5 = this.generateShader(e4);
        t4.programCache[i4] = this.createProgram(t4.context, r5);
      }
      return t4.programCache[i4];
    }, getFilterWindow: function() {
      var t4 = this.tempScale;
      return Math.ceil(this.lanczosLobes / t4);
    }, getTaps: function() {
      for (var t4 = this.lanczosCreate(this.lanczosLobes), e4 = this.tempScale, i4 = this.getFilterWindow(), r5 = new Array(i4), n5 = 1; n5 <= i4; n5++) r5[n5 - 1] = t4(n5 * e4);
      return r5;
    }, generateShader: function(t4) {
      for (var e4 = new Array(t4), i4 = this.fragmentSourceTOP, r5 = 1; r5 <= t4; r5++) e4[r5 - 1] = r5 + ".0 * uDelta";
      return i4 += "uniform float uTaps[" + t4 + "];\n", i4 += "void main() {\n", i4 += "  vec4 color = texture2D(uTexture, vTexCoord);\n", i4 += "  float sum = 1.0;\n", e4.forEach(function(t5, e5) {
        i4 += "  color += texture2D(uTexture, vTexCoord + " + t5 + ") * uTaps[" + e5 + "];\n", i4 += "  color += texture2D(uTexture, vTexCoord - " + t5 + ") * uTaps[" + e5 + "];\n", i4 += "  sum += 2.0 * uTaps[" + e5 + "];\n";
      }), i4 += "  gl_FragColor = color / sum;\n", i4 += "}";
    }, fragmentSourceTOP: "precision highp float;\nuniform sampler2D uTexture;\nuniform vec2 uDelta;\nvarying vec2 vTexCoord;\n", applyTo: function(t4) {
      t4.webgl ? (t4.passes++, this.width = t4.sourceWidth, this.horizontal = true, this.dW = Math.round(this.width * this.scaleX), this.dH = t4.sourceHeight, this.tempScale = this.dW / this.width, this.taps = this.getTaps(), t4.destinationWidth = this.dW, this._setupFrameBuffer(t4), this.applyToWebGL(t4), this._swapTextures(t4), t4.sourceWidth = t4.destinationWidth, this.height = t4.sourceHeight, this.horizontal = false, this.dH = Math.round(this.height * this.scaleY), this.tempScale = this.dH / this.height, this.taps = this.getTaps(), t4.destinationHeight = this.dH, this._setupFrameBuffer(t4), this.applyToWebGL(t4), this._swapTextures(t4), t4.sourceHeight = t4.destinationHeight) : this.applyTo2d(t4);
    }, isNeutralState: function() {
      return 1 === this.scaleX && 1 === this.scaleY;
    }, lanczosCreate: function(t4) {
      return function(e4) {
        if (e4 >= t4 || e4 <= -t4) return 0;
        if (e4 < 11920929e-14 && e4 > -11920929e-14) return 1;
        var i4 = (e4 *= Math.PI) / t4;
        return a4(e4) / e4 * a4(i4) / i4;
      };
    }, applyTo2d: function(t4) {
      var e4 = t4.imageData, i4 = this.scaleX, r5 = this.scaleY;
      this.rcpScaleX = 1 / i4, this.rcpScaleY = 1 / r5;
      var n5, s5 = e4.width, a5 = e4.height, h5 = o4(s5 * i4), l5 = o4(a5 * r5);
      "sliceHack" === this.resizeType ? n5 = this.sliceByTwo(t4, s5, a5, h5, l5) : "hermite" === this.resizeType ? n5 = this.hermiteFastResize(t4, s5, a5, h5, l5) : "bilinear" === this.resizeType ? n5 = this.bilinearFiltering(t4, s5, a5, h5, l5) : "lanczos" === this.resizeType && (n5 = this.lanczosResize(t4, s5, a5, h5, l5)), t4.imageData = n5;
    }, sliceByTwo: function(t4, i4, n5, s5, o5) {
      var a5, h5, l5 = t4.imageData, c5 = 0.5, u4 = false, d4 = false, f4 = i4 * c5, g4 = n5 * c5, p4 = e3.filterBackend.resources, m4 = 0, v4 = 0, _4 = i4, y4 = 0;
      for (p4.sliceByTwo || (p4.sliceByTwo = document.createElement("canvas")), ((a5 = p4.sliceByTwo).width < 1.5 * i4 || a5.height < n5) && (a5.width = 1.5 * i4, a5.height = n5), (h5 = a5.getContext("2d")).clearRect(0, 0, 1.5 * i4, n5), h5.putImageData(l5, 0, 0), s5 = r4(s5), o5 = r4(o5); !u4 || !d4; ) i4 = f4, n5 = g4, s5 < r4(f4 * c5) ? f4 = r4(f4 * c5) : (f4 = s5, u4 = true), o5 < r4(g4 * c5) ? g4 = r4(g4 * c5) : (g4 = o5, d4 = true), h5.drawImage(a5, m4, v4, i4, n5, _4, y4, f4, g4), m4 = _4, v4 = y4, y4 += g4;
      return h5.getImageData(m4, v4, s5, o5);
    }, lanczosResize: function(t4, e4, o5, a5, l5) {
      var c5 = t4.imageData.data, u4 = t4.ctx.createImageData(a5, l5), d4 = u4.data, f4 = this.lanczosCreate(this.lanczosLobes), g4 = this.rcpScaleX, p4 = this.rcpScaleY, m4 = 2 / this.rcpScaleX, v4 = 2 / this.rcpScaleY, _4 = h4(g4 * this.lanczosLobes / 2), y4 = h4(p4 * this.lanczosLobes / 2), b4 = {}, w4 = {}, C4 = {};
      return function t5(h5) {
        var S4, x4, T4, O4, E4, D3, M3, I3, L3, F2, k2;
        for (w4.x = (h5 + 0.5) * g4, C4.x = r4(w4.x), S4 = 0; S4 < l5; S4++) {
          for (w4.y = (S4 + 0.5) * p4, C4.y = r4(w4.y), E4 = 0, D3 = 0, M3 = 0, I3 = 0, L3 = 0, x4 = C4.x - _4; x4 <= C4.x + _4; x4++) if (!(x4 < 0 || x4 >= e4)) {
            F2 = r4(1e3 * s4(x4 - w4.x)), b4[F2] || (b4[F2] = {});
            for (var P2 = C4.y - y4; P2 <= C4.y + y4; P2++) P2 < 0 || P2 >= o5 || (k2 = r4(1e3 * s4(P2 - w4.y)), b4[F2][k2] || (b4[F2][k2] = f4(n4(i3(F2 * m4, 2) + i3(k2 * v4, 2)) / 1e3)), (T4 = b4[F2][k2]) > 0 && (E4 += T4, D3 += T4 * c5[O4 = 4 * (P2 * e4 + x4)], M3 += T4 * c5[O4 + 1], I3 += T4 * c5[O4 + 2], L3 += T4 * c5[O4 + 3]));
          }
          d4[O4 = 4 * (S4 * a5 + h5)] = D3 / E4, d4[O4 + 1] = M3 / E4, d4[O4 + 2] = I3 / E4, d4[O4 + 3] = L3 / E4;
        }
        return ++h5 < a5 ? t5(h5) : u4;
      }(0);
    }, bilinearFiltering: function(t4, e4, i4, n5, s5) {
      var o5, a5, h5, l5, c5, u4, d4, f4, g4, p4 = 0, m4 = this.rcpScaleX, v4 = this.rcpScaleY, _4 = 4 * (e4 - 1), y4 = t4.imageData.data, b4 = t4.ctx.createImageData(n5, s5), w4 = b4.data;
      for (h5 = 0; h5 < s5; h5++) for (l5 = 0; l5 < n5; l5++) for (c5 = m4 * l5 - (o5 = r4(m4 * l5)), u4 = v4 * h5 - (a5 = r4(v4 * h5)), g4 = 4 * (a5 * e4 + o5), d4 = 0; d4 < 4; d4++) f4 = y4[g4 + d4] * (1 - c5) * (1 - u4) + y4[g4 + 4 + d4] * c5 * (1 - u4) + y4[g4 + _4 + d4] * u4 * (1 - c5) + y4[g4 + _4 + 4 + d4] * c5 * u4, w4[p4++] = f4;
      return b4;
    }, hermiteFastResize: function(t4, e4, i4, o5, a5) {
      for (var l5 = this.rcpScaleX, c5 = this.rcpScaleY, u4 = h4(l5 / 2), d4 = h4(c5 / 2), f4 = t4.imageData.data, g4 = t4.ctx.createImageData(o5, a5), p4 = g4.data, m4 = 0; m4 < a5; m4++) for (var v4 = 0; v4 < o5; v4++) {
        for (var _4 = 4 * (v4 + m4 * o5), y4 = 0, b4 = 0, w4 = 0, C4 = 0, S4 = 0, x4 = 0, T4 = 0, O4 = (m4 + 0.5) * c5, E4 = r4(m4 * c5); E4 < (m4 + 1) * c5; E4++) for (var D3 = s4(O4 - (E4 + 0.5)) / d4, M3 = (v4 + 0.5) * l5, I3 = D3 * D3, L3 = r4(v4 * l5); L3 < (v4 + 1) * l5; L3++) {
          var F2 = s4(M3 - (L3 + 0.5)) / u4, k2 = n4(I3 + F2 * F2);
          k2 > 1 && k2 < -1 || (y4 = 2 * k2 * k2 * k2 - 3 * k2 * k2 + 1) > 0 && (T4 += y4 * f4[3 + (F2 = 4 * (L3 + E4 * e4))], w4 += y4, f4[F2 + 3] < 255 && (y4 = y4 * f4[F2 + 3] / 250), C4 += y4 * f4[F2], S4 += y4 * f4[F2 + 1], x4 += y4 * f4[F2 + 2], b4 += y4);
        }
        p4[_4] = C4 / b4, p4[_4 + 1] = S4 / b4, p4[_4 + 2] = x4 / b4, p4[_4 + 3] = T4 / w4;
      }
      return g4;
    }, toObject: function() {
      return { type: this.type, scaleX: this.scaleX, scaleY: this.scaleY, resizeType: this.resizeType, lanczosLobes: this.lanczosLobes };
    } }), e3.Image.filters.Resize.fromObject = e3.Image.filters.BaseFilter.fromObject;
  }(e2), function(t3) {
    var e3 = t3.fabric || (t3.fabric = {}), i3 = e3.Image.filters, r4 = e3.util.createClass;
    i3.Contrast = r4(i3.BaseFilter, { type: "Contrast", fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uContrast;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nfloat contrastF = 1.015 * (uContrast + 1.0) / (1.0 * (1.015 - uContrast));\ncolor.rgb = contrastF * (color.rgb - 0.5) + 0.5;\ngl_FragColor = color;\n}", contrast: 0, mainParameter: "contrast", applyTo2d: function(t4) {
      if (0 !== this.contrast) {
        var e4, i4 = t4.imageData.data, r5 = i4.length, n4 = Math.floor(255 * this.contrast), s4 = 259 * (n4 + 255) / (255 * (259 - n4));
        for (e4 = 0; e4 < r5; e4 += 4) i4[e4] = s4 * (i4[e4] - 128) + 128, i4[e4 + 1] = s4 * (i4[e4 + 1] - 128) + 128, i4[e4 + 2] = s4 * (i4[e4 + 2] - 128) + 128;
      }
    }, getUniformLocations: function(t4, e4) {
      return { uContrast: t4.getUniformLocation(e4, "uContrast") };
    }, sendUniformData: function(t4, e4) {
      t4.uniform1f(e4.uContrast, this.contrast);
    } }), e3.Image.filters.Contrast.fromObject = e3.Image.filters.BaseFilter.fromObject;
  }(e2), function(t3) {
    var e3 = t3.fabric || (t3.fabric = {}), i3 = e3.Image.filters, r4 = e3.util.createClass;
    i3.Saturation = r4(i3.BaseFilter, { type: "Saturation", fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uSaturation;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nfloat rgMax = max(color.r, color.g);\nfloat rgbMax = max(rgMax, color.b);\ncolor.r += rgbMax != color.r ? (rgbMax - color.r) * uSaturation : 0.00;\ncolor.g += rgbMax != color.g ? (rgbMax - color.g) * uSaturation : 0.00;\ncolor.b += rgbMax != color.b ? (rgbMax - color.b) * uSaturation : 0.00;\ngl_FragColor = color;\n}", saturation: 0, mainParameter: "saturation", applyTo2d: function(t4) {
      if (0 !== this.saturation) {
        var e4, i4, r5 = t4.imageData.data, n4 = r5.length, s4 = -this.saturation;
        for (e4 = 0; e4 < n4; e4 += 4) i4 = Math.max(r5[e4], r5[e4 + 1], r5[e4 + 2]), r5[e4] += i4 !== r5[e4] ? (i4 - r5[e4]) * s4 : 0, r5[e4 + 1] += i4 !== r5[e4 + 1] ? (i4 - r5[e4 + 1]) * s4 : 0, r5[e4 + 2] += i4 !== r5[e4 + 2] ? (i4 - r5[e4 + 2]) * s4 : 0;
      }
    }, getUniformLocations: function(t4, e4) {
      return { uSaturation: t4.getUniformLocation(e4, "uSaturation") };
    }, sendUniformData: function(t4, e4) {
      t4.uniform1f(e4.uSaturation, -this.saturation);
    } }), e3.Image.filters.Saturation.fromObject = e3.Image.filters.BaseFilter.fromObject;
  }(e2), function(t3) {
    var e3 = t3.fabric || (t3.fabric = {}), i3 = e3.Image.filters, r4 = e3.util.createClass;
    i3.Vibrance = r4(i3.BaseFilter, { type: "Vibrance", fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uVibrance;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nfloat max = max(color.r, max(color.g, color.b));\nfloat avg = (color.r + color.g + color.b) / 3.0;\nfloat amt = (abs(max - avg) * 2.0) * uVibrance;\ncolor.r += max != color.r ? (max - color.r) * amt : 0.00;\ncolor.g += max != color.g ? (max - color.g) * amt : 0.00;\ncolor.b += max != color.b ? (max - color.b) * amt : 0.00;\ngl_FragColor = color;\n}", vibrance: 0, mainParameter: "vibrance", applyTo2d: function(t4) {
      if (0 !== this.vibrance) {
        var e4, i4, r5, n4, s4 = t4.imageData.data, o4 = s4.length, a4 = -this.vibrance;
        for (e4 = 0; e4 < o4; e4 += 4) i4 = Math.max(s4[e4], s4[e4 + 1], s4[e4 + 2]), r5 = (s4[e4] + s4[e4 + 1] + s4[e4 + 2]) / 3, n4 = 2 * Math.abs(i4 - r5) / 255 * a4, s4[e4] += i4 !== s4[e4] ? (i4 - s4[e4]) * n4 : 0, s4[e4 + 1] += i4 !== s4[e4 + 1] ? (i4 - s4[e4 + 1]) * n4 : 0, s4[e4 + 2] += i4 !== s4[e4 + 2] ? (i4 - s4[e4 + 2]) * n4 : 0;
      }
    }, getUniformLocations: function(t4, e4) {
      return { uVibrance: t4.getUniformLocation(e4, "uVibrance") };
    }, sendUniformData: function(t4, e4) {
      t4.uniform1f(e4.uVibrance, -this.vibrance);
    } }), e3.Image.filters.Vibrance.fromObject = e3.Image.filters.BaseFilter.fromObject;
  }(e2), function(t3) {
    var e3 = t3.fabric || (t3.fabric = {}), i3 = e3.Image.filters, r4 = e3.util.createClass;
    i3.Blur = r4(i3.BaseFilter, { type: "Blur", fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform vec2 uDelta;\nvarying vec2 vTexCoord;\nconst float nSamples = 15.0;\nvec3 v3offset = vec3(12.9898, 78.233, 151.7182);\nfloat random(vec3 scale) {\nreturn fract(sin(dot(gl_FragCoord.xyz, scale)) * 43758.5453);\n}\nvoid main() {\nvec4 color = vec4(0.0);\nfloat total = 0.0;\nfloat offset = random(v3offset);\nfor (float t = -nSamples; t <= nSamples; t++) {\nfloat percent = (t + offset - 0.5) / nSamples;\nfloat weight = 1.0 - abs(percent);\ncolor += texture2D(uTexture, vTexCoord + uDelta * percent) * weight;\ntotal += weight;\n}\ngl_FragColor = color / total;\n}", blur: 0, mainParameter: "blur", applyTo: function(t4) {
      t4.webgl ? (this.aspectRatio = t4.sourceWidth / t4.sourceHeight, t4.passes++, this._setupFrameBuffer(t4), this.horizontal = true, this.applyToWebGL(t4), this._swapTextures(t4), this._setupFrameBuffer(t4), this.horizontal = false, this.applyToWebGL(t4), this._swapTextures(t4)) : this.applyTo2d(t4);
    }, applyTo2d: function(t4) {
      t4.imageData = this.simpleBlur(t4);
    }, simpleBlur: function(t4) {
      var i4, r5, n4 = t4.filterBackend.resources, s4 = t4.imageData.width, o4 = t4.imageData.height;
      n4.blurLayer1 || (n4.blurLayer1 = e3.util.createCanvasElement(), n4.blurLayer2 = e3.util.createCanvasElement()), i4 = n4.blurLayer1, r5 = n4.blurLayer2, i4.width === s4 && i4.height === o4 || (r5.width = i4.width = s4, r5.height = i4.height = o4);
      var a4, h4, l4, c4, u4 = i4.getContext("2d"), d4 = r5.getContext("2d"), f4 = 0.06 * this.blur * 0.5;
      for (u4.putImageData(t4.imageData, 0, 0), d4.clearRect(0, 0, s4, o4), c4 = -15; c4 <= 15; c4++) l4 = f4 * (h4 = c4 / 15) * s4 + (a4 = (Math.random() - 0.5) / 4), d4.globalAlpha = 1 - Math.abs(h4), d4.drawImage(i4, l4, a4), u4.drawImage(r5, 0, 0), d4.globalAlpha = 1, d4.clearRect(0, 0, r5.width, r5.height);
      for (c4 = -15; c4 <= 15; c4++) l4 = f4 * (h4 = c4 / 15) * o4 + (a4 = (Math.random() - 0.5) / 4), d4.globalAlpha = 1 - Math.abs(h4), d4.drawImage(i4, a4, l4), u4.drawImage(r5, 0, 0), d4.globalAlpha = 1, d4.clearRect(0, 0, r5.width, r5.height);
      t4.ctx.drawImage(i4, 0, 0);
      var g4 = t4.ctx.getImageData(0, 0, i4.width, i4.height);
      return u4.globalAlpha = 1, u4.clearRect(0, 0, i4.width, i4.height), g4;
    }, getUniformLocations: function(t4, e4) {
      return { delta: t4.getUniformLocation(e4, "uDelta") };
    }, sendUniformData: function(t4, e4) {
      var i4 = this.chooseRightDelta();
      t4.uniform2fv(e4.delta, i4);
    }, chooseRightDelta: function() {
      var t4, e4 = 1, i4 = [0, 0];
      return this.horizontal ? this.aspectRatio > 1 && (e4 = 1 / this.aspectRatio) : this.aspectRatio < 1 && (e4 = this.aspectRatio), t4 = e4 * this.blur * 0.12, this.horizontal ? i4[0] = t4 : i4[1] = t4, i4;
    } }), i3.Blur.fromObject = e3.Image.filters.BaseFilter.fromObject;
  }(e2), function(t3) {
    var e3 = t3.fabric || (t3.fabric = {}), i3 = e3.Image.filters, r4 = e3.util.createClass;
    i3.Gamma = r4(i3.BaseFilter, { type: "Gamma", fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform vec3 uGamma;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nvec3 correction = (1.0 / uGamma);\ncolor.r = pow(color.r, correction.r);\ncolor.g = pow(color.g, correction.g);\ncolor.b = pow(color.b, correction.b);\ngl_FragColor = color;\ngl_FragColor.rgb *= color.a;\n}", gamma: [1, 1, 1], mainParameter: "gamma", initialize: function(t4) {
      this.gamma = [1, 1, 1], i3.BaseFilter.prototype.initialize.call(this, t4);
    }, applyTo2d: function(t4) {
      var e4, i4 = t4.imageData.data, r5 = this.gamma, n4 = i4.length, s4 = 1 / r5[0], o4 = 1 / r5[1], a4 = 1 / r5[2];
      for (this.rVals || (this.rVals = new Uint8Array(256), this.gVals = new Uint8Array(256), this.bVals = new Uint8Array(256)), e4 = 0, n4 = 256; e4 < n4; e4++) this.rVals[e4] = 255 * Math.pow(e4 / 255, s4), this.gVals[e4] = 255 * Math.pow(e4 / 255, o4), this.bVals[e4] = 255 * Math.pow(e4 / 255, a4);
      for (e4 = 0, n4 = i4.length; e4 < n4; e4 += 4) i4[e4] = this.rVals[i4[e4]], i4[e4 + 1] = this.gVals[i4[e4 + 1]], i4[e4 + 2] = this.bVals[i4[e4 + 2]];
    }, getUniformLocations: function(t4, e4) {
      return { uGamma: t4.getUniformLocation(e4, "uGamma") };
    }, sendUniformData: function(t4, e4) {
      t4.uniform3fv(e4.uGamma, this.gamma);
    } }), e3.Image.filters.Gamma.fromObject = e3.Image.filters.BaseFilter.fromObject;
  }(e2), function(t3) {
    var e3 = t3.fabric || (t3.fabric = {}), i3 = e3.Image.filters, r4 = e3.util.createClass;
    i3.Composed = r4(i3.BaseFilter, { type: "Composed", subFilters: [], initialize: function(t4) {
      this.callSuper("initialize", t4), this.subFilters = this.subFilters.slice(0);
    }, applyTo: function(t4) {
      t4.passes += this.subFilters.length - 1, this.subFilters.forEach(function(e4) {
        e4.applyTo(t4);
      });
    }, toObject: function() {
      return e3.util.object.extend(this.callSuper("toObject"), { subFilters: this.subFilters.map(function(t4) {
        return t4.toObject();
      }) });
    }, isNeutralState: function() {
      return !this.subFilters.some(function(t4) {
        return !t4.isNeutralState();
      });
    } }), e3.Image.filters.Composed.fromObject = function(t4, i4) {
      var r5 = (t4.subFilters || []).map(function(t5) {
        return new e3.Image.filters[t5.type](t5);
      }), n4 = new e3.Image.filters.Composed({ subFilters: r5 });
      return i4 && i4(n4), n4;
    };
  }(e2), function(t3) {
    var e3 = t3.fabric || (t3.fabric = {}), i3 = e3.Image.filters, r4 = e3.util.createClass;
    i3.HueRotation = r4(i3.ColorMatrix, { type: "HueRotation", rotation: 0, mainParameter: "rotation", calculateMatrix: function() {
      var t4 = this.rotation * Math.PI, i4 = e3.util.cos(t4), r5 = e3.util.sin(t4), n4 = 1 / 3, s4 = Math.sqrt(n4) * r5, o4 = 1 - i4;
      this.matrix = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], this.matrix[0] = i4 + o4 / 3, this.matrix[1] = n4 * o4 - s4, this.matrix[2] = n4 * o4 + s4, this.matrix[5] = n4 * o4 + s4, this.matrix[6] = i4 + n4 * o4, this.matrix[7] = n4 * o4 - s4, this.matrix[10] = n4 * o4 - s4, this.matrix[11] = n4 * o4 + s4, this.matrix[12] = i4 + n4 * o4;
    }, isNeutralState: function(t4) {
      return this.calculateMatrix(), i3.BaseFilter.prototype.isNeutralState.call(this, t4);
    }, applyTo: function(t4) {
      this.calculateMatrix(), i3.BaseFilter.prototype.applyTo.call(this, t4);
    } }), e3.Image.filters.HueRotation.fromObject = e3.Image.filters.BaseFilter.fromObject;
  }(e2), function(t3) {
    var e3 = t3.fabric || (t3.fabric = {}), i3 = e3.util.object.clone;
    if (e3.Text) e3.warn("fabric.Text is already defined");
    else {
      var r4 = "fontFamily fontWeight fontSize text underline overline linethrough textAlign fontStyle lineHeight textBackgroundColor charSpacing styles direction path pathStartOffset pathSide pathAlign".split(" ");
      e3.Text = e3.util.createClass(e3.Object, { _dimensionAffectingProps: ["fontSize", "fontWeight", "fontFamily", "fontStyle", "lineHeight", "text", "charSpacing", "textAlign", "styles", "path", "pathStartOffset", "pathSide", "pathAlign"], _reNewline: /\r?\n/, _reSpacesAndTabs: /[ \t\r]/g, _reSpaceAndTab: /[ \t\r]/, _reWords: /\S+/g, type: "text", fontSize: 40, fontWeight: "normal", fontFamily: "Times New Roman", underline: false, overline: false, linethrough: false, textAlign: "left", fontStyle: "normal", lineHeight: 1.16, superscript: { size: 0.6, baseline: -0.35 }, subscript: { size: 0.6, baseline: 0.11 }, textBackgroundColor: "", stateProperties: e3.Object.prototype.stateProperties.concat(r4), cacheProperties: e3.Object.prototype.cacheProperties.concat(r4), stroke: null, shadow: null, path: null, pathStartOffset: 0, pathSide: "left", pathAlign: "baseline", _fontSizeFraction: 0.222, offsets: { underline: 0.1, linethrough: -0.315, overline: -0.88 }, _fontSizeMult: 1.13, charSpacing: 0, styles: null, _measuringContext: null, deltaY: 0, direction: "ltr", _styleProperties: ["stroke", "strokeWidth", "fill", "fontFamily", "fontSize", "fontWeight", "fontStyle", "underline", "overline", "linethrough", "deltaY", "textBackgroundColor"], __charBounds: [], CACHE_FONT_SIZE: 400, MIN_TEXT_WIDTH: 2, initialize: function(t4, e4) {
        this.styles = e4 && e4.styles || {}, this.text = t4, this.__skipDimension = true, this.callSuper("initialize", e4), this.path && this.setPathInfo(), this.__skipDimension = false, this.initDimensions(), this.setCoords(), this.setupState({ propertySet: "_dimensionAffectingProps" });
      }, setPathInfo: function() {
        var t4 = this.path;
        t4 && (t4.segmentsInfo = e3.util.getPathSegmentsInfo(t4.path));
      }, getMeasuringContext: function() {
        return e3._measuringContext || (e3._measuringContext = this.canvas && this.canvas.contextCache || e3.util.createCanvasElement().getContext("2d")), e3._measuringContext;
      }, _splitText: function() {
        var t4 = this._splitTextIntoLines(this.text);
        return this.textLines = t4.lines, this._textLines = t4.graphemeLines, this._unwrappedTextLines = t4._unwrappedLines, this._text = t4.graphemeText, t4;
      }, initDimensions: function() {
        this.__skipDimension || (this._splitText(), this._clearCache(), this.path ? (this.width = this.path.width, this.height = this.path.height) : (this.width = this.calcTextWidth() || this.cursorWidth || this.MIN_TEXT_WIDTH, this.height = this.calcTextHeight()), -1 !== this.textAlign.indexOf("justify") && this.enlargeSpaces(), this.saveState({ propertySet: "_dimensionAffectingProps" }));
      }, enlargeSpaces: function() {
        for (var t4, e4, i4, r5, n4, s4, o4, a4 = 0, h4 = this._textLines.length; a4 < h4; a4++) if (("justify" === this.textAlign || a4 !== h4 - 1 && !this.isEndOfWrapping(a4)) && (r5 = 0, n4 = this._textLines[a4], (e4 = this.getLineWidth(a4)) < this.width && (o4 = this.textLines[a4].match(this._reSpacesAndTabs)))) {
          i4 = o4.length, t4 = (this.width - e4) / i4;
          for (var l4 = 0, c4 = n4.length; l4 <= c4; l4++) s4 = this.__charBounds[a4][l4], this._reSpaceAndTab.test(n4[l4]) ? (s4.width += t4, s4.kernedWidth += t4, s4.left += r5, r5 += t4) : s4.left += r5;
        }
      }, isEndOfWrapping: function(t4) {
        return t4 === this._textLines.length - 1;
      }, missingNewlineOffset: function() {
        return 1;
      }, toString: function() {
        return "#<fabric.Text (" + this.complexity() + '): { "text": "' + this.text + '", "fontFamily": "' + this.fontFamily + '" }>';
      }, _getCacheCanvasDimensions: function() {
        var t4 = this.callSuper("_getCacheCanvasDimensions"), e4 = this.fontSize;
        return t4.width += e4 * t4.zoomX, t4.height += e4 * t4.zoomY, t4;
      }, _render: function(t4) {
        var e4 = this.path;
        e4 && !e4.isNotVisible() && e4._render(t4), this._setTextStyles(t4), this._renderTextLinesBackground(t4), this._renderTextDecoration(t4, "underline"), this._renderText(t4), this._renderTextDecoration(t4, "overline"), this._renderTextDecoration(t4, "linethrough");
      }, _renderText: function(t4) {
        "stroke" === this.paintFirst ? (this._renderTextStroke(t4), this._renderTextFill(t4)) : (this._renderTextFill(t4), this._renderTextStroke(t4));
      }, _setTextStyles: function(t4, e4, i4) {
        if (t4.textBaseline = "alphabetical", this.path) switch (this.pathAlign) {
          case "center":
            t4.textBaseline = "middle";
            break;
          case "ascender":
            t4.textBaseline = "top";
            break;
          case "descender":
            t4.textBaseline = "bottom";
        }
        t4.font = this._getFontDeclaration(e4, i4);
      }, calcTextWidth: function() {
        for (var t4 = this.getLineWidth(0), e4 = 1, i4 = this._textLines.length; e4 < i4; e4++) {
          var r5 = this.getLineWidth(e4);
          r5 > t4 && (t4 = r5);
        }
        return t4;
      }, _renderTextLine: function(t4, e4, i4, r5, n4, s4) {
        this._renderChars(t4, e4, i4, r5, n4, s4);
      }, _renderTextLinesBackground: function(t4) {
        if (this.textBackgroundColor || this.styleHas("textBackgroundColor")) {
          for (var e4, i4, r5, n4, s4, o4, a4, h4 = t4.fillStyle, l4 = this._getLeftOffset(), c4 = this._getTopOffset(), u4 = 0, d4 = 0, f4 = this.path, g4 = 0, p4 = this._textLines.length; g4 < p4; g4++) if (e4 = this.getHeightOfLine(g4), this.textBackgroundColor || this.styleHas("textBackgroundColor", g4)) {
            r5 = this._textLines[g4], i4 = this._getLineLeftOffset(g4), d4 = 0, u4 = 0, n4 = this.getValueOfPropertyAt(g4, 0, "textBackgroundColor");
            for (var m4 = 0, v4 = r5.length; m4 < v4; m4++) s4 = this.__charBounds[g4][m4], o4 = this.getValueOfPropertyAt(g4, m4, "textBackgroundColor"), f4 ? (t4.save(), t4.translate(s4.renderLeft, s4.renderTop), t4.rotate(s4.angle), t4.fillStyle = o4, o4 && t4.fillRect(-s4.width / 2, -e4 / this.lineHeight * (1 - this._fontSizeFraction), s4.width, e4 / this.lineHeight), t4.restore()) : o4 !== n4 ? (a4 = l4 + i4 + u4, "rtl" === this.direction && (a4 = this.width - a4 - d4), t4.fillStyle = n4, n4 && t4.fillRect(a4, c4, d4, e4 / this.lineHeight), u4 = s4.left, d4 = s4.width, n4 = o4) : d4 += s4.kernedWidth;
            o4 && !f4 && (a4 = l4 + i4 + u4, "rtl" === this.direction && (a4 = this.width - a4 - d4), t4.fillStyle = o4, t4.fillRect(a4, c4, d4, e4 / this.lineHeight)), c4 += e4;
          } else c4 += e4;
          t4.fillStyle = h4, this._removeShadow(t4);
        }
      }, getFontCache: function(t4) {
        var i4 = t4.fontFamily.toLowerCase();
        e3.charWidthsCache[i4] || (e3.charWidthsCache[i4] = {});
        var r5 = e3.charWidthsCache[i4], n4 = t4.fontStyle.toLowerCase() + "_" + (t4.fontWeight + "").toLowerCase();
        return r5[n4] || (r5[n4] = {}), r5[n4];
      }, _measureChar: function(t4, e4, i4, r5) {
        var n4, s4, o4, a4, h4 = this.getFontCache(e4), l4 = i4 + t4, c4 = this._getFontDeclaration(e4) === this._getFontDeclaration(r5), u4 = e4.fontSize / this.CACHE_FONT_SIZE;
        if (i4 && void 0 !== h4[i4] && (o4 = h4[i4]), void 0 !== h4[t4] && (a4 = n4 = h4[t4]), c4 && void 0 !== h4[l4] && (a4 = (s4 = h4[l4]) - o4), void 0 === n4 || void 0 === o4 || void 0 === s4) {
          var d4 = this.getMeasuringContext();
          this._setTextStyles(d4, e4, true);
        }
        return void 0 === n4 && (a4 = n4 = d4.measureText(t4).width, h4[t4] = n4), void 0 === o4 && c4 && i4 && (o4 = d4.measureText(i4).width, h4[i4] = o4), c4 && void 0 === s4 && (s4 = d4.measureText(l4).width, h4[l4] = s4, a4 = s4 - o4), { width: n4 * u4, kernedWidth: a4 * u4 };
      }, getHeightOfChar: function(t4, e4) {
        return this.getValueOfPropertyAt(t4, e4, "fontSize");
      }, measureLine: function(t4) {
        var e4 = this._measureLine(t4);
        return 0 !== this.charSpacing && (e4.width -= this._getWidthOfCharSpacing()), e4.width < 0 && (e4.width = 0), e4;
      }, _measureLine: function(t4) {
        var i4, r5, n4, s4, o4, a4, h4 = 0, l4 = this._textLines[t4], c4 = new Array(l4.length), u4 = 0, d4 = this.path, f4 = "right" === this.pathSide;
        for (this.__charBounds[t4] = c4, i4 = 0; i4 < l4.length; i4++) r5 = l4[i4], s4 = this._getGraphemeBox(r5, t4, i4, n4), c4[i4] = s4, h4 += s4.kernedWidth, n4 = r5;
        if (c4[i4] = { left: s4 ? s4.left + s4.width : 0, width: 0, kernedWidth: 0, height: this.fontSize }, d4) {
          switch (a4 = d4.segmentsInfo[d4.segmentsInfo.length - 1].length, (o4 = e3.util.getPointOnPath(d4.path, 0, d4.segmentsInfo)).x += d4.pathOffset.x, o4.y += d4.pathOffset.y, this.textAlign) {
            case "left":
              u4 = f4 ? a4 - h4 : 0;
              break;
            case "center":
              u4 = (a4 - h4) / 2;
              break;
            case "right":
              u4 = f4 ? 0 : a4 - h4;
          }
          for (u4 += this.pathStartOffset * (f4 ? -1 : 1), i4 = f4 ? l4.length - 1 : 0; f4 ? i4 >= 0 : i4 < l4.length; f4 ? i4-- : i4++) s4 = c4[i4], u4 > a4 ? u4 %= a4 : u4 < 0 && (u4 += a4), this._setGraphemeOnPath(u4, s4, o4), u4 += s4.kernedWidth;
        }
        return { width: h4, numOfSpaces: 0 };
      }, _setGraphemeOnPath: function(t4, i4, r5) {
        var n4 = t4 + i4.kernedWidth / 2, s4 = this.path, o4 = e3.util.getPointOnPath(s4.path, n4, s4.segmentsInfo);
        i4.renderLeft = o4.x - r5.x, i4.renderTop = o4.y - r5.y, i4.angle = o4.angle + ("right" === this.pathSide ? Math.PI : 0);
      }, _getGraphemeBox: function(t4, e4, i4, r5, n4) {
        var s4, o4 = this.getCompleteStyleDeclaration(e4, i4), a4 = r5 ? this.getCompleteStyleDeclaration(e4, i4 - 1) : {}, h4 = this._measureChar(t4, o4, r5, a4), l4 = h4.kernedWidth, c4 = h4.width;
        0 !== this.charSpacing && (c4 += s4 = this._getWidthOfCharSpacing(), l4 += s4);
        var u4 = { width: c4, left: 0, height: o4.fontSize, kernedWidth: l4, deltaY: o4.deltaY };
        if (i4 > 0 && !n4) {
          var d4 = this.__charBounds[e4][i4 - 1];
          u4.left = d4.left + d4.width + h4.kernedWidth - h4.width;
        }
        return u4;
      }, getHeightOfLine: function(t4) {
        if (this.__lineHeights[t4]) return this.__lineHeights[t4];
        for (var e4 = this._textLines[t4], i4 = this.getHeightOfChar(t4, 0), r5 = 1, n4 = e4.length; r5 < n4; r5++) i4 = Math.max(this.getHeightOfChar(t4, r5), i4);
        return this.__lineHeights[t4] = i4 * this.lineHeight * this._fontSizeMult;
      }, calcTextHeight: function() {
        for (var t4, e4 = 0, i4 = 0, r5 = this._textLines.length; i4 < r5; i4++) t4 = this.getHeightOfLine(i4), e4 += i4 === r5 - 1 ? t4 / this.lineHeight : t4;
        return e4;
      }, _getLeftOffset: function() {
        return "ltr" === this.direction ? -this.width / 2 : this.width / 2;
      }, _getTopOffset: function() {
        return -this.height / 2;
      }, _renderTextCommon: function(t4, e4) {
        t4.save();
        for (var i4 = 0, r5 = this._getLeftOffset(), n4 = this._getTopOffset(), s4 = 0, o4 = this._textLines.length; s4 < o4; s4++) {
          var a4 = this.getHeightOfLine(s4), h4 = a4 / this.lineHeight, l4 = this._getLineLeftOffset(s4);
          this._renderTextLine(e4, t4, this._textLines[s4], r5 + l4, n4 + i4 + h4, s4), i4 += a4;
        }
        t4.restore();
      }, _renderTextFill: function(t4) {
        (this.fill || this.styleHas("fill")) && this._renderTextCommon(t4, "fillText");
      }, _renderTextStroke: function(t4) {
        (this.stroke && 0 !== this.strokeWidth || !this.isEmptyStyles()) && (this.shadow && !this.shadow.affectStroke && this._removeShadow(t4), t4.save(), this._setLineDash(t4, this.strokeDashArray), t4.beginPath(), this._renderTextCommon(t4, "strokeText"), t4.closePath(), t4.restore());
      }, _renderChars: function(t4, e4, i4, r5, n4, s4) {
        var o4, a4, h4, l4, c4, u4 = this.getHeightOfLine(s4), d4 = -1 !== this.textAlign.indexOf("justify"), f4 = "", g4 = 0, p4 = this.path, m4 = !d4 && 0 === this.charSpacing && this.isEmptyStyles(s4) && !p4, v4 = "ltr" === this.direction, _4 = "ltr" === this.direction ? 1 : -1, y4 = e4.canvas.getAttribute("dir");
        if (e4.save(), y4 !== this.direction && (e4.canvas.setAttribute("dir", v4 ? "ltr" : "rtl"), e4.direction = v4 ? "ltr" : "rtl", e4.textAlign = v4 ? "left" : "right"), n4 -= u4 * this._fontSizeFraction / this.lineHeight, m4) return this._renderChar(t4, e4, s4, 0, i4.join(""), r5, n4, u4), void e4.restore();
        for (var b4 = 0, w4 = i4.length - 1; b4 <= w4; b4++) l4 = b4 === w4 || this.charSpacing || p4, f4 += i4[b4], h4 = this.__charBounds[s4][b4], 0 === g4 ? (r5 += _4 * (h4.kernedWidth - h4.width), g4 += h4.width) : g4 += h4.kernedWidth, d4 && !l4 && this._reSpaceAndTab.test(i4[b4]) && (l4 = true), l4 || (o4 = o4 || this.getCompleteStyleDeclaration(s4, b4), a4 = this.getCompleteStyleDeclaration(s4, b4 + 1), l4 = this._hasStyleChanged(o4, a4)), l4 && (p4 ? (e4.save(), e4.translate(h4.renderLeft, h4.renderTop), e4.rotate(h4.angle), this._renderChar(t4, e4, s4, b4, f4, -g4 / 2, 0, u4), e4.restore()) : (c4 = r5, this._renderChar(t4, e4, s4, b4, f4, c4, n4, u4)), f4 = "", o4 = a4, r5 += _4 * g4, g4 = 0);
        e4.restore();
      }, _applyPatternGradientTransformText: function(t4) {
        var i4, r5 = e3.util.createCanvasElement(), n4 = this.width + this.strokeWidth, s4 = this.height + this.strokeWidth;
        return r5.width = n4, r5.height = s4, (i4 = r5.getContext("2d")).beginPath(), i4.moveTo(0, 0), i4.lineTo(n4, 0), i4.lineTo(n4, s4), i4.lineTo(0, s4), i4.closePath(), i4.translate(n4 / 2, s4 / 2), i4.fillStyle = t4.toLive(i4), this._applyPatternGradientTransform(i4, t4), i4.fill(), i4.createPattern(r5, "no-repeat");
      }, handleFiller: function(t4, e4, i4) {
        var r5, n4;
        return i4.toLive ? "percentage" === i4.gradientUnits || i4.gradientTransform || i4.patternTransform ? (r5 = -this.width / 2, n4 = -this.height / 2, t4.translate(r5, n4), t4[e4] = this._applyPatternGradientTransformText(i4), { offsetX: r5, offsetY: n4 }) : (t4[e4] = i4.toLive(t4, this), this._applyPatternGradientTransform(t4, i4)) : (t4[e4] = i4, { offsetX: 0, offsetY: 0 });
      }, _setStrokeStyles: function(t4, e4) {
        return t4.lineWidth = e4.strokeWidth, t4.lineCap = this.strokeLineCap, t4.lineDashOffset = this.strokeDashOffset, t4.lineJoin = this.strokeLineJoin, t4.miterLimit = this.strokeMiterLimit, this.handleFiller(t4, "strokeStyle", e4.stroke);
      }, _setFillStyles: function(t4, e4) {
        return this.handleFiller(t4, "fillStyle", e4.fill);
      }, _renderChar: function(t4, e4, i4, r5, n4, s4, o4) {
        var a4, h4, l4 = this._getStyleDeclaration(i4, r5), c4 = this.getCompleteStyleDeclaration(i4, r5), u4 = "fillText" === t4 && c4.fill, d4 = "strokeText" === t4 && c4.stroke && c4.strokeWidth;
        (d4 || u4) && (e4.save(), u4 && (a4 = this._setFillStyles(e4, c4)), d4 && (h4 = this._setStrokeStyles(e4, c4)), e4.font = this._getFontDeclaration(c4), l4 && l4.textBackgroundColor && this._removeShadow(e4), l4 && l4.deltaY && (o4 += l4.deltaY), u4 && e4.fillText(n4, s4 - a4.offsetX, o4 - a4.offsetY), d4 && e4.strokeText(n4, s4 - h4.offsetX, o4 - h4.offsetY), e4.restore());
      }, setSuperscript: function(t4, e4) {
        return this._setScript(t4, e4, this.superscript);
      }, setSubscript: function(t4, e4) {
        return this._setScript(t4, e4, this.subscript);
      }, _setScript: function(t4, e4, i4) {
        var r5 = this.get2DCursorLocation(t4, true), n4 = this.getValueOfPropertyAt(r5.lineIndex, r5.charIndex, "fontSize"), s4 = this.getValueOfPropertyAt(r5.lineIndex, r5.charIndex, "deltaY"), o4 = { fontSize: n4 * i4.size, deltaY: s4 + n4 * i4.baseline };
        return this.setSelectionStyles(o4, t4, e4), this;
      }, _hasStyleChanged: function(t4, e4) {
        return t4.fill !== e4.fill || t4.stroke !== e4.stroke || t4.strokeWidth !== e4.strokeWidth || t4.fontSize !== e4.fontSize || t4.fontFamily !== e4.fontFamily || t4.fontWeight !== e4.fontWeight || t4.fontStyle !== e4.fontStyle || t4.deltaY !== e4.deltaY;
      }, _hasStyleChangedForSvg: function(t4, e4) {
        return this._hasStyleChanged(t4, e4) || t4.overline !== e4.overline || t4.underline !== e4.underline || t4.linethrough !== e4.linethrough;
      }, _getLineLeftOffset: function(t4) {
        var e4 = this.getLineWidth(t4), i4 = this.width - e4, r5 = this.textAlign, n4 = this.direction, s4 = 0, o4 = this.isEndOfWrapping(t4);
        return "justify" === r5 || "justify-center" === r5 && !o4 || "justify-right" === r5 && !o4 || "justify-left" === r5 && !o4 ? 0 : ("center" === r5 && (s4 = i4 / 2), "right" === r5 && (s4 = i4), "justify-center" === r5 && (s4 = i4 / 2), "justify-right" === r5 && (s4 = i4), "rtl" === n4 && (s4 -= i4), s4);
      }, _clearCache: function() {
        this.__lineWidths = [], this.__lineHeights = [], this.__charBounds = [];
      }, _shouldClearDimensionCache: function() {
        var t4 = this._forceClearCache;
        return t4 || (t4 = this.hasStateChanged("_dimensionAffectingProps")), t4 && (this.dirty = true, this._forceClearCache = false), t4;
      }, getLineWidth: function(t4) {
        if (void 0 !== this.__lineWidths[t4]) return this.__lineWidths[t4];
        var e4 = this.measureLine(t4).width;
        return this.__lineWidths[t4] = e4, e4;
      }, _getWidthOfCharSpacing: function() {
        return 0 !== this.charSpacing ? this.fontSize * this.charSpacing / 1e3 : 0;
      }, getValueOfPropertyAt: function(t4, e4, i4) {
        var r5 = this._getStyleDeclaration(t4, e4);
        return r5 && void 0 !== r5[i4] ? r5[i4] : this[i4];
      }, _renderTextDecoration: function(t4, e4) {
        if (this[e4] || this.styleHas(e4)) {
          for (var i4, r5, n4, s4, o4, a4, h4, l4, c4, u4, d4, f4, g4, p4, m4, v4, _4 = this._getLeftOffset(), y4 = this._getTopOffset(), b4 = this.path, w4 = this._getWidthOfCharSpacing(), C4 = this.offsets[e4], S4 = 0, x4 = this._textLines.length; S4 < x4; S4++) if (i4 = this.getHeightOfLine(S4), this[e4] || this.styleHas(e4, S4)) {
            h4 = this._textLines[S4], p4 = i4 / this.lineHeight, s4 = this._getLineLeftOffset(S4), u4 = 0, d4 = 0, l4 = this.getValueOfPropertyAt(S4, 0, e4), v4 = this.getValueOfPropertyAt(S4, 0, "fill"), c4 = y4 + p4 * (1 - this._fontSizeFraction), r5 = this.getHeightOfChar(S4, 0), o4 = this.getValueOfPropertyAt(S4, 0, "deltaY");
            for (var T4 = 0, O4 = h4.length; T4 < O4; T4++) if (f4 = this.__charBounds[S4][T4], g4 = this.getValueOfPropertyAt(S4, T4, e4), m4 = this.getValueOfPropertyAt(S4, T4, "fill"), n4 = this.getHeightOfChar(S4, T4), a4 = this.getValueOfPropertyAt(S4, T4, "deltaY"), b4 && g4 && m4) t4.save(), t4.fillStyle = v4, t4.translate(f4.renderLeft, f4.renderTop), t4.rotate(f4.angle), t4.fillRect(-f4.kernedWidth / 2, C4 * n4 + a4, f4.kernedWidth, this.fontSize / 15), t4.restore();
            else if ((g4 !== l4 || m4 !== v4 || n4 !== r5 || a4 !== o4) && d4 > 0) {
              var E4 = _4 + s4 + u4;
              "rtl" === this.direction && (E4 = this.width - E4 - d4), l4 && v4 && (t4.fillStyle = v4, t4.fillRect(E4, c4 + C4 * r5 + o4, d4, this.fontSize / 15)), u4 = f4.left, d4 = f4.width, l4 = g4, v4 = m4, r5 = n4, o4 = a4;
            } else d4 += f4.kernedWidth;
            E4 = _4 + s4 + u4, "rtl" === this.direction && (E4 = this.width - E4 - d4), t4.fillStyle = m4, g4 && m4 && t4.fillRect(E4, c4 + C4 * r5 + o4, d4 - w4, this.fontSize / 15), y4 += i4;
          } else y4 += i4;
          this._removeShadow(t4);
        }
      }, _getFontDeclaration: function(t4, i4) {
        var r5 = t4 || this, n4 = this.fontFamily, s4 = e3.Text.genericFonts.indexOf(n4.toLowerCase()) > -1, o4 = void 0 === n4 || n4.indexOf("'") > -1 || n4.indexOf(",") > -1 || n4.indexOf('"') > -1 || s4 ? r5.fontFamily : '"' + r5.fontFamily + '"';
        return [e3.isLikelyNode ? r5.fontWeight : r5.fontStyle, e3.isLikelyNode ? r5.fontStyle : r5.fontWeight, i4 ? this.CACHE_FONT_SIZE + "px" : r5.fontSize + "px", o4].join(" ");
      }, render: function(t4) {
        this.visible && (this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen() || (this._shouldClearDimensionCache() && this.initDimensions(), this.callSuper("render", t4)));
      }, _splitTextIntoLines: function(t4) {
        for (var i4 = t4.split(this._reNewline), r5 = new Array(i4.length), n4 = ["\n"], s4 = [], o4 = 0; o4 < i4.length; o4++) r5[o4] = e3.util.string.graphemeSplit(i4[o4]), s4 = s4.concat(r5[o4], n4);
        return s4.pop(), { _unwrappedLines: r5, lines: i4, graphemeText: s4, graphemeLines: r5 };
      }, toObject: function(t4) {
        var e4 = r4.concat(t4), n4 = this.callSuper("toObject", e4);
        return n4.styles = i3(this.styles, true), n4.path && (n4.path = this.path.toObject()), n4;
      }, set: function(t4, e4) {
        this.callSuper("set", t4, e4);
        var i4 = false, r5 = false;
        if ("object" == typeof t4) for (var n4 in t4) "path" === n4 && this.setPathInfo(), i4 = i4 || -1 !== this._dimensionAffectingProps.indexOf(n4), r5 = r5 || "path" === n4;
        else i4 = -1 !== this._dimensionAffectingProps.indexOf(t4), r5 = "path" === t4;
        return r5 && this.setPathInfo(), i4 && (this.initDimensions(), this.setCoords()), this;
      }, complexity: function() {
        return 1;
      } }), e3.Text.ATTRIBUTE_NAMES = e3.SHARED_ATTRIBUTES.concat("x y dx dy font-family font-style font-weight font-size letter-spacing text-decoration text-anchor".split(" ")), e3.Text.DEFAULT_SVG_FONT_SIZE = 16, e3.Text.fromElement = function(t4, r5, n4) {
        if (!t4) return r5(null);
        var s4 = e3.parseAttributes(t4, e3.Text.ATTRIBUTE_NAMES), o4 = s4.textAnchor || "left";
        if ((n4 = e3.util.object.extend(n4 ? i3(n4) : {}, s4)).top = n4.top || 0, n4.left = n4.left || 0, s4.textDecoration) {
          var a4 = s4.textDecoration;
          -1 !== a4.indexOf("underline") && (n4.underline = true), -1 !== a4.indexOf("overline") && (n4.overline = true), -1 !== a4.indexOf("line-through") && (n4.linethrough = true), delete n4.textDecoration;
        }
        "dx" in s4 && (n4.left += s4.dx), "dy" in s4 && (n4.top += s4.dy), "fontSize" in n4 || (n4.fontSize = e3.Text.DEFAULT_SVG_FONT_SIZE);
        var h4 = "";
        "textContent" in t4 ? h4 = t4.textContent : "firstChild" in t4 && null !== t4.firstChild && "data" in t4.firstChild && null !== t4.firstChild.data && (h4 = t4.firstChild.data), h4 = h4.replace(/^\s+|\s+$|\n+/g, "").replace(/\s+/g, " ");
        var l4 = n4.strokeWidth;
        n4.strokeWidth = 0;
        var c4 = new e3.Text(h4, n4), u4 = c4.getScaledHeight() / c4.height, d4 = ((c4.height + c4.strokeWidth) * c4.lineHeight - c4.height) * u4, f4 = c4.getScaledHeight() + d4, g4 = 0;
        "center" === o4 && (g4 = c4.getScaledWidth() / 2), "right" === o4 && (g4 = c4.getScaledWidth()), c4.set({ left: c4.left - g4, top: c4.top - (f4 - c4.fontSize * (0.07 + c4._fontSizeFraction)) / c4.lineHeight, strokeWidth: void 0 !== l4 ? l4 : 1 }), r5(c4);
      }, e3.Text.fromObject = function(t4, r5) {
        var n4 = i3(t4), s4 = t4.path;
        return delete n4.path, e3.Object._fromObject("Text", n4, function(t5) {
          s4 ? e3.Object._fromObject("Path", s4, function(e4) {
            t5.set("path", e4), r5(t5);
          }, "path") : r5(t5);
        }, "text");
      }, e3.Text.genericFonts = ["sans-serif", "serif", "cursive", "fantasy", "monospace"], e3.util.createAccessors && e3.util.createAccessors(e3.Text);
    }
  }(e2), x3.util.object.extend(x3.Text.prototype, { isEmptyStyles: function(t3) {
    if (!this.styles) return true;
    if (void 0 !== t3 && !this.styles[t3]) return true;
    var e3 = void 0 === t3 ? this.styles : { line: this.styles[t3] };
    for (var i3 in e3) for (var r4 in e3[i3]) for (var n4 in e3[i3][r4]) return false;
    return true;
  }, styleHas: function(t3, e3) {
    if (!this.styles || !t3 || "" === t3) return false;
    if (void 0 !== e3 && !this.styles[e3]) return false;
    var i3 = void 0 === e3 ? this.styles : { 0: this.styles[e3] };
    for (var r4 in i3) for (var n4 in i3[r4]) if (void 0 !== i3[r4][n4][t3]) return true;
    return false;
  }, cleanStyle: function(t3) {
    if (!this.styles || !t3 || "" === t3) return false;
    var e3, i3, r4 = this.styles, n4 = 0, s4 = true, o4 = 0;
    for (var a4 in r4) {
      for (var h4 in e3 = 0, r4[a4]) {
        var l4;
        n4++, (l4 = r4[a4][h4]).hasOwnProperty(t3) ? (i3 ? l4[t3] !== i3 && (s4 = false) : i3 = l4[t3], l4[t3] === this[t3] && delete l4[t3]) : s4 = false, 0 !== Object.keys(l4).length ? e3++ : delete r4[a4][h4];
      }
      0 === e3 && delete r4[a4];
    }
    for (var c4 = 0; c4 < this._textLines.length; c4++) o4 += this._textLines[c4].length;
    s4 && n4 === o4 && (this[t3] = i3, this.removeStyle(t3));
  }, removeStyle: function(t3) {
    if (this.styles && t3 && "" !== t3) {
      var e3, i3, r4, n4 = this.styles;
      for (i3 in n4) {
        for (r4 in e3 = n4[i3]) delete e3[r4][t3], 0 === Object.keys(e3[r4]).length && delete e3[r4];
        0 === Object.keys(e3).length && delete n4[i3];
      }
    }
  }, _extendStyles: function(t3, e3) {
    var i3 = this.get2DCursorLocation(t3);
    this._getLineStyle(i3.lineIndex) || this._setLineStyle(i3.lineIndex), this._getStyleDeclaration(i3.lineIndex, i3.charIndex) || this._setStyleDeclaration(i3.lineIndex, i3.charIndex, {}), x3.util.object.extend(this._getStyleDeclaration(i3.lineIndex, i3.charIndex), e3);
  }, get2DCursorLocation: function(t3, e3) {
    void 0 === t3 && (t3 = this.selectionStart);
    for (var i3 = e3 ? this._unwrappedTextLines : this._textLines, r4 = i3.length, n4 = 0; n4 < r4; n4++) {
      if (t3 <= i3[n4].length) return { lineIndex: n4, charIndex: t3 };
      t3 -= i3[n4].length + this.missingNewlineOffset(n4);
    }
    return { lineIndex: n4 - 1, charIndex: i3[n4 - 1].length < t3 ? i3[n4 - 1].length : t3 };
  }, getSelectionStyles: function(t3, e3, i3) {
    void 0 === t3 && (t3 = this.selectionStart || 0), void 0 === e3 && (e3 = this.selectionEnd || t3);
    for (var r4 = [], n4 = t3; n4 < e3; n4++) r4.push(this.getStyleAtPosition(n4, i3));
    return r4;
  }, getStyleAtPosition: function(t3, e3) {
    var i3 = this.get2DCursorLocation(t3);
    return (e3 ? this.getCompleteStyleDeclaration(i3.lineIndex, i3.charIndex) : this._getStyleDeclaration(i3.lineIndex, i3.charIndex)) || {};
  }, setSelectionStyles: function(t3, e3, i3) {
    void 0 === e3 && (e3 = this.selectionStart || 0), void 0 === i3 && (i3 = this.selectionEnd || e3);
    for (var r4 = e3; r4 < i3; r4++) this._extendStyles(r4, t3);
    return this._forceClearCache = true, this;
  }, _getStyleDeclaration: function(t3, e3) {
    var i3 = this.styles && this.styles[t3];
    return i3 ? i3[e3] : null;
  }, getCompleteStyleDeclaration: function(t3, e3) {
    for (var i3, r4 = this._getStyleDeclaration(t3, e3) || {}, n4 = {}, s4 = 0; s4 < this._styleProperties.length; s4++) n4[i3 = this._styleProperties[s4]] = void 0 === r4[i3] ? this[i3] : r4[i3];
    return n4;
  }, _setStyleDeclaration: function(t3, e3, i3) {
    this.styles[t3][e3] = i3;
  }, _deleteStyleDeclaration: function(t3, e3) {
    delete this.styles[t3][e3];
  }, _getLineStyle: function(t3) {
    return !!this.styles[t3];
  }, _setLineStyle: function(t3) {
    this.styles[t3] = {};
  }, _deleteLineStyle: function(t3) {
    delete this.styles[t3];
  } }), function() {
    function t3(t4) {
      t4.textDecoration && (t4.textDecoration.indexOf("underline") > -1 && (t4.underline = true), t4.textDecoration.indexOf("line-through") > -1 && (t4.linethrough = true), t4.textDecoration.indexOf("overline") > -1 && (t4.overline = true), delete t4.textDecoration);
    }
    x3.IText = x3.util.createClass(x3.Text, x3.Observable, { type: "i-text", selectionStart: 0, selectionEnd: 0, selectionColor: "rgba(17,119,255,0.3)", isEditing: false, editable: true, editingBorderColor: "rgba(102,153,255,0.25)", cursorWidth: 2, cursorColor: "", cursorDelay: 1e3, cursorDuration: 600, caching: true, hiddenTextareaContainer: null, _reSpace: /\s|\n/, _currentCursorOpacity: 0, _selectionDirection: null, _abortCursorAnimation: false, __widthOfSpace: [], inCompositionMode: false, initialize: function(t4, e3) {
      this.callSuper("initialize", t4, e3), this.initBehavior();
    }, setSelectionStart: function(t4) {
      t4 = Math.max(t4, 0), this._updateAndFire("selectionStart", t4);
    }, setSelectionEnd: function(t4) {
      t4 = Math.min(t4, this.text.length), this._updateAndFire("selectionEnd", t4);
    }, _updateAndFire: function(t4, e3) {
      this[t4] !== e3 && (this._fireSelectionChanged(), this[t4] = e3), this._updateTextarea();
    }, _fireSelectionChanged: function() {
      this.fire("selection:changed"), this.canvas && this.canvas.fire("text:selection:changed", { target: this });
    }, initDimensions: function() {
      this.isEditing && this.initDelayedCursor(), this.clearContextTop(), this.callSuper("initDimensions");
    }, render: function(t4) {
      this.clearContextTop(), this.callSuper("render", t4), this.cursorOffsetCache = {}, this.renderCursorOrSelection();
    }, _render: function(t4) {
      this.callSuper("_render", t4);
    }, clearContextTop: function(t4) {
      if (this.isEditing && this.canvas && this.canvas.contextTop) {
        var e3 = this.canvas.contextTop, i3 = this.canvas.viewportTransform;
        e3.save(), e3.transform(i3[0], i3[1], i3[2], i3[3], i3[4], i3[5]), this.transform(e3), this._clearTextArea(e3), t4 || e3.restore();
      }
    }, renderCursorOrSelection: function() {
      if (this.isEditing && this.canvas && this.canvas.contextTop) {
        var t4 = this._getCursorBoundaries(), e3 = this.canvas.contextTop;
        this.clearContextTop(true), this.selectionStart === this.selectionEnd ? this.renderCursor(t4, e3) : this.renderSelection(t4, e3), e3.restore();
      }
    }, _clearTextArea: function(t4) {
      var e3 = this.width + 4, i3 = this.height + 4;
      t4.clearRect(-e3 / 2, -i3 / 2, e3, i3);
    }, _getCursorBoundaries: function(t4) {
      void 0 === t4 && (t4 = this.selectionStart);
      var e3 = this._getLeftOffset(), i3 = this._getTopOffset(), r4 = this._getCursorBoundariesOffsets(t4);
      return { left: e3, top: i3, leftOffset: r4.left, topOffset: r4.top };
    }, _getCursorBoundariesOffsets: function(t4) {
      if (this.cursorOffsetCache && "top" in this.cursorOffsetCache) return this.cursorOffsetCache;
      var e3, i3, r4, n4, s4 = 0, o4 = 0, a4 = this.get2DCursorLocation(t4);
      r4 = a4.charIndex, i3 = a4.lineIndex;
      for (var h4 = 0; h4 < i3; h4++) s4 += this.getHeightOfLine(h4);
      e3 = this._getLineLeftOffset(i3);
      var l4 = this.__charBounds[i3][r4];
      return l4 && (o4 = l4.left), 0 !== this.charSpacing && r4 === this._textLines[i3].length && (o4 -= this._getWidthOfCharSpacing()), n4 = { top: s4, left: e3 + (o4 > 0 ? o4 : 0) }, "rtl" === this.direction && (n4.left *= -1), this.cursorOffsetCache = n4, this.cursorOffsetCache;
    }, renderCursor: function(t4, e3) {
      var i3 = this.get2DCursorLocation(), r4 = i3.lineIndex, n4 = i3.charIndex > 0 ? i3.charIndex - 1 : 0, s4 = this.getValueOfPropertyAt(r4, n4, "fontSize"), o4 = this.scaleX * this.canvas.getZoom(), a4 = this.cursorWidth / o4, h4 = t4.topOffset, l4 = this.getValueOfPropertyAt(r4, n4, "deltaY");
      h4 += (1 - this._fontSizeFraction) * this.getHeightOfLine(r4) / this.lineHeight - s4 * (1 - this._fontSizeFraction), this.inCompositionMode && this.renderSelection(t4, e3), e3.fillStyle = this.cursorColor || this.getValueOfPropertyAt(r4, n4, "fill"), e3.globalAlpha = this.__isMousedown ? 1 : this._currentCursorOpacity, e3.fillRect(t4.left + t4.leftOffset - a4 / 2, h4 + t4.top + l4, a4, s4);
    }, renderSelection: function(t4, e3) {
      for (var i3 = this.inCompositionMode ? this.hiddenTextarea.selectionStart : this.selectionStart, r4 = this.inCompositionMode ? this.hiddenTextarea.selectionEnd : this.selectionEnd, n4 = -1 !== this.textAlign.indexOf("justify"), s4 = this.get2DCursorLocation(i3), o4 = this.get2DCursorLocation(r4), a4 = s4.lineIndex, h4 = o4.lineIndex, l4 = s4.charIndex < 0 ? 0 : s4.charIndex, c4 = o4.charIndex < 0 ? 0 : o4.charIndex, u4 = a4; u4 <= h4; u4++) {
        var d4, f4 = this._getLineLeftOffset(u4) || 0, g4 = this.getHeightOfLine(u4), p4 = 0, m4 = 0;
        if (u4 === a4 && (p4 = this.__charBounds[a4][l4].left), u4 >= a4 && u4 < h4) m4 = n4 && !this.isEndOfWrapping(u4) ? this.width : this.getLineWidth(u4) || 5;
        else if (u4 === h4) if (0 === c4) m4 = this.__charBounds[h4][c4].left;
        else {
          var v4 = this._getWidthOfCharSpacing();
          m4 = this.__charBounds[h4][c4 - 1].left + this.__charBounds[h4][c4 - 1].width - v4;
        }
        d4 = g4, (this.lineHeight < 1 || u4 === h4 && this.lineHeight > 1) && (g4 /= this.lineHeight);
        var _4 = t4.left + f4 + p4, y4 = m4 - p4, b4 = g4, w4 = 0;
        this.inCompositionMode ? (e3.fillStyle = this.compositionColor || "black", b4 = 1, w4 = g4) : e3.fillStyle = this.selectionColor, "rtl" === this.direction && (_4 = this.width - _4 - y4), e3.fillRect(_4, t4.top + t4.topOffset + w4, y4, b4), t4.topOffset += d4;
      }
    }, getCurrentCharFontSize: function() {
      var t4 = this._getCurrentCharIndex();
      return this.getValueOfPropertyAt(t4.l, t4.c, "fontSize");
    }, getCurrentCharColor: function() {
      var t4 = this._getCurrentCharIndex();
      return this.getValueOfPropertyAt(t4.l, t4.c, "fill");
    }, _getCurrentCharIndex: function() {
      var t4 = this.get2DCursorLocation(this.selectionStart, true), e3 = t4.charIndex > 0 ? t4.charIndex - 1 : 0;
      return { l: t4.lineIndex, c: e3 };
    } }), x3.IText.fromObject = function(e3, i3) {
      if (t3(e3), e3.styles) for (var r4 in e3.styles) for (var n4 in e3.styles[r4]) t3(e3.styles[r4][n4]);
      x3.Object._fromObject("IText", e3, i3, "text");
    };
  }(), S3 = x3.util.object.clone, x3.util.object.extend(x3.IText.prototype, { initBehavior: function() {
    this.initAddedHandler(), this.initRemovedHandler(), this.initCursorSelectionHandlers(), this.initDoubleClickSimulation(), this.mouseMoveHandler = this.mouseMoveHandler.bind(this);
  }, onDeselect: function() {
    this.isEditing && this.exitEditing(), this.selected = false;
  }, initAddedHandler: function() {
    var t3 = this;
    this.on("added", function() {
      var e3 = t3.canvas;
      e3 && (e3._hasITextHandlers || (e3._hasITextHandlers = true, t3._initCanvasHandlers(e3)), e3._iTextInstances = e3._iTextInstances || [], e3._iTextInstances.push(t3));
    });
  }, initRemovedHandler: function() {
    var t3 = this;
    this.on("removed", function() {
      var e3 = t3.canvas;
      e3 && (e3._iTextInstances = e3._iTextInstances || [], x3.util.removeFromArray(e3._iTextInstances, t3), 0 === e3._iTextInstances.length && (e3._hasITextHandlers = false, t3._removeCanvasHandlers(e3)));
    });
  }, _initCanvasHandlers: function(t3) {
    t3._mouseUpITextHandler = function() {
      t3._iTextInstances && t3._iTextInstances.forEach(function(t4) {
        t4.__isMousedown = false;
      });
    }, t3.on("mouse:up", t3._mouseUpITextHandler);
  }, _removeCanvasHandlers: function(t3) {
    t3.off("mouse:up", t3._mouseUpITextHandler);
  }, _tick: function() {
    this._currentTickState = this._animateCursor(this, 1, this.cursorDuration, "_onTickComplete");
  }, _animateCursor: function(t3, e3, i3, r4) {
    var n4;
    return n4 = { isAborted: false, abort: function() {
      this.isAborted = true;
    } }, t3.animate("_currentCursorOpacity", e3, { duration: i3, onComplete: function() {
      n4.isAborted || t3[r4]();
    }, onChange: function() {
      t3.canvas && t3.selectionStart === t3.selectionEnd && t3.renderCursorOrSelection();
    }, abort: function() {
      return n4.isAborted;
    } }), n4;
  }, _onTickComplete: function() {
    var t3 = this;
    this._cursorTimeout1 && clearTimeout(this._cursorTimeout1), this._cursorTimeout1 = setTimeout(function() {
      t3._currentTickCompleteState = t3._animateCursor(t3, 0, this.cursorDuration / 2, "_tick");
    }, 100);
  }, initDelayedCursor: function(t3) {
    var e3 = this, i3 = t3 ? 0 : this.cursorDelay;
    this.abortCursorAnimation(), this._currentCursorOpacity = 1, this._cursorTimeout2 = setTimeout(function() {
      e3._tick();
    }, i3);
  }, abortCursorAnimation: function() {
    var t3 = this._currentTickState || this._currentTickCompleteState, e3 = this.canvas;
    this._currentTickState && this._currentTickState.abort(), this._currentTickCompleteState && this._currentTickCompleteState.abort(), clearTimeout(this._cursorTimeout1), clearTimeout(this._cursorTimeout2), this._currentCursorOpacity = 0, t3 && e3 && e3.clearContext(e3.contextTop || e3.contextContainer);
  }, selectAll: function() {
    return this.selectionStart = 0, this.selectionEnd = this._text.length, this._fireSelectionChanged(), this._updateTextarea(), this;
  }, getSelectedText: function() {
    return this._text.slice(this.selectionStart, this.selectionEnd).join("");
  }, findWordBoundaryLeft: function(t3) {
    var e3 = 0, i3 = t3 - 1;
    if (this._reSpace.test(this._text[i3])) for (; this._reSpace.test(this._text[i3]); ) e3++, i3--;
    for (; /\S/.test(this._text[i3]) && i3 > -1; ) e3++, i3--;
    return t3 - e3;
  }, findWordBoundaryRight: function(t3) {
    var e3 = 0, i3 = t3;
    if (this._reSpace.test(this._text[i3])) for (; this._reSpace.test(this._text[i3]); ) e3++, i3++;
    for (; /\S/.test(this._text[i3]) && i3 < this._text.length; ) e3++, i3++;
    return t3 + e3;
  }, findLineBoundaryLeft: function(t3) {
    for (var e3 = 0, i3 = t3 - 1; !/\n/.test(this._text[i3]) && i3 > -1; ) e3++, i3--;
    return t3 - e3;
  }, findLineBoundaryRight: function(t3) {
    for (var e3 = 0, i3 = t3; !/\n/.test(this._text[i3]) && i3 < this._text.length; ) e3++, i3++;
    return t3 + e3;
  }, searchWordBoundary: function(t3, e3) {
    for (var i3 = this._text, r4 = this._reSpace.test(i3[t3]) ? t3 - 1 : t3, n4 = i3[r4], s4 = x3.reNonWord; !s4.test(n4) && r4 > 0 && r4 < i3.length; ) n4 = i3[r4 += e3];
    return s4.test(n4) && (r4 += 1 === e3 ? 0 : 1), r4;
  }, selectWord: function(t3) {
    t3 = t3 || this.selectionStart;
    var e3 = this.searchWordBoundary(t3, -1), i3 = this.searchWordBoundary(t3, 1);
    this.selectionStart = e3, this.selectionEnd = i3, this._fireSelectionChanged(), this._updateTextarea(), this.renderCursorOrSelection();
  }, selectLine: function(t3) {
    t3 = t3 || this.selectionStart;
    var e3 = this.findLineBoundaryLeft(t3), i3 = this.findLineBoundaryRight(t3);
    return this.selectionStart = e3, this.selectionEnd = i3, this._fireSelectionChanged(), this._updateTextarea(), this;
  }, enterEditing: function(t3) {
    if (!this.isEditing && this.editable) return this.canvas && (this.canvas.calcOffset(), this.exitEditingOnOthers(this.canvas)), this.isEditing = true, this.initHiddenTextarea(t3), this.hiddenTextarea.focus(), this.hiddenTextarea.value = this.text, this._updateTextarea(), this._saveEditingProps(), this._setEditingProps(), this._textBeforeEdit = this.text, this._tick(), this.fire("editing:entered"), this._fireSelectionChanged(), this.canvas ? (this.canvas.fire("text:editing:entered", { target: this }), this.initMouseMoveHandler(), this.canvas.requestRenderAll(), this) : this;
  }, exitEditingOnOthers: function(t3) {
    t3._iTextInstances && t3._iTextInstances.forEach(function(t4) {
      t4.selected = false, t4.isEditing && t4.exitEditing();
    });
  }, initMouseMoveHandler: function() {
    this.canvas.on("mouse:move", this.mouseMoveHandler);
  }, mouseMoveHandler: function(t3) {
    if (this.__isMousedown && this.isEditing) {
      var e3 = this.getSelectionStartFromPointer(t3.e), i3 = this.selectionStart, r4 = this.selectionEnd;
      (e3 === this.__selectionStartOnMouseDown && i3 !== r4 || i3 !== e3 && r4 !== e3) && (e3 > this.__selectionStartOnMouseDown ? (this.selectionStart = this.__selectionStartOnMouseDown, this.selectionEnd = e3) : (this.selectionStart = e3, this.selectionEnd = this.__selectionStartOnMouseDown), this.selectionStart === i3 && this.selectionEnd === r4 || (this.restartCursorIfNeeded(), this._fireSelectionChanged(), this._updateTextarea(), this.renderCursorOrSelection()));
    }
  }, _setEditingProps: function() {
    this.hoverCursor = "text", this.canvas && (this.canvas.defaultCursor = this.canvas.moveCursor = "text"), this.borderColor = this.editingBorderColor, this.hasControls = this.selectable = false, this.lockMovementX = this.lockMovementY = true;
  }, fromStringToGraphemeSelection: function(t3, e3, i3) {
    var r4 = i3.slice(0, t3), n4 = x3.util.string.graphemeSplit(r4).length;
    if (t3 === e3) return { selectionStart: n4, selectionEnd: n4 };
    var s4 = i3.slice(t3, e3);
    return { selectionStart: n4, selectionEnd: n4 + x3.util.string.graphemeSplit(s4).length };
  }, fromGraphemeToStringSelection: function(t3, e3, i3) {
    var r4 = i3.slice(0, t3).join("").length;
    return t3 === e3 ? { selectionStart: r4, selectionEnd: r4 } : { selectionStart: r4, selectionEnd: r4 + i3.slice(t3, e3).join("").length };
  }, _updateTextarea: function() {
    if (this.cursorOffsetCache = {}, this.hiddenTextarea) {
      if (!this.inCompositionMode) {
        var t3 = this.fromGraphemeToStringSelection(this.selectionStart, this.selectionEnd, this._text);
        this.hiddenTextarea.selectionStart = t3.selectionStart, this.hiddenTextarea.selectionEnd = t3.selectionEnd;
      }
      this.updateTextareaPosition();
    }
  }, updateFromTextArea: function() {
    if (this.hiddenTextarea) {
      this.cursorOffsetCache = {}, this.text = this.hiddenTextarea.value, this._shouldClearDimensionCache() && (this.initDimensions(), this.setCoords());
      var t3 = this.fromStringToGraphemeSelection(this.hiddenTextarea.selectionStart, this.hiddenTextarea.selectionEnd, this.hiddenTextarea.value);
      this.selectionEnd = this.selectionStart = t3.selectionEnd, this.inCompositionMode || (this.selectionStart = t3.selectionStart), this.updateTextareaPosition();
    }
  }, updateTextareaPosition: function() {
    if (this.selectionStart === this.selectionEnd) {
      var t3 = this._calcTextareaPosition();
      this.hiddenTextarea.style.left = t3.left, this.hiddenTextarea.style.top = t3.top;
    }
  }, _calcTextareaPosition: function() {
    if (!this.canvas) return { x: 1, y: 1 };
    var t3 = this.inCompositionMode ? this.compositionStart : this.selectionStart, e3 = this._getCursorBoundaries(t3), i3 = this.get2DCursorLocation(t3), r4 = i3.lineIndex, n4 = i3.charIndex, s4 = this.getValueOfPropertyAt(r4, n4, "fontSize") * this.lineHeight, o4 = e3.leftOffset, a4 = this.calcTransformMatrix(), h4 = { x: e3.left + o4, y: e3.top + e3.topOffset + s4 }, l4 = this.canvas.getRetinaScaling(), c4 = this.canvas.upperCanvasEl, u4 = c4.width / l4, d4 = c4.height / l4, f4 = u4 - s4, g4 = d4 - s4, p4 = c4.clientWidth / u4, m4 = c4.clientHeight / d4;
    return h4 = x3.util.transformPoint(h4, a4), (h4 = x3.util.transformPoint(h4, this.canvas.viewportTransform)).x *= p4, h4.y *= m4, h4.x < 0 && (h4.x = 0), h4.x > f4 && (h4.x = f4), h4.y < 0 && (h4.y = 0), h4.y > g4 && (h4.y = g4), h4.x += this.canvas._offset.left, h4.y += this.canvas._offset.top, { left: h4.x + "px", top: h4.y + "px", fontSize: s4 + "px", charHeight: s4 };
  }, _saveEditingProps: function() {
    this._savedProps = { hasControls: this.hasControls, borderColor: this.borderColor, lockMovementX: this.lockMovementX, lockMovementY: this.lockMovementY, hoverCursor: this.hoverCursor, selectable: this.selectable, defaultCursor: this.canvas && this.canvas.defaultCursor, moveCursor: this.canvas && this.canvas.moveCursor };
  }, _restoreEditingProps: function() {
    this._savedProps && (this.hoverCursor = this._savedProps.hoverCursor, this.hasControls = this._savedProps.hasControls, this.borderColor = this._savedProps.borderColor, this.selectable = this._savedProps.selectable, this.lockMovementX = this._savedProps.lockMovementX, this.lockMovementY = this._savedProps.lockMovementY, this.canvas && (this.canvas.defaultCursor = this._savedProps.defaultCursor, this.canvas.moveCursor = this._savedProps.moveCursor));
  }, exitEditing: function() {
    var t3 = this._textBeforeEdit !== this.text, e3 = this.hiddenTextarea;
    return this.selected = false, this.isEditing = false, this.selectionEnd = this.selectionStart, e3 && (e3.blur && e3.blur(), e3.parentNode && e3.parentNode.removeChild(e3)), this.hiddenTextarea = null, this.abortCursorAnimation(), this._restoreEditingProps(), this._currentCursorOpacity = 0, this._shouldClearDimensionCache() && (this.initDimensions(), this.setCoords()), this.fire("editing:exited"), t3 && this.fire("modified"), this.canvas && (this.canvas.off("mouse:move", this.mouseMoveHandler), this.canvas.fire("text:editing:exited", { target: this }), t3 && this.canvas.fire("object:modified", { target: this })), this;
  }, _removeExtraneousStyles: function() {
    for (var t3 in this.styles) this._textLines[t3] || delete this.styles[t3];
  }, removeStyleFromTo: function(t3, e3) {
    var i3, r4, n4 = this.get2DCursorLocation(t3, true), s4 = this.get2DCursorLocation(e3, true), o4 = n4.lineIndex, a4 = n4.charIndex, h4 = s4.lineIndex, l4 = s4.charIndex;
    if (o4 !== h4) {
      if (this.styles[o4]) for (i3 = a4; i3 < this._unwrappedTextLines[o4].length; i3++) delete this.styles[o4][i3];
      if (this.styles[h4]) for (i3 = l4; i3 < this._unwrappedTextLines[h4].length; i3++) (r4 = this.styles[h4][i3]) && (this.styles[o4] || (this.styles[o4] = {}), this.styles[o4][a4 + i3 - l4] = r4);
      for (i3 = o4 + 1; i3 <= h4; i3++) delete this.styles[i3];
      this.shiftLineStyles(h4, o4 - h4);
    } else if (this.styles[o4]) {
      r4 = this.styles[o4];
      var c4, u4, d4 = l4 - a4;
      for (i3 = a4; i3 < l4; i3++) delete r4[i3];
      for (u4 in this.styles[o4]) (c4 = parseInt(u4, 10)) >= l4 && (r4[c4 - d4] = r4[u4], delete r4[u4]);
    }
  }, shiftLineStyles: function(t3, e3) {
    var i3 = S3(this.styles);
    for (var r4 in this.styles) {
      var n4 = parseInt(r4, 10);
      n4 > t3 && (this.styles[n4 + e3] = i3[n4], i3[n4 - e3] || delete this.styles[n4]);
    }
  }, restartCursorIfNeeded: function() {
    this._currentTickState && !this._currentTickState.isAborted && this._currentTickCompleteState && !this._currentTickCompleteState.isAborted || this.initDelayedCursor();
  }, insertNewlineStyleObject: function(t3, e3, i3, r4) {
    var n4, s4 = {}, o4 = false, a4 = this._unwrappedTextLines[t3].length === e3;
    for (var h4 in i3 || (i3 = 1), this.shiftLineStyles(t3, i3), this.styles[t3] && (n4 = this.styles[t3][0 === e3 ? e3 : e3 - 1]), this.styles[t3]) {
      var l4 = parseInt(h4, 10);
      l4 >= e3 && (o4 = true, s4[l4 - e3] = this.styles[t3][h4], a4 && 0 === e3 || delete this.styles[t3][h4]);
    }
    var c4 = false;
    for (o4 && !a4 && (this.styles[t3 + i3] = s4, c4 = true), c4 && i3--; i3 > 0; ) r4 && r4[i3 - 1] ? this.styles[t3 + i3] = { 0: S3(r4[i3 - 1]) } : n4 ? this.styles[t3 + i3] = { 0: S3(n4) } : delete this.styles[t3 + i3], i3--;
    this._forceClearCache = true;
  }, insertCharStyleObject: function(t3, e3, i3, r4) {
    this.styles || (this.styles = {});
    var n4 = this.styles[t3], s4 = n4 ? S3(n4) : {};
    for (var o4 in i3 || (i3 = 1), s4) {
      var a4 = parseInt(o4, 10);
      a4 >= e3 && (n4[a4 + i3] = s4[a4], s4[a4 - i3] || delete n4[a4]);
    }
    if (this._forceClearCache = true, r4) for (; i3--; ) Object.keys(r4[i3]).length && (this.styles[t3] || (this.styles[t3] = {}), this.styles[t3][e3 + i3] = S3(r4[i3]));
    else if (n4) for (var h4 = n4[e3 ? e3 - 1 : 1]; h4 && i3--; ) this.styles[t3][e3 + i3] = S3(h4);
  }, insertNewStyleBlock: function(t3, e3, i3) {
    for (var r4 = this.get2DCursorLocation(e3, true), n4 = [0], s4 = 0, o4 = 0; o4 < t3.length; o4++) "\n" === t3[o4] ? n4[++s4] = 0 : n4[s4]++;
    for (n4[0] > 0 && (this.insertCharStyleObject(r4.lineIndex, r4.charIndex, n4[0], i3), i3 = i3 && i3.slice(n4[0] + 1)), s4 && this.insertNewlineStyleObject(r4.lineIndex, r4.charIndex + n4[0], s4), o4 = 1; o4 < s4; o4++) n4[o4] > 0 ? this.insertCharStyleObject(r4.lineIndex + o4, 0, n4[o4], i3) : i3 && this.styles[r4.lineIndex + o4] && i3[0] && (this.styles[r4.lineIndex + o4][0] = i3[0]), i3 = i3 && i3.slice(n4[o4] + 1);
    n4[o4] > 0 && this.insertCharStyleObject(r4.lineIndex + o4, 0, n4[o4], i3);
  }, setSelectionStartEndWithShift: function(t3, e3, i3) {
    i3 <= t3 ? (e3 === t3 ? this._selectionDirection = "left" : "right" === this._selectionDirection && (this._selectionDirection = "left", this.selectionEnd = t3), this.selectionStart = i3) : i3 > t3 && i3 < e3 ? "right" === this._selectionDirection ? this.selectionEnd = i3 : this.selectionStart = i3 : (e3 === t3 ? this._selectionDirection = "right" : "left" === this._selectionDirection && (this._selectionDirection = "right", this.selectionStart = e3), this.selectionEnd = i3);
  }, setSelectionInBoundaries: function() {
    var t3 = this.text.length;
    this.selectionStart > t3 ? this.selectionStart = t3 : this.selectionStart < 0 && (this.selectionStart = 0), this.selectionEnd > t3 ? this.selectionEnd = t3 : this.selectionEnd < 0 && (this.selectionEnd = 0);
  } }), x3.util.object.extend(x3.IText.prototype, { initDoubleClickSimulation: function() {
    this.__lastClickTime = +/* @__PURE__ */ new Date(), this.__lastLastClickTime = +/* @__PURE__ */ new Date(), this.__lastPointer = {}, this.on("mousedown", this.onMouseDown);
  }, onMouseDown: function(t3) {
    if (this.canvas) {
      this.__newClickTime = +/* @__PURE__ */ new Date();
      var e3 = t3.pointer;
      this.isTripleClick(e3) && (this.fire("tripleclick", t3), this._stopEvent(t3.e)), this.__lastLastClickTime = this.__lastClickTime, this.__lastClickTime = this.__newClickTime, this.__lastPointer = e3, this.__lastIsEditing = this.isEditing, this.__lastSelected = this.selected;
    }
  }, isTripleClick: function(t3) {
    return this.__newClickTime - this.__lastClickTime < 500 && this.__lastClickTime - this.__lastLastClickTime < 500 && this.__lastPointer.x === t3.x && this.__lastPointer.y === t3.y;
  }, _stopEvent: function(t3) {
    t3.preventDefault && t3.preventDefault(), t3.stopPropagation && t3.stopPropagation();
  }, initCursorSelectionHandlers: function() {
    this.initMousedownHandler(), this.initMouseupHandler(), this.initClicks();
  }, doubleClickHandler: function(t3) {
    this.isEditing && this.selectWord(this.getSelectionStartFromPointer(t3.e));
  }, tripleClickHandler: function(t3) {
    this.isEditing && this.selectLine(this.getSelectionStartFromPointer(t3.e));
  }, initClicks: function() {
    this.on("mousedblclick", this.doubleClickHandler), this.on("tripleclick", this.tripleClickHandler);
  }, _mouseDownHandler: function(t3) {
    !this.canvas || !this.editable || t3.e.button && 1 !== t3.e.button || (this.__isMousedown = true, this.selected && (this.inCompositionMode = false, this.setCursorByClick(t3.e)), this.isEditing && (this.__selectionStartOnMouseDown = this.selectionStart, this.selectionStart === this.selectionEnd && this.abortCursorAnimation(), this.renderCursorOrSelection()));
  }, _mouseDownHandlerBefore: function(t3) {
    !this.canvas || !this.editable || t3.e.button && 1 !== t3.e.button || (this.selected = this === this.canvas._activeObject);
  }, initMousedownHandler: function() {
    this.on("mousedown", this._mouseDownHandler), this.on("mousedown:before", this._mouseDownHandlerBefore);
  }, initMouseupHandler: function() {
    this.on("mouseup", this.mouseUpHandler);
  }, mouseUpHandler: function(t3) {
    if (this.__isMousedown = false, !(!this.editable || this.group || t3.transform && t3.transform.actionPerformed || t3.e.button && 1 !== t3.e.button)) {
      if (this.canvas) {
        var e3 = this.canvas._activeObject;
        if (e3 && e3 !== this) return;
      }
      this.__lastSelected && !this.__corner ? (this.selected = false, this.__lastSelected = false, this.enterEditing(t3.e), this.selectionStart === this.selectionEnd ? this.initDelayedCursor(true) : this.renderCursorOrSelection()) : this.selected = true;
    }
  }, setCursorByClick: function(t3) {
    var e3 = this.getSelectionStartFromPointer(t3), i3 = this.selectionStart, r4 = this.selectionEnd;
    t3.shiftKey ? this.setSelectionStartEndWithShift(i3, r4, e3) : (this.selectionStart = e3, this.selectionEnd = e3), this.isEditing && (this._fireSelectionChanged(), this._updateTextarea());
  }, getSelectionStartFromPointer: function(t3) {
    for (var e3, i3 = this.getLocalPointer(t3), r4 = 0, n4 = 0, s4 = 0, o4 = 0, a4 = 0, h4 = 0, l4 = this._textLines.length; h4 < l4 && s4 <= i3.y; h4++) s4 += this.getHeightOfLine(h4) * this.scaleY, a4 = h4, h4 > 0 && (o4 += this._textLines[h4 - 1].length + this.missingNewlineOffset(h4 - 1));
    n4 = this._getLineLeftOffset(a4) * this.scaleX, e3 = this._textLines[a4], "rtl" === this.direction && (i3.x = this.width * this.scaleX - i3.x + n4);
    for (var c4 = 0, u4 = e3.length; c4 < u4 && (r4 = n4, (n4 += this.__charBounds[a4][c4].kernedWidth * this.scaleX) <= i3.x); c4++) o4++;
    return this._getNewSelectionStartFromOffset(i3, r4, n4, o4, u4);
  }, _getNewSelectionStartFromOffset: function(t3, e3, i3, r4, n4) {
    var s4 = t3.x - e3, o4 = i3 - t3.x, a4 = r4 + (o4 > s4 || o4 < 0 ? 0 : 1);
    return this.flipX && (a4 = n4 - a4), a4 > this._text.length && (a4 = this._text.length), a4;
  } }), x3.util.object.extend(x3.IText.prototype, { initHiddenTextarea: function() {
    this.hiddenTextarea = x3.document.createElement("textarea"), this.hiddenTextarea.setAttribute("autocapitalize", "off"), this.hiddenTextarea.setAttribute("autocorrect", "off"), this.hiddenTextarea.setAttribute("autocomplete", "off"), this.hiddenTextarea.setAttribute("spellcheck", "false"), this.hiddenTextarea.setAttribute("data-fabric-hiddentextarea", ""), this.hiddenTextarea.setAttribute("wrap", "off");
    var t3 = this._calcTextareaPosition();
    this.hiddenTextarea.style.cssText = "position: absolute; top: " + t3.top + "; left: " + t3.left + "; z-index: -999; opacity: 0; width: 1px; height: 1px; font-size: 1px; paddingtop: " + t3.fontSize + ";", this.hiddenTextareaContainer ? this.hiddenTextareaContainer.appendChild(this.hiddenTextarea) : x3.document.body.appendChild(this.hiddenTextarea), x3.util.addListener(this.hiddenTextarea, "keydown", this.onKeyDown.bind(this)), x3.util.addListener(this.hiddenTextarea, "keyup", this.onKeyUp.bind(this)), x3.util.addListener(this.hiddenTextarea, "input", this.onInput.bind(this)), x3.util.addListener(this.hiddenTextarea, "copy", this.copy.bind(this)), x3.util.addListener(this.hiddenTextarea, "cut", this.copy.bind(this)), x3.util.addListener(this.hiddenTextarea, "paste", this.paste.bind(this)), x3.util.addListener(this.hiddenTextarea, "compositionstart", this.onCompositionStart.bind(this)), x3.util.addListener(this.hiddenTextarea, "compositionupdate", this.onCompositionUpdate.bind(this)), x3.util.addListener(this.hiddenTextarea, "compositionend", this.onCompositionEnd.bind(this)), !this._clickHandlerInitialized && this.canvas && (x3.util.addListener(this.canvas.upperCanvasEl, "click", this.onClick.bind(this)), this._clickHandlerInitialized = true);
  }, keysMap: { 9: "exitEditing", 27: "exitEditing", 33: "moveCursorUp", 34: "moveCursorDown", 35: "moveCursorRight", 36: "moveCursorLeft", 37: "moveCursorLeft", 38: "moveCursorUp", 39: "moveCursorRight", 40: "moveCursorDown" }, keysMapRtl: { 9: "exitEditing", 27: "exitEditing", 33: "moveCursorUp", 34: "moveCursorDown", 35: "moveCursorLeft", 36: "moveCursorRight", 37: "moveCursorRight", 38: "moveCursorUp", 39: "moveCursorLeft", 40: "moveCursorDown" }, ctrlKeysMapUp: { 67: "copy", 88: "cut" }, ctrlKeysMapDown: { 65: "selectAll" }, onClick: function() {
    this.hiddenTextarea && this.hiddenTextarea.focus();
  }, onKeyDown: function(t3) {
    if (this.isEditing) {
      var e3 = "rtl" === this.direction ? this.keysMapRtl : this.keysMap;
      if (t3.keyCode in e3) this[e3[t3.keyCode]](t3);
      else {
        if (!(t3.keyCode in this.ctrlKeysMapDown) || !t3.ctrlKey && !t3.metaKey) return;
        this[this.ctrlKeysMapDown[t3.keyCode]](t3);
      }
      t3.stopImmediatePropagation(), t3.preventDefault(), t3.keyCode >= 33 && t3.keyCode <= 40 ? (this.inCompositionMode = false, this.clearContextTop(), this.renderCursorOrSelection()) : this.canvas && this.canvas.requestRenderAll();
    }
  }, onKeyUp: function(t3) {
    !this.isEditing || this._copyDone || this.inCompositionMode ? this._copyDone = false : t3.keyCode in this.ctrlKeysMapUp && (t3.ctrlKey || t3.metaKey) && (this[this.ctrlKeysMapUp[t3.keyCode]](t3), t3.stopImmediatePropagation(), t3.preventDefault(), this.canvas && this.canvas.requestRenderAll());
  }, onInput: function(t3) {
    var e3 = this.fromPaste;
    if (this.fromPaste = false, t3 && t3.stopPropagation(), this.isEditing) {
      var i3, r4, n4, s4, o4, a4 = this._splitTextIntoLines(this.hiddenTextarea.value).graphemeText, h4 = this._text.length, l4 = a4.length, c4 = l4 - h4, u4 = this.selectionStart, d4 = this.selectionEnd, f4 = u4 !== d4;
      if ("" === this.hiddenTextarea.value) return this.styles = {}, this.updateFromTextArea(), this.fire("changed"), void (this.canvas && (this.canvas.fire("text:changed", { target: this }), this.canvas.requestRenderAll()));
      var g4 = this.fromStringToGraphemeSelection(this.hiddenTextarea.selectionStart, this.hiddenTextarea.selectionEnd, this.hiddenTextarea.value), p4 = u4 > g4.selectionStart;
      f4 ? (i3 = this._text.slice(u4, d4), c4 += d4 - u4) : l4 < h4 && (i3 = p4 ? this._text.slice(d4 + c4, d4) : this._text.slice(u4, u4 - c4)), r4 = a4.slice(g4.selectionEnd - c4, g4.selectionEnd), i3 && i3.length && (r4.length && (n4 = this.getSelectionStyles(u4, u4 + 1, false), n4 = r4.map(function() {
        return n4[0];
      })), f4 ? (s4 = u4, o4 = d4) : p4 ? (s4 = d4 - i3.length, o4 = d4) : (s4 = d4, o4 = d4 + i3.length), this.removeStyleFromTo(s4, o4)), r4.length && (e3 && r4.join("") === x3.copiedText && !x3.disableStyleCopyPaste && (n4 = x3.copiedTextStyle), this.insertNewStyleBlock(r4, u4, n4)), this.updateFromTextArea(), this.fire("changed"), this.canvas && (this.canvas.fire("text:changed", { target: this }), this.canvas.requestRenderAll());
    }
  }, onCompositionStart: function() {
    this.inCompositionMode = true;
  }, onCompositionEnd: function() {
    this.inCompositionMode = false;
  }, onCompositionUpdate: function(t3) {
    this.compositionStart = t3.target.selectionStart, this.compositionEnd = t3.target.selectionEnd, this.updateTextareaPosition();
  }, copy: function() {
    this.selectionStart !== this.selectionEnd && (x3.copiedText = this.getSelectedText(), x3.disableStyleCopyPaste ? x3.copiedTextStyle = null : x3.copiedTextStyle = this.getSelectionStyles(this.selectionStart, this.selectionEnd, true), this._copyDone = true);
  }, paste: function() {
    this.fromPaste = true;
  }, _getClipboardData: function(t3) {
    return t3 && t3.clipboardData || x3.window.clipboardData;
  }, _getWidthBeforeCursor: function(t3, e3) {
    var i3, r4 = this._getLineLeftOffset(t3);
    return e3 > 0 && (r4 += (i3 = this.__charBounds[t3][e3 - 1]).left + i3.width), r4;
  }, getDownCursorOffset: function(t3, e3) {
    var i3 = this._getSelectionForOffset(t3, e3), r4 = this.get2DCursorLocation(i3), n4 = r4.lineIndex;
    if (n4 === this._textLines.length - 1 || t3.metaKey || 34 === t3.keyCode) return this._text.length - i3;
    var s4 = r4.charIndex, o4 = this._getWidthBeforeCursor(n4, s4), a4 = this._getIndexOnLine(n4 + 1, o4);
    return this._textLines[n4].slice(s4).length + a4 + 1 + this.missingNewlineOffset(n4);
  }, _getSelectionForOffset: function(t3, e3) {
    return t3.shiftKey && this.selectionStart !== this.selectionEnd && e3 ? this.selectionEnd : this.selectionStart;
  }, getUpCursorOffset: function(t3, e3) {
    var i3 = this._getSelectionForOffset(t3, e3), r4 = this.get2DCursorLocation(i3), n4 = r4.lineIndex;
    if (0 === n4 || t3.metaKey || 33 === t3.keyCode) return -i3;
    var s4 = r4.charIndex, o4 = this._getWidthBeforeCursor(n4, s4), a4 = this._getIndexOnLine(n4 - 1, o4), h4 = this._textLines[n4].slice(0, s4), l4 = this.missingNewlineOffset(n4 - 1);
    return -this._textLines[n4 - 1].length + a4 - h4.length + (1 - l4);
  }, _getIndexOnLine: function(t3, e3) {
    for (var i3, r4, n4 = this._textLines[t3], s4 = this._getLineLeftOffset(t3), o4 = 0, a4 = 0, h4 = n4.length; a4 < h4; a4++) if ((s4 += i3 = this.__charBounds[t3][a4].width) > e3) {
      r4 = true;
      var l4 = s4 - i3, c4 = s4, u4 = Math.abs(l4 - e3);
      o4 = Math.abs(c4 - e3) < u4 ? a4 : a4 - 1;
      break;
    }
    return r4 || (o4 = n4.length - 1), o4;
  }, moveCursorDown: function(t3) {
    this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length || this._moveCursorUpOrDown("Down", t3);
  }, moveCursorUp: function(t3) {
    0 === this.selectionStart && 0 === this.selectionEnd || this._moveCursorUpOrDown("Up", t3);
  }, _moveCursorUpOrDown: function(t3, e3) {
    var i3 = this["get" + t3 + "CursorOffset"](e3, "right" === this._selectionDirection);
    e3.shiftKey ? this.moveCursorWithShift(i3) : this.moveCursorWithoutShift(i3), 0 !== i3 && (this.setSelectionInBoundaries(), this.abortCursorAnimation(), this._currentCursorOpacity = 1, this.initDelayedCursor(), this._fireSelectionChanged(), this._updateTextarea());
  }, moveCursorWithShift: function(t3) {
    var e3 = "left" === this._selectionDirection ? this.selectionStart + t3 : this.selectionEnd + t3;
    return this.setSelectionStartEndWithShift(this.selectionStart, this.selectionEnd, e3), 0 !== t3;
  }, moveCursorWithoutShift: function(t3) {
    return t3 < 0 ? (this.selectionStart += t3, this.selectionEnd = this.selectionStart) : (this.selectionEnd += t3, this.selectionStart = this.selectionEnd), 0 !== t3;
  }, moveCursorLeft: function(t3) {
    0 === this.selectionStart && 0 === this.selectionEnd || this._moveCursorLeftOrRight("Left", t3);
  }, _move: function(t3, e3, i3) {
    var r4;
    if (t3.altKey) r4 = this["findWordBoundary" + i3](this[e3]);
    else {
      if (!t3.metaKey && 35 !== t3.keyCode && 36 !== t3.keyCode) return this[e3] += "Left" === i3 ? -1 : 1, true;
      r4 = this["findLineBoundary" + i3](this[e3]);
    }
    if (void 0 !== typeof r4 && this[e3] !== r4) return this[e3] = r4, true;
  }, _moveLeft: function(t3, e3) {
    return this._move(t3, e3, "Left");
  }, _moveRight: function(t3, e3) {
    return this._move(t3, e3, "Right");
  }, moveCursorLeftWithoutShift: function(t3) {
    var e3 = true;
    return this._selectionDirection = "left", this.selectionEnd === this.selectionStart && 0 !== this.selectionStart && (e3 = this._moveLeft(t3, "selectionStart")), this.selectionEnd = this.selectionStart, e3;
  }, moveCursorLeftWithShift: function(t3) {
    return "right" === this._selectionDirection && this.selectionStart !== this.selectionEnd ? this._moveLeft(t3, "selectionEnd") : 0 !== this.selectionStart ? (this._selectionDirection = "left", this._moveLeft(t3, "selectionStart")) : void 0;
  }, moveCursorRight: function(t3) {
    this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length || this._moveCursorLeftOrRight("Right", t3);
  }, _moveCursorLeftOrRight: function(t3, e3) {
    var i3 = "moveCursor" + t3 + "With";
    this._currentCursorOpacity = 1, e3.shiftKey ? i3 += "Shift" : i3 += "outShift", this[i3](e3) && (this.abortCursorAnimation(), this.initDelayedCursor(), this._fireSelectionChanged(), this._updateTextarea());
  }, moveCursorRightWithShift: function(t3) {
    return "left" === this._selectionDirection && this.selectionStart !== this.selectionEnd ? this._moveRight(t3, "selectionStart") : this.selectionEnd !== this._text.length ? (this._selectionDirection = "right", this._moveRight(t3, "selectionEnd")) : void 0;
  }, moveCursorRightWithoutShift: function(t3) {
    var e3 = true;
    return this._selectionDirection = "right", this.selectionStart === this.selectionEnd ? (e3 = this._moveRight(t3, "selectionStart"), this.selectionEnd = this.selectionStart) : this.selectionStart = this.selectionEnd, e3;
  }, removeChars: function(t3, e3) {
    void 0 === e3 && (e3 = t3 + 1), this.removeStyleFromTo(t3, e3), this._text.splice(t3, e3 - t3), this.text = this._text.join(""), this.set("dirty", true), this._shouldClearDimensionCache() && (this.initDimensions(), this.setCoords()), this._removeExtraneousStyles();
  }, insertChars: function(t3, e3, i3, r4) {
    void 0 === r4 && (r4 = i3), r4 > i3 && this.removeStyleFromTo(i3, r4);
    var n4 = x3.util.string.graphemeSplit(t3);
    this.insertNewStyleBlock(n4, i3, e3), this._text = [].concat(this._text.slice(0, i3), n4, this._text.slice(r4)), this.text = this._text.join(""), this.set("dirty", true), this._shouldClearDimensionCache() && (this.initDimensions(), this.setCoords()), this._removeExtraneousStyles();
  } }), function() {
    var t3 = x3.util.toFixed, e3 = /  +/g;
    x3.util.object.extend(x3.Text.prototype, { _toSVG: function() {
      var t4 = this._getSVGLeftTopOffsets(), e4 = this._getSVGTextAndBg(t4.textTop, t4.textLeft);
      return this._wrapSVGTextAndBg(e4);
    }, toSVG: function(t4) {
      return this._createBaseSVGMarkup(this._toSVG(), { reviver: t4, noStyle: true, withShadow: true });
    }, _getSVGLeftTopOffsets: function() {
      return { textLeft: -this.width / 2, textTop: -this.height / 2, lineTop: this.getHeightOfLine(0) };
    }, _wrapSVGTextAndBg: function(t4) {
      var e4 = this.getSvgTextDecoration(this);
      return [t4.textBgRects.join(""), '		<text xml:space="preserve" ', this.fontFamily ? 'font-family="' + this.fontFamily.replace(/"/g, "'") + '" ' : "", this.fontSize ? 'font-size="' + this.fontSize + '" ' : "", this.fontStyle ? 'font-style="' + this.fontStyle + '" ' : "", this.fontWeight ? 'font-weight="' + this.fontWeight + '" ' : "", e4 ? 'text-decoration="' + e4 + '" ' : "", 'style="', this.getSvgStyles(true), '"', this.addPaintOrder(), " >", t4.textSpans.join(""), "</text>\n"];
    }, _getSVGTextAndBg: function(t4, e4) {
      var i3, r4 = [], n4 = [], s4 = t4;
      this._setSVGBg(n4);
      for (var o4 = 0, a4 = this._textLines.length; o4 < a4; o4++) i3 = this._getLineLeftOffset(o4), (this.textBackgroundColor || this.styleHas("textBackgroundColor", o4)) && this._setSVGTextLineBg(n4, o4, e4 + i3, s4), this._setSVGTextLineText(r4, o4, e4 + i3, s4), s4 += this.getHeightOfLine(o4);
      return { textSpans: r4, textBgRects: n4 };
    }, _createTextCharSpan: function(i3, r4, n4, s4) {
      var o4 = i3 !== i3.trim() || i3.match(e3), a4 = this.getSvgSpanStyles(r4, o4), h4 = a4 ? 'style="' + a4 + '"' : "", l4 = r4.deltaY, c4 = "", u4 = x3.Object.NUM_FRACTION_DIGITS;
      return l4 && (c4 = ' dy="' + t3(l4, u4) + '" '), ['<tspan x="', t3(n4, u4), '" y="', t3(s4, u4), '" ', c4, h4, ">", x3.util.string.escapeXml(i3), "</tspan>"].join("");
    }, _setSVGTextLineText: function(t4, e4, i3, r4) {
      var n4, s4, o4, a4, h4, l4 = this.getHeightOfLine(e4), c4 = -1 !== this.textAlign.indexOf("justify"), u4 = "", d4 = 0, f4 = this._textLines[e4];
      r4 += l4 * (1 - this._fontSizeFraction) / this.lineHeight;
      for (var g4 = 0, p4 = f4.length - 1; g4 <= p4; g4++) h4 = g4 === p4 || this.charSpacing, u4 += f4[g4], o4 = this.__charBounds[e4][g4], 0 === d4 ? (i3 += o4.kernedWidth - o4.width, d4 += o4.width) : d4 += o4.kernedWidth, c4 && !h4 && this._reSpaceAndTab.test(f4[g4]) && (h4 = true), h4 || (n4 = n4 || this.getCompleteStyleDeclaration(e4, g4), s4 = this.getCompleteStyleDeclaration(e4, g4 + 1), h4 = this._hasStyleChangedForSvg(n4, s4)), h4 && (a4 = this._getStyleDeclaration(e4, g4) || {}, t4.push(this._createTextCharSpan(u4, a4, i3, r4)), u4 = "", n4 = s4, i3 += d4, d4 = 0);
    }, _pushTextBgRect: function(e4, i3, r4, n4, s4, o4) {
      var a4 = x3.Object.NUM_FRACTION_DIGITS;
      e4.push("		<rect ", this._getFillAttributes(i3), ' x="', t3(r4, a4), '" y="', t3(n4, a4), '" width="', t3(s4, a4), '" height="', t3(o4, a4), '"></rect>\n');
    }, _setSVGTextLineBg: function(t4, e4, i3, r4) {
      for (var n4, s4, o4 = this._textLines[e4], a4 = this.getHeightOfLine(e4) / this.lineHeight, h4 = 0, l4 = 0, c4 = this.getValueOfPropertyAt(e4, 0, "textBackgroundColor"), u4 = 0, d4 = o4.length; u4 < d4; u4++) n4 = this.__charBounds[e4][u4], (s4 = this.getValueOfPropertyAt(e4, u4, "textBackgroundColor")) !== c4 ? (c4 && this._pushTextBgRect(t4, c4, i3 + l4, r4, h4, a4), l4 = n4.left, h4 = n4.width, c4 = s4) : h4 += n4.kernedWidth;
      s4 && this._pushTextBgRect(t4, s4, i3 + l4, r4, h4, a4);
    }, _getFillAttributes: function(t4) {
      var e4 = t4 && "string" == typeof t4 ? new x3.Color(t4) : "";
      return e4 && e4.getSource() && 1 !== e4.getAlpha() ? 'opacity="' + e4.getAlpha() + '" fill="' + e4.setAlpha(1).toRgb() + '"' : 'fill="' + t4 + '"';
    }, _getSVGLineTopOffset: function(t4) {
      for (var e4, i3 = 0, r4 = 0; r4 < t4; r4++) i3 += this.getHeightOfLine(r4);
      return e4 = this.getHeightOfLine(r4), { lineTop: i3, offset: (this._fontSizeMult - this._fontSizeFraction) * e4 / (this.lineHeight * this._fontSizeMult) };
    }, getSvgStyles: function(t4) {
      return x3.Object.prototype.getSvgStyles.call(this, t4) + " white-space: pre;";
    } });
  }(), function(t3) {
    var e3 = t3.fabric || (t3.fabric = {});
    e3.Textbox = e3.util.createClass(e3.IText, e3.Observable, { type: "textbox", minWidth: 20, dynamicMinWidth: 2, __cachedLines: null, lockScalingFlip: true, noScaleCache: false, _dimensionAffectingProps: e3.Text.prototype._dimensionAffectingProps.concat("width"), _wordJoiners: /[ \t\r]/, splitByGrapheme: false, initDimensions: function() {
      this.__skipDimension || (this.isEditing && this.initDelayedCursor(), this.clearContextTop(), this._clearCache(), this.dynamicMinWidth = 0, this._styleMap = this._generateStyleMap(this._splitText()), this.dynamicMinWidth > this.width && this._set("width", this.dynamicMinWidth), -1 !== this.textAlign.indexOf("justify") && this.enlargeSpaces(), this.height = this.calcTextHeight(), this.saveState({ propertySet: "_dimensionAffectingProps" }));
    }, _generateStyleMap: function(t4) {
      for (var e4 = 0, i3 = 0, r4 = 0, n4 = {}, s4 = 0; s4 < t4.graphemeLines.length; s4++) "\n" === t4.graphemeText[r4] && s4 > 0 ? (i3 = 0, r4++, e4++) : !this.splitByGrapheme && this._reSpaceAndTab.test(t4.graphemeText[r4]) && s4 > 0 && (i3++, r4++), n4[s4] = { line: e4, offset: i3 }, r4 += t4.graphemeLines[s4].length, i3 += t4.graphemeLines[s4].length;
      return n4;
    }, styleHas: function(t4, i3) {
      if (this._styleMap && !this.isWrapping) {
        var r4 = this._styleMap[i3];
        r4 && (i3 = r4.line);
      }
      return e3.Text.prototype.styleHas.call(this, t4, i3);
    }, isEmptyStyles: function(t4) {
      if (!this.styles) return true;
      var e4, i3, r4 = 0, n4 = false, s4 = this._styleMap[t4], o4 = this._styleMap[t4 + 1];
      for (var a4 in s4 && (t4 = s4.line, r4 = s4.offset), o4 && (n4 = o4.line === t4, e4 = o4.offset), i3 = void 0 === t4 ? this.styles : { line: this.styles[t4] }) for (var h4 in i3[a4]) if (h4 >= r4 && (!n4 || h4 < e4)) for (var l4 in i3[a4][h4]) return false;
      return true;
    }, _getStyleDeclaration: function(t4, e4) {
      if (this._styleMap && !this.isWrapping) {
        var i3 = this._styleMap[t4];
        if (!i3) return null;
        t4 = i3.line, e4 = i3.offset + e4;
      }
      return this.callSuper("_getStyleDeclaration", t4, e4);
    }, _setStyleDeclaration: function(t4, e4, i3) {
      var r4 = this._styleMap[t4];
      t4 = r4.line, e4 = r4.offset + e4, this.styles[t4][e4] = i3;
    }, _deleteStyleDeclaration: function(t4, e4) {
      var i3 = this._styleMap[t4];
      t4 = i3.line, e4 = i3.offset + e4, delete this.styles[t4][e4];
    }, _getLineStyle: function(t4) {
      var e4 = this._styleMap[t4];
      return !!this.styles[e4.line];
    }, _setLineStyle: function(t4) {
      var e4 = this._styleMap[t4];
      this.styles[e4.line] = {};
    }, _wrapText: function(t4, e4) {
      var i3, r4 = [];
      for (this.isWrapping = true, i3 = 0; i3 < t4.length; i3++) r4 = r4.concat(this._wrapLine(t4[i3], i3, e4));
      return this.isWrapping = false, r4;
    }, _measureWord: function(t4, e4, i3) {
      var r4, n4 = 0;
      i3 = i3 || 0;
      for (var s4 = 0, o4 = t4.length; s4 < o4; s4++) n4 += this._getGraphemeBox(t4[s4], e4, s4 + i3, r4, true).kernedWidth, r4 = t4[s4];
      return n4;
    }, _wrapLine: function(t4, i3, r4, n4) {
      var s4 = 0, o4 = this.splitByGrapheme, a4 = [], h4 = [], l4 = o4 ? e3.util.string.graphemeSplit(t4) : t4.split(this._wordJoiners), c4 = "", u4 = 0, d4 = o4 ? "" : " ", f4 = 0, g4 = 0, p4 = 0, m4 = true, v4 = this._getWidthOfCharSpacing();
      n4 = n4 || 0, 0 === l4.length && l4.push([]), r4 -= n4;
      for (var _4 = 0; _4 < l4.length; _4++) c4 = o4 ? l4[_4] : e3.util.string.graphemeSplit(l4[_4]), f4 = this._measureWord(c4, i3, u4), u4 += c4.length, (s4 += g4 + f4 - v4) > r4 && !m4 ? (a4.push(h4), h4 = [], s4 = f4, m4 = true) : s4 += v4, m4 || o4 || h4.push(d4), h4 = h4.concat(c4), g4 = o4 ? 0 : this._measureWord([d4], i3, u4), u4++, m4 = false, f4 > p4 && (p4 = f4);
      return _4 && a4.push(h4), p4 + n4 > this.dynamicMinWidth && (this.dynamicMinWidth = p4 - v4 + n4), a4;
    }, isEndOfWrapping: function(t4) {
      return !this._styleMap[t4 + 1] || this._styleMap[t4 + 1].line !== this._styleMap[t4].line;
    }, missingNewlineOffset: function(t4) {
      return this.splitByGrapheme ? this.isEndOfWrapping(t4) ? 1 : 0 : 1;
    }, _splitTextIntoLines: function(t4) {
      for (var i3 = e3.Text.prototype._splitTextIntoLines.call(this, t4), r4 = this._wrapText(i3.lines, this.width), n4 = new Array(r4.length), s4 = 0; s4 < r4.length; s4++) n4[s4] = r4[s4].join("");
      return i3.lines = n4, i3.graphemeLines = r4, i3;
    }, getMinWidth: function() {
      return Math.max(this.minWidth, this.dynamicMinWidth);
    }, _removeExtraneousStyles: function() {
      var t4 = {};
      for (var e4 in this._styleMap) this._textLines[e4] && (t4[this._styleMap[e4].line] = 1);
      for (var e4 in this.styles) t4[e4] || delete this.styles[e4];
    }, toObject: function(t4) {
      return this.callSuper("toObject", ["minWidth", "splitByGrapheme"].concat(t4));
    } }), e3.Textbox.fromObject = function(t4, i3) {
      return e3.Object._fromObject("Textbox", t4, i3, "text");
    };
  }(e2), function() {
    var t3 = x3.controlsUtils, e3 = t3.scaleSkewCursorStyleHandler, i3 = t3.scaleCursorStyleHandler, r4 = t3.scalingEqually, n4 = t3.scalingYOrSkewingX, s4 = t3.scalingXOrSkewingY, o4 = t3.scaleOrSkewActionName, a4 = x3.Object.prototype.controls;
    if (a4.ml = new x3.Control({ x: -0.5, y: 0, cursorStyleHandler: e3, actionHandler: s4, getActionName: o4 }), a4.mr = new x3.Control({ x: 0.5, y: 0, cursorStyleHandler: e3, actionHandler: s4, getActionName: o4 }), a4.mb = new x3.Control({ x: 0, y: 0.5, cursorStyleHandler: e3, actionHandler: n4, getActionName: o4 }), a4.mt = new x3.Control({ x: 0, y: -0.5, cursorStyleHandler: e3, actionHandler: n4, getActionName: o4 }), a4.tl = new x3.Control({ x: -0.5, y: -0.5, cursorStyleHandler: i3, actionHandler: r4 }), a4.tr = new x3.Control({ x: 0.5, y: -0.5, cursorStyleHandler: i3, actionHandler: r4 }), a4.bl = new x3.Control({ x: -0.5, y: 0.5, cursorStyleHandler: i3, actionHandler: r4 }), a4.br = new x3.Control({ x: 0.5, y: 0.5, cursorStyleHandler: i3, actionHandler: r4 }), a4.mtr = new x3.Control({ x: 0, y: -0.5, actionHandler: t3.rotationWithSnapping, cursorStyleHandler: t3.rotationStyleHandler, offsetY: -40, withConnection: true, actionName: "rotate" }), x3.Textbox) {
      var h4 = x3.Textbox.prototype.controls = {};
      h4.mtr = a4.mtr, h4.tr = a4.tr, h4.br = a4.br, h4.tl = a4.tl, h4.bl = a4.bl, h4.mt = a4.mt, h4.mb = a4.mb, h4.mr = new x3.Control({ x: 0.5, y: 0, actionHandler: t3.changeWidth, cursorStyleHandler: e3, actionName: "resizing" }), h4.ml = new x3.Control({ x: -0.5, y: 0, actionHandler: t3.changeWidth, cursorStyleHandler: e3, actionName: "resizing" });
    }
  }();
}, 192: () => {
}, 898: () => {
}, 245: () => {
} };
var d = {};
function f(t2) {
  var e2 = d[t2];
  if (void 0 !== e2) return e2.exports;
  var i2 = d[t2] = { exports: {} };
  return u[t2](i2, i2.exports, f), i2.exports;
}
f.d = (t2, e2) => {
  for (var i2 in e2) f.o(e2, i2) && !f.o(t2, i2) && Object.defineProperty(t2, i2, { enumerable: true, get: e2[i2] });
}, f.o = (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2);
var g = {};
(() => {
  let t2;
  f.d(g, { R: () => t2 }), t2 = "undefined" != typeof document && "undefined" != typeof window ? f(653).fabric : { version: "5.2.1" };
})();
var p = g.R;
var m = class {
  get mediaType() {
    return this._mediaType;
  }
  get drawingLayerId() {
    return this._drawingLayerId;
  }
  constructor(t2, e2) {
    this._zIndex = null, this._drawingLayer = null, this._drawingLayerId = null, this._mapStyle = /* @__PURE__ */ new Map(), this.mapEvent_Callbacks = /* @__PURE__ */ new Map([["selected", /* @__PURE__ */ new Map()], ["deselected", /* @__PURE__ */ new Map()], ["mousedown", /* @__PURE__ */ new Map()], ["mouseup", /* @__PURE__ */ new Map()], ["dblclick", /* @__PURE__ */ new Map()], ["mouseover", /* @__PURE__ */ new Map()], ["mouseout", /* @__PURE__ */ new Map()]]), this.mapNoteName_Content = /* @__PURE__ */ new Map([]), this.isDrawingItem = true, this._setFabricObject(t2), this._mediaType = t2.type, this.styleSelector = "default", this.styleId = e2;
  }
  _setFabricObject(t2) {
    this._fabricObject = t2, this._fabricObject.on("selected", () => {
      this.styleSelector = "selected";
    }), this._fabricObject.on("deselected", () => {
      this._fabricObject.canvas && this._fabricObject.canvas.getActiveObjects().includes(this._fabricObject) ? this.styleSelector = "selected" : this.styleSelector = "default", "textbox" === this._fabricObject.type && (this._fabricObject.isEditing && this._fabricObject.exitEditing(), this._fabricObject.selected = false);
    }), t2.getDrawingItem = () => this;
  }
  _getFabricObject() {
    return this._fabricObject;
  }
  _on(t2, e2) {
    if (!e2) return;
    const i2 = t2.toLowerCase(), r3 = this.mapEvent_Callbacks.get(i2);
    if (!r3) throw new Error(`Event '${t2}' does not exist.`);
    let n3 = r3.get(e2);
    n3 || (n3 = (t3) => {
      const i3 = t3.e;
      if (!i3) return void (e2 && e2.apply(this, [{ targetItem: this, itemClientX: null, itemClientY: null, itemPageX: null, itemPageY: null }]));
      const r4 = { targetItem: this, itemClientX: null, itemClientY: null, itemPageX: null, itemPageY: null };
      if (this._drawingLayer) {
        let t4, e3, n4, s3;
        const o3 = i3.target.getBoundingClientRect();
        t4 = o3.left, e3 = o3.top, n4 = t4 + window.scrollX, s3 = e3 + window.scrollY;
        const a3 = this._drawingLayer.fabricCanvas.lowerCanvasEl.width, h3 = this._drawingLayer.fabricCanvas.lowerCanvasEl.height, l3 = parseFloat(window.getComputedStyle(this._drawingLayer.fabricCanvas.lowerCanvasEl).width), c3 = parseFloat(window.getComputedStyle(this._drawingLayer.fabricCanvas.lowerCanvasEl).height), u3 = l3 / c3, d3 = a3 / h3, f3 = this._drawingLayer._getObjectFit();
        let g3, p3, m3, v3, _3 = 1;
        if ("contain" === f3) u3 < d3 ? (_3 = l3 / a3, g3 = t4 + this.get("x") * _3, p3 = e3 + this.get("y") * _3 + (c3 - h3 * _3) / 2, m3 = n4 + this.get("x") * _3, v3 = s3 + this.get("y") * _3 + (c3 - h3 * _3) / 2) : (_3 = c3 / h3, g3 = t4 + this.get("x") * _3 + (l3 - a3 * _3) / 2, p3 = e3 + this.get("y") * _3, m3 = n4 + this.get("x") * _3 + (l3 - a3 * _3) / 2, v3 = s3 + this.get("y") * _3);
        else if ("cover" === f3) if (u3 < d3) {
          _3 = c3 / h3;
          let i4 = this.get("x") * _3 - (a3 * _3 - l3) / 2;
          i4 = Math.max(i4, 0), i4 = Math.min(i4, l3), g3 = t4 + i4, p3 = e3 + this.get("y") * _3, m3 = n4 + i4, v3 = s3 + this.get("y") * _3;
        } else {
          _3 = l3 / a3;
          let i4 = this.get("y") * _3 - (h3 * _3 - c3) / 2;
          i4 = Math.max(i4, 0), i4 = Math.min(i4, c3), g3 = t4 + this.get("x") * _3, p3 = e3 + i4, m3 = n4 + this.get("x") * _3, v3 = s3 + i4;
        }
        r4.itemClientX = Math.round(g3), r4.itemClientY = Math.round(p3), r4.itemPageX = Math.round(m3), r4.itemPageY = Math.round(v3);
      }
      for (let t4 of Object.getOwnPropertyNames(r4)) Object.defineProperty(i3, t4, { value: r4[t4], writable: true });
      e2 && e2.apply(this, [i3]);
    }, r3.set(e2, n3), this._fabricObject.on("dblclick" === i2 ? "mousedblclick" : i2, n3));
  }
  on(t2, e2) {
    this._on(t2, e2);
  }
  _off(t2, e2) {
    const i2 = t2.toLowerCase(), r3 = this.mapEvent_Callbacks.get(i2);
    if (!r3) throw new Error(`Event '${t2}' does not exist.`);
    let n3 = r3.get(e2);
    n3 && (r3.delete(e2), this._fabricObject.off("dblclick" === i2 ? "mousedblclick" : i2, n3));
  }
  off(t2, e2) {
    this._off(t2, e2);
  }
  _setEditable(t2) {
    const e2 = this._fabricObject;
    t2 ? (e2.selectable = true, e2.hasControls = true, e2.hoverCursor = null) : (e2.selectable = false, e2.hasControls = false, e2.hoverCursor = "default");
  }
  hasNote(t2) {
    return this.mapNoteName_Content.has(t2);
  }
  addNote(t2, e2) {
    if (this.hasNote(t2.name) && !e2) throw new Error("A note with the same name already exists, please use a different name.");
    const i2 = t2.content ? JSON.parse(JSON.stringify(t2.content)) : t2.content;
    this.mapNoteName_Content.set(t2.name, [i2]);
  }
  getNote(t2) {
    const e2 = this.mapNoteName_Content.get(t2);
    return e2 ? 1 === e2.length ? { name: t2, content: e2[0] ? JSON.parse(JSON.stringify(e2[0])) : e2[0] } : { name: t2, content: JSON.parse(JSON.stringify(e2)) } : null;
  }
  getNotes() {
    const t2 = [];
    for (let e2 of this.mapNoteName_Content) {
      let i2 = 1 === e2[1].length ? e2[1][0] : e2[1];
      i2 = i2 ? JSON.parse(JSON.stringify(i2)) : i2, t2.push({ name: e2[0], content: i2 });
    }
    return t2;
  }
  updateNote(t2, e2, i2) {
    const r3 = this.mapNoteName_Content.get(t2);
    if (!r3) throw new Error("The note name does not exist.");
    i2 || (r3.length = 0), e2 = e2 ? JSON.parse(JSON.stringify(e2)) : e2, r3.push(e2);
  }
  deleteNote(t2) {
    this.mapNoteName_Content.delete(t2);
  }
  clearNotes() {
    this.mapNoteName_Content.clear();
  }
  _extendSet(t2, e2) {
    return false;
  }
  _extendGet(t2) {
  }
  set(t2, e2) {
    if (!this._extendSet(t2, e2)) if ("x" === t2) {
      const t3 = this._fabricObject.group;
      t3 ? (this._fabricObject.set("left", e2 - t3.left - t3.width / 2), t3.addWithUpdate()) : this._fabricObject.set("left", e2);
    } else if ("y" === t2) {
      const t3 = this._fabricObject.group;
      t3 ? (this._fabricObject.set("top", e2 - t3.top - t3.height / 2), t3.addWithUpdate()) : this._fabricObject.set("top", e2);
    } else "styleId" === t2 ? this.styleId = e2 : this._fabricObject.set(t2, e2);
    ["vertices", "startPoint", "endPoint", "x", "y", "left", "top", "width", "height", "scaleX", "scaleY", "skewX", "skewY", "padding", "angle", "strokeWidth"].includes(t2) && this._fabricObject.setCoords();
  }
  get(t2) {
    let e2 = this._extendGet(t2);
    if (void 0 === e2) if ("x" === t2) {
      const t3 = this._fabricObject.group;
      e2 = t3 ? this._fabricObject.get("left") + t3.left + t3.width / 2 : this._fabricObject.get("left");
    } else if ("y" === t2) {
      const t3 = this._fabricObject.group;
      e2 = t3 ? this._fabricObject.get("top") + t3.top + t3.height / 2 : this._fabricObject.get("top");
    } else e2 = ["type", "mediaType"].includes(t2) ? this.mediaType : "styleSelector" === t2 ? this.styleSelector : "styleId" === t2 ? this.styleId : "drawingLayerId" === t2 ? this.drawingLayerId : this._fabricObject.get(t2);
    return e2;
  }
  setAttribute(t2, e2) {
    this.set(t2, e2);
  }
  getAttribute(t2) {
    return this.get(t2);
  }
};
m.arrMediaTypes = ["rect", "arc", "polygon", "image", "text", "line", "path"], m.arrStyleSelectors = ["default", "selected"];
function v(t2, e2, i2) {
  let r3 = i2.points[this.pointIndex].x - i2.pathOffset.x, n3 = i2.points[this.pointIndex].y - i2.pathOffset.y;
  return p.util.transformPoint({ x: r3, y: n3 }, i2.calcTransformMatrix());
}
function _(t2) {
  let e2 = new p.Point(t2.strokeUniform ? 1 / t2.scaleX : 1, t2.strokeUniform ? 1 / t2.scaleY : 1).multiply(t2.strokeWidth);
  return new p.Point(t2.width + e2.x, t2.height + e2.y);
}
function y(t2, e2, i2, r3) {
  let n3 = e2.target, s3 = n3.controls[n3.__corner], o3 = n3.toLocalPoint(new p.Point(i2, r3), "center", "center"), a3 = _(n3), h3 = n3._getTransformedDimensions(0, 0), l3 = { x: o3.x * a3.x / h3.x + n3.pathOffset.x, y: o3.y * a3.y / h3.y + n3.pathOffset.y };
  return n3.points[s3.pointIndex] = l3, true;
}
function b(t2, e2) {
  return function(i2, r3, n3, s3) {
    let o3 = r3.target, a3 = p.util.transformPoint({ x: o3.points[t2].x - o3.pathOffset.x, y: o3.points[t2].y - o3.pathOffset.y }, o3.calcTransformMatrix()), h3 = e2(i2, r3, n3, s3);
    o3._setPositionDimensions({});
    let l3 = _(o3), c3 = (o3.points[t2].x - o3.pathOffset.x) / l3.x, u3 = (o3.points[t2].y - o3.pathOffset.y) / l3.y;
    return o3.setPositionByOrigin(a3, c3 + 0.5, u3 + 0.5), h3;
  };
}
var w = class extends m {
  constructor(t2, e2) {
    super(new p.Polygon(t2, { objectCaching: false }), e2);
    const i2 = this._fabricObject;
    let r3 = i2.points.length - 1;
    i2.controls = i2.points.reduce(function(t3, e3, i3) {
      return t3["p" + i3] = new p.Control({ positionHandler: v, actionHandler: b(i3 > 0 ? i3 - 1 : r3, y), actionName: "modifyPolygon", pointIndex: i3 }), t3;
    }, {});
  }
  _extendSet(t2, e2) {
    if ("vertices" === t2) {
      const t3 = this._fabricObject;
      if (t3.group) {
        const i3 = t3.group;
        t3.points = e2.map((t4) => ({ x: t4.x - i3.left - i3.width / 2, y: t4.y - i3.top - i3.height / 2 })), i3.addWithUpdate();
      } else t3.points = e2;
      const i2 = t3.points.length - 1;
      return t3.controls = t3.points.reduce(function(t4, e3, r3) {
        return t4["p" + r3] = new p.Control({ positionHandler: v, actionHandler: b(r3 > 0 ? r3 - 1 : i2, y), actionName: "modifyPolygon", pointIndex: r3 }), t4;
      }, {}), t3._setPositionDimensions({}), true;
    }
  }
  _extendGet(t2) {
    if ("vertices" === t2) {
      const t3 = [], e2 = this._fabricObject;
      if (e2.selectable && !e2.group) for (let i2 in e2.oCoords) t3.push({ x: e2.oCoords[i2].x, y: e2.oCoords[i2].y });
      else for (let i2 of e2.points) {
        let r3 = i2.x - e2.pathOffset.x, n3 = i2.y - e2.pathOffset.y;
        const s3 = p.util.transformPoint({ x: r3, y: n3 }, e2.calcTransformMatrix());
        t3.push({ x: s3.x, y: s3.y });
      }
      return t3;
    }
  }
};
var C = (t2) => {
  let e2 = ((t3) => t3.split("\n").map((t4) => t4.split("	")))(t2);
  return ((t3) => {
    for (let e3 = 0; ; e3++) {
      let i2 = -1;
      for (let r3 = 0; r3 < t3.length; r3++) {
        let n3 = t3[r3][e3];
        void 0 !== n3 && (n3.length > i2 && (i2 = n3.length));
      }
      if (-1 === i2) break;
      for (let r3 = 0; r3 < t3.length; r3++) {
        if (e3 >= t3[r3].length - 1) continue;
        let n3 = " ".repeat(i2 + 2 - t3[r3][e3].length);
        t3[r3][e3] = t3[r3][e3].concat(n3);
      }
    }
  })(e2), ((t3) => {
    let e3 = "";
    for (let i2 = 0; i2 < t3.length; i2++) e3 = e3.concat(...t3[i2], i2 === t3.length - 1 ? "" : "\n");
    return e3;
  })(e2);
};
var S = class extends m {
  constructor(t2, e2, i2, r3, n3) {
    if ("number" != typeof r3 || r3 <= 0) throw new RangeError("Invalid width.");
    super(new p.Textbox(C(t2), { left: e2, top: i2, width: r3 }), n3), this._mediaType = "text", this._text = t2;
  }
  _extendSet(t2, e2) {
    if ("text" === t2) return this._text = e2, this._fabricObject.set("text", C(e2)), true;
  }
  _extendGet(t2) {
    if ("text" === t2) return this._text;
  }
};
"undefined" != typeof document && "undefined" != typeof window && (p.StaticCanvas.prototype.dispose = function() {
  return this.isRendering && (p.util.cancelAnimFrame(this.isRendering), this.isRendering = 0), this.forEachObject(function(t2) {
    t2.dispose && t2.dispose();
  }), this._objects = [], this.backgroundImage && this.backgroundImage.dispose && this.backgroundImage.dispose(), this.backgroundImage = null, this.overlayImage && this.overlayImage.dispose && this.overlayImage.dispose(), this.overlayImage = null, this._iTextInstances = null, this.contextContainer = null, this.lowerCanvasEl.classList.remove("lower-canvas"), delete this._originalCanvasStyle, this.lowerCanvasEl.setAttribute("width", this.width), this.lowerCanvasEl.setAttribute("height", this.height), p.util.cleanUpJsdomNode(this.lowerCanvasEl), this.lowerCanvasEl = void 0, this;
}, p.Object.prototype.transparentCorners = false, p.Object.prototype.cornerSize = 20, p.Object.prototype.touchCornerSize = 100, p.Object.prototype.cornerColor = "rgb(254,142,20)", p.Object.prototype.cornerStyle = "circle", p.Object.prototype.strokeUniform = true, p.Object.prototype.hasBorders = false, p.Canvas.prototype.containerClass = "", p.Canvas.prototype.getPointer = function(t2, e2) {
  if (this._absolutePointer && !e2) return this._absolutePointer;
  if (this._pointer && e2) return this._pointer;
  var i2, r3 = this.upperCanvasEl, n3 = p.util.getPointer(t2, r3), s3 = r3.getBoundingClientRect(), o3 = s3.width || 0, a3 = s3.height || 0;
  o3 && a3 || ("top" in s3 && "bottom" in s3 && (a3 = Math.abs(s3.top - s3.bottom)), "right" in s3 && "left" in s3 && (o3 = Math.abs(s3.right - s3.left))), this.calcOffset(), n3.x = n3.x - this._offset.left, n3.y = n3.y - this._offset.top, e2 || (n3 = this.restorePointerVpt(n3));
  var h3 = this.getRetinaScaling();
  if (1 !== h3 && (n3.x /= h3, n3.y /= h3), 0 !== o3 && 0 !== a3) {
    var l3 = window.getComputedStyle(r3).objectFit, c3 = r3.width, u3 = r3.height, d3 = o3, f3 = a3;
    i2 = { width: c3 / d3, height: u3 / f3 };
    var g3, m3, v3 = c3 / u3, _3 = d3 / f3;
    return "contain" === l3 ? v3 > _3 ? (g3 = d3, m3 = d3 / v3, { x: n3.x * i2.width, y: (n3.y - (f3 - m3) / 2) * i2.width }) : (g3 = f3 * v3, m3 = f3, { x: (n3.x - (d3 - g3) / 2) * i2.height, y: n3.y * i2.height }) : "cover" === l3 ? v3 > _3 ? { x: (c3 - i2.height * d3) / 2 + n3.x * i2.height, y: n3.y * i2.height } : { x: n3.x * i2.width, y: (u3 - i2.width * f3) / 2 + n3.y * i2.width } : { x: n3.x * i2.width, y: n3.y * i2.height };
  }
  return i2 = { width: 1, height: 1 }, { x: n3.x * i2.width, y: n3.y * i2.height };
}, p.Canvas.prototype._onTouchStart = function(t2) {
  var e2 = this.findTarget(t2);
  !this.allowTouchScrolling && t2.cancelable && t2.preventDefault && t2.preventDefault(), e2 && t2.cancelable && t2.preventDefault && t2.preventDefault(), null === this.mainTouchId && (this.mainTouchId = this.getPointerId(t2)), this.__onMouseDown(t2), this._resetTransformEventData();
  var i2 = this.upperCanvasEl, r3 = this._getEventPrefix();
  p.util.addListener(p.document, "touchend", this._onTouchEnd, { passive: false }), p.util.addListener(p.document, "touchmove", this._onMouseMove, { passive: false }), p.util.removeListener(i2, r3 + "down", this._onMouseDown);
}, p.Textbox.prototype._wrapLine = function(t2, e2, i2, r3) {
  const n3 = t2.match(/[\u3040-\u30ff\u3400-\u4dbf\u4e00-\u9fff\uf900-\ufaff\uff66-\uff9f]/g), s3 = !(!n3 || !n3.length);
  var o3 = 0, a3 = this.splitByGrapheme || s3, h3 = [], l3 = [], c3 = a3 ? p.util.string.graphemeSplit(t2) : t2.split(this._wordJoiners), u3 = "", d3 = 0, f3 = a3 ? "" : " ", g3 = 0, m3 = 0, v3 = 0, _3 = true, y3 = this._getWidthOfCharSpacing();
  r3 = r3 || 0;
  0 === c3.length && c3.push([]), i2 -= r3;
  for (var b3 = 0; b3 < c3.length; b3++) u3 = a3 ? c3[b3] : p.util.string.graphemeSplit(c3[b3]), g3 = this._measureWord(u3, e2, d3), d3 += u3.length, (o3 += m3 + g3 - y3) > i2 && !_3 ? (h3.push(l3), l3 = [], o3 = g3, _3 = true) : o3 += y3, _3 || a3 || l3.push(f3), l3 = l3.concat(u3), m3 = a3 ? 0 : this._measureWord([f3], e2, d3), d3++, _3 = false, g3 > v3 && (v3 = g3);
  return b3 && h3.push(l3), v3 + r3 > this.dynamicMinWidth && (this.dynamicMinWidth = v3 - y3 + r3), h3;
});
var x = class {
  constructor(t2, e2, i2, r3) {
    let n3, s3;
    switch (this.mapMediaType_Style = /* @__PURE__ */ new Map(), this.mode = "viewer", this.onSelectionChange = null, this._arrDrwaingItem = [], this._arrFabricObject = [], this._visible = true, t2.hasOwnProperty("getFabricCanvas") ? this.fabricCanvas = t2.getFabricCanvas() : (this.fabricCanvas = new p.Canvas(t2, Object.assign(r3, { allowTouchScrolling: true })), this.fabricCanvas.setDimensions({ width: "100%", height: "100%" }, { cssOnly: true }), this.fabricCanvas.lowerCanvasEl.className = "", this.fabricCanvas.upperCanvasEl.className = "", this.fabricCanvas.on("selection:created", function(t3) {
      const e3 = t3.selected, i3 = [];
      for (let t4 of e3) {
        const e4 = t4.getDrawingItem()._drawingLayer;
        e4 && !i3.includes(e4) && i3.push(e4);
      }
      for (let t4 of i3) {
        const i4 = [];
        for (let r4 of e3) {
          const e4 = r4.getDrawingItem();
          e4._drawingLayer === t4 && i4.push(e4);
        }
        setTimeout(() => {
          t4.onSelectionChange && t4.onSelectionChange(i4, []);
        }, 0);
      }
    }), this.fabricCanvas.on("before:selection:cleared", function(t3) {
      const e3 = this.getActiveObjects(), i3 = [];
      for (let t4 of e3) {
        const e4 = t4.getDrawingItem()._drawingLayer;
        e4 && !i3.includes(e4) && i3.push(e4);
      }
      for (let t4 of i3) {
        const i4 = [];
        for (let r4 of e3) {
          const e4 = r4.getDrawingItem();
          e4._drawingLayer === t4 && i4.push(e4);
        }
        setTimeout(() => {
          const e4 = [];
          for (let r4 of i4) t4.hasDrawingItem(r4) && e4.push(r4);
          e4.length > 0 && t4.onSelectionChange && t4.onSelectionChange([], e4);
        }, 0);
      }
    }), this.fabricCanvas.on("selection:updated", function(t3) {
      const e3 = t3.selected, i3 = t3.deselected, r4 = [];
      for (let t4 of e3) {
        const e4 = t4.getDrawingItem()._drawingLayer;
        e4 && !r4.includes(e4) && r4.push(e4);
      }
      for (let t4 of i3) {
        const e4 = t4.getDrawingItem()._drawingLayer;
        e4 && !r4.includes(e4) && r4.push(e4);
      }
      for (let t4 of r4) {
        const r5 = [], n4 = [];
        for (let i4 of e3) {
          const e4 = i4.getDrawingItem();
          e4._drawingLayer === t4 && r5.push(e4);
        }
        for (let e4 of i3) {
          const i4 = e4.getDrawingItem();
          i4._drawingLayer === t4 && n4.push(i4);
        }
        setTimeout(() => {
          t4.onSelectionChange && t4.onSelectionChange(r5, n4);
        }, 0);
      }
    }), this.fabricCanvas.wrapperEl.style.position = "absolute", t2.getFabricCanvas = () => this.fabricCanvas), this.id = e2, this._mapDrawingStyles = i2, e2) {
      case 1:
        n3 = i2.get(1), s3 = i2.get(5);
        break;
      case 2:
        n3 = i2.get(2), s3 = i2.get(6);
        break;
      case 3:
        n3 = i2.get(3), s3 = i2.get(7);
        break;
      default:
        n3 = i2.get(4), s3 = i2.get(8);
    }
    for (let t3 of m.arrMediaTypes) this.mapMediaType_Style.set(t3, { default: n3, selected: s3 });
  }
  getId() {
    return this.id;
  }
  _getDrawingStyle(t2, e2) {
    if ("number" != typeof t2) throw new Error("Invalid style id.");
    const i2 = this._mapDrawingStyles.get(t2);
    return i2 ? e2 ? JSON.parse(JSON.stringify(i2)) : i2 : null;
  }
  setVisible(t2) {
    if (t2) {
      for (let t3 of this._arrFabricObject) t3.visible = true;
      this._visible = true;
    } else {
      for (let t3 of this._arrFabricObject) t3.visible = false;
      this._visible = false;
    }
    this.fabricCanvas.renderAll();
  }
  isVisible() {
    return this._visible;
  }
  _getItemCurrentStyleId(t2) {
    return t2.styleId ? t2.styleId : this.mapMediaType_Style.get(t2._mediaType)[t2.styleSelector].styleId;
  }
  _getItemCurrentStyle(t2) {
    if (t2.styleId) return this._getDrawingStyle(t2.styleId);
    const e2 = t2._mapStyle.get(t2.styleSelector);
    return e2 || null;
  }
  _changeMediaTypeCurStyleInStyleSelector(t2, e2, i2, r3) {
    let n3;
    switch (t2) {
      case "rect":
        n3 = this.fabricCanvas.getObjects("rect");
        break;
      case "arc":
        n3 = this.fabricCanvas.getObjects("circle");
        break;
      case "polygon":
        n3 = this.fabricCanvas.getObjects("polygon");
        break;
      case "image":
        n3 = this.fabricCanvas.getObjects("image");
        break;
      case "text":
        n3 = this.fabricCanvas.getObjects("textbox");
        break;
      case "line":
        n3 = this.fabricCanvas.getObjects("line");
        break;
      case "path":
        n3 = this.fabricCanvas.getObjects("path");
    }
    for (let t3 of n3) {
      if (!this._arrFabricObject.includes(t3)) continue;
      const r4 = t3.getDrawingItem();
      r4.styleSelector === e2 && this._changeItemStyle(r4, i2, true);
    }
    r3 || this.fabricCanvas.renderAll();
  }
  _changeItemStyle(t2, e2, i2) {
    if (!t2 || !e2) return;
    const r3 = t2._getFabricObject();
    "number" == typeof t2.styleId && (e2 = this._getDrawingStyle(t2.styleId)), r3.strokeWidth = e2.lineWidth, "fill" === e2.paintMode ? (r3.fill = e2.fillStyle, r3.stroke = e2.fillStyle) : "stroke" === e2.paintMode ? (r3.fill = "transparent", r3.stroke = e2.strokeStyle) : "strokeAndFill" === e2.paintMode && (r3.fill = e2.fillStyle, r3.stroke = e2.strokeStyle), r3.fontFamily && (r3.fontFamily = e2.fontFamily), r3.fontSize && (r3.fontSize = e2.fontSize), r3.group || (r3.dirty = true), i2 || this.fabricCanvas.renderAll();
  }
  _updateGroupItem(t2, e2, i2) {
    if (!t2 || !e2) return;
    const r3 = t2.getChildItems();
    if ("add" === i2) {
      if (r3.includes(e2)) return;
      const i3 = e2._getFabricObject();
      if (this.fabricCanvas.getObjects().includes(i3)) {
        if (!this._arrFabricObject.includes(i3)) throw new Error("Existed in other drawing layers.");
        e2._zIndex = null;
      } else {
        let i4;
        if (e2.styleId) i4 = this._getDrawingStyle(e2.styleId);
        else {
          i4 = this.mapMediaType_Style.get(e2._mediaType)[t2.styleSelector];
          const r4 = () => {
            this._changeItemStyle(e2, this.mapMediaType_Style.get(e2._mediaType).selected, true);
          }, n3 = () => {
            this._changeItemStyle(e2, this.mapMediaType_Style.get(e2._mediaType).default, true);
          };
          e2._on("selected", r4), e2._on("deselected", n3), e2._funcChangeStyleToSelected = r4, e2._funcChangeStyleToDefault = n3;
        }
        e2._drawingLayer = this, e2._drawingLayerId = this.id, this._changeItemStyle(e2, i4, true);
      }
      t2._fabricObject.addWithUpdate(e2._getFabricObject());
    } else {
      if ("remove" !== i2) return;
      if (!r3.includes(e2)) return;
      e2._zIndex = null, e2._drawingLayer = null, e2._drawingLayerId = null, e2._off("selected", e2._funcChangeStyleToSelected), e2._off("deselected", e2._funcChangeStyleToDefault), e2._funcChangeStyleToSelected = null, e2._funcChangeStyleToDefault = null, t2._fabricObject.removeWithUpdate(e2._getFabricObject());
    }
    this.fabricCanvas.renderAll();
  }
  _addDrawingItem(t2, e2) {
    let i2 = t2._getFabricObject();
    const r3 = this.fabricCanvas.getObjects();
    let n3, s3;
    if (r3.includes(i2)) {
      if (this._arrFabricObject.includes(i2)) return;
      throw new Error("Existed in other drawing layers.");
    }
    if ("group" === t2._mediaType) {
      n3 = t2.getChildItems();
      for (let t3 of n3) if (t3._drawingLayer && t3._drawingLayer !== this) throw new Error("The childItems of DT_Group have existed in other drawing layers.");
    }
    if (e2 && "object" == typeof e2 && !Array.isArray(e2)) for (let t3 in e2) i2.set(t3, e2[t3]);
    if (n3) {
      for (let t3 of n3) {
        const e3 = this.mapMediaType_Style.get(t3._mediaType);
        for (let i3 of m.arrStyleSelectors) t3._mapStyle.set(i3, e3[i3]);
        if (t3.styleId) s3 = this._getDrawingStyle(t3.styleId);
        else {
          s3 = e3.default;
          const i3 = () => {
            this._changeItemStyle(t3, this.mapMediaType_Style.get(t3._mediaType).selected, true);
          }, r4 = () => {
            this._changeItemStyle(t3, this.mapMediaType_Style.get(t3._mediaType).default, true);
          };
          t3._on("selected", i3), t3._on("deselected", r4), t3._funcChangeStyleToSelected = i3, t3._funcChangeStyleToDefault = r4;
        }
        t3._drawingLayer = this, t3._drawingLayerId = this.id, this._changeItemStyle(t3, s3, true);
      }
      i2.dirty = true, this.fabricCanvas.renderAll();
    } else {
      const e3 = this.mapMediaType_Style.get(t2._mediaType);
      for (let i3 of m.arrStyleSelectors) t2._mapStyle.set(i3, e3[i3]);
      if (t2.styleId) s3 = this._getDrawingStyle(t2.styleId);
      else {
        s3 = e3.default;
        const i3 = () => {
          this._changeItemStyle(t2, this.mapMediaType_Style.get(t2._mediaType).selected);
        }, r4 = () => {
          this._changeItemStyle(t2, this.mapMediaType_Style.get(t2._mediaType).default);
        };
        t2._on("selected", i3), t2._on("deselected", r4), t2._funcChangeStyleToSelected = i3, t2._funcChangeStyleToDefault = r4;
      }
      this._changeItemStyle(t2, s3);
    }
    t2._zIndex = this.id, t2._drawingLayer = this, t2._drawingLayerId = this.id;
    const o3 = this._arrFabricObject.length;
    let a3 = r3.length;
    if (o3) a3 = r3.indexOf(this._arrFabricObject[o3 - 1]) + 1;
    else for (let e3 = 0; e3 < r3.length; e3++) if (t2._zIndex < r3[e3].getDrawingItem()._zIndex) {
      a3 = e3;
      break;
    }
    this._arrDrwaingItem.push(t2), this._arrFabricObject.push(i2), this._visible ? i2.visible = true : i2.visible = false, this.fabricCanvas.insertAt(i2, a3, false);
  }
  addDrawingItem(t2) {
    if (!t2 || !t2.isDrawingItem) throw TypeError("Illegal drawing item.");
    if ("viewer" === this.mode) t2._setEditable(false);
    else {
      if ("editor" !== this.mode) throw new Error("Illegal 'mode'.");
      t2._setEditable(true);
    }
    this._addDrawingItem(t2);
  }
  addDrawingItems(t2) {
    for (let e2 of t2) this.addDrawingItem(e2);
  }
  removeDrawingItem(t2) {
    if (!t2 || !t2.isDrawingItem) throw TypeError("Illegal drawing item.");
    if (!this.hasDrawingItem(t2)) return;
    if (t2._zIndex = null, t2._drawingLayer = null, t2._drawingLayerId = null, "group" === t2._mediaType) {
      const e3 = t2.getChildItems();
      for (let t3 of e3) t3._zIndex = null, t3._drawingLayer = null, t3._drawingLayerId = null, t3._off("selected", t3._funcChangeStyleToSelected), t3._off("deselected", t3._funcChangeStyleToDefault), t3._funcChangeStyleToSelected = null, t3._funcChangeStyleToDefault = null, t3._mapStyle.clear();
    } else t2._off("selected", t2._funcChangeStyleToSelected), t2._off("deselected", t2._funcChangeStyleToDefault), t2._funcChangeStyleToSelected = null, t2._funcChangeStyleToDefault = null, t2._mapStyle.clear();
    const e2 = t2._getFabricObject();
    "selected" === t2.styleSelector && (e2.group ? e2.group.removeWithUpdate(e2) : this.fabricCanvas._activeObject = null, t2.styleSelector = "default"), this.fabricCanvas.remove(e2), this._arrDrwaingItem.splice(this._arrDrwaingItem.indexOf(t2), 1), this._arrFabricObject.splice(this._arrFabricObject.indexOf(e2), 1);
  }
  removeDrawingItems(t2) {
    for (let e2 of t2) this.removeDrawingItem(e2);
  }
  setDrawingItems(t2) {
    this.clearDrawingItems(), this.addDrawingItems(t2);
  }
  getDrawingItems(t2) {
    return t2 && "function" == typeof t2 ? this._arrDrwaingItem.filter(t2) : Array.from(this._arrDrwaingItem);
  }
  getSelectedDrawingItems() {
    const t2 = this.fabricCanvas.getActiveObjects(), e2 = [];
    for (let i2 of t2) this._arrFabricObject.includes(i2) && e2.push(i2.getDrawingItem());
    return e2;
  }
  hasDrawingItem(t2) {
    if (!t2 || !t2.isDrawingItem) throw TypeError("Illegal drawing item.");
    return this._arrDrwaingItem.includes(t2);
  }
  clearDrawingItems() {
    this.removeDrawingItems(Array.from(this._arrDrwaingItem));
  }
  setDrawingStyle(t2, e2, i2) {
    e2 = e2 ? e2.toLocaleLowerCase() : "all", i2 = i2 ? i2.toLocaleLowerCase() : "all";
    let r3, n3 = this._getDrawingStyle(t2);
    if ("all" === e2) {
      const t3 = this.mapMediaType_Style.keys();
      for (let e3 of t3) if (r3 = this.mapMediaType_Style.get(e3), "all" === i2) for (let t4 of m.arrStyleSelectors) {
        this._changeMediaTypeCurStyleInStyleSelector(e3, t4, n3, true), r3[t4] = n3;
        for (let e4 of this._arrDrwaingItem) e4._mapStyle.set(t4, n3);
      }
      else {
        this._changeMediaTypeCurStyleInStyleSelector(e3, i2, n3, true), r3[i2] = n3;
        for (let t4 of this._arrDrwaingItem) t4._mapStyle.set(i2, n3);
      }
      this.fabricCanvas.renderAll();
    } else if (r3 = this.mapMediaType_Style.get(e2), "all" === i2) for (let t3 of m.arrStyleSelectors) {
      this._changeMediaTypeCurStyleInStyleSelector(e2, t3, n3, true), r3[t3] = n3;
      for (let i3 of this._arrDrwaingItem) i3._mediaType === e2 && i3._mapStyle.set(t3, n3);
    }
    else {
      this._changeMediaTypeCurStyleInStyleSelector(e2, i2, n3, true), r3[i2] = n3;
      for (let t3 of this._arrDrwaingItem) t3._mediaType === e2 && t3._mapStyle.set(i2, n3);
    }
  }
  setMode(t2) {
    if ("viewer" === (t2 = t2.toLocaleLowerCase())) {
      for (let t3 of this._arrDrwaingItem) t3._setEditable(false);
      this.fabricCanvas.discardActiveObject(), this.fabricCanvas.renderAll(), this.mode = "viewer";
    } else {
      if ("editor" !== t2) throw new RangeError("Invalid value.");
      for (let t3 of this._arrDrwaingItem) t3._setEditable(true);
      this.mode = "editor";
    }
    this._manager._switchPointerEvent();
  }
  getMode() {
    return this.mode;
  }
  _setDimensions(t2, e2) {
    this.fabricCanvas.setDimensions(t2, e2);
  }
  _setObjectFit(t2) {
    if (t2 = t2.toLowerCase(), !["contain", "cover"].includes(t2)) throw new Error(`Unsupported value '${t2}'.`);
    this.fabricCanvas.lowerCanvasEl.style.objectFit = t2, this.fabricCanvas.upperCanvasEl.style.objectFit = t2;
  }
  _getObjectFit() {
    return this.fabricCanvas.lowerCanvasEl.style.objectFit;
  }
  renderAll() {
    for (let t2 of this._arrDrwaingItem) {
      const e2 = this._getItemCurrentStyle(t2);
      this._changeItemStyle(t2, e2, true);
    }
    this.fabricCanvas.renderAll();
  }
  dispose() {
    this.clearDrawingItems(), 1 === this._manager._arrDrawingLayer.length && (this.fabricCanvas.wrapperEl.style.pointerEvents = "none", this.fabricCanvas.dispose(), this._arrDrwaingItem.length = 0, this._arrFabricObject.length = 0);
  }
};
var T = class {
  constructor() {
    this._arrDrawingLayer = [], this._mapDrawingStyles = /* @__PURE__ */ new Map([[1, { id: 1, lineWidth: 4, fillStyle: "rgba(73, 173, 245, 0.3)", strokeStyle: "rgba(73, 173, 245, 1)", paintMode: "stroke", fontFamily: "consolas", fontSize: 40 }], [2, { id: 2, lineWidth: 2, fillStyle: "rgba(73, 245, 73, 0.3)", strokeStyle: "rgba(73, 245, 73, 0.9)", paintMode: "strokeAndFill", fontFamily: "consolas", fontSize: 40 }], [3, { id: 3, lineWidth: 2, fillStyle: "rgba(254, 180, 32, 0.3)", strokeStyle: "rgba(254, 180, 32, 0.9)", paintMode: "strokeAndFill", fontFamily: "consolas", fontSize: 40 }], [4, { id: 4, lineWidth: 2, fillStyle: "rgba(245, 236, 73, 0.3)", strokeStyle: "rgba(245, 236, 73, 1)", paintMode: "stroke", fontFamily: "consolas", fontSize: 40 }], [5, { id: 5, lineWidth: 4, fillStyle: "rgba(73, 173, 245, 0.3)", strokeStyle: "rgba(73, 173, 245, 1)", paintMode: "strokeAndFill", fontFamily: "consolas", fontSize: 40 }], [6, { id: 6, lineWidth: 2, fillStyle: "rgba(73, 245, 73, 0.3)", strokeStyle: "rgba(73, 245, 73, 0.9)", paintMode: "strokeAndFill", fontFamily: "consolas", fontSize: 40 }], [7, { id: 7, lineWidth: 2, fillStyle: "rgba(254, 180, 32, 0.3)", strokeStyle: "rgba(254, 180, 32, 1)", paintMode: "strokeAndFill", fontFamily: "consolas", fontSize: 40 }], [8, { id: 8, lineWidth: 2, fillStyle: "rgba(245, 236, 73, 0.3)", strokeStyle: "rgba(245, 236, 73, 1)", paintMode: "strokeAndFill", fontFamily: "consolas", fontSize: 40 }]]), this._defaultStyleTemplate = { lineWidth: 2, fillStyle: "rgba(245, 236, 73, 0.3)", strokeStyle: "rgba(245, 236, 73, 1)", paintMode: "stroke", fontFamily: "consolas", fontSize: 40 };
  }
  createDrawingStyle(t2) {
    if (!t2) throw new Error("Invalid style definition.");
    let e2;
    if (t2.hasOwnProperty("id")) {
      if (this._mapDrawingStyles.has(t2.id)) throw new Error("Existing drawing style id.");
      e2 = t2.id;
    } else {
      let t3 = 100;
      for (; this._mapDrawingStyles.has(t3); ) t3++;
      e2 = t3;
    }
    const i2 = JSON.parse(JSON.stringify(t2));
    i2.id = e2;
    for (let t3 in this._defaultStyleTemplate) i2.hasOwnProperty(t3) || (i2[t3] = this._defaultStyleTemplate[t3]);
    return this._mapDrawingStyles.set(e2, i2), i2.id;
  }
  _getDrawingStyle(t2, e2) {
    if ("number" != typeof t2) throw new Error("Invalid style id.");
    const i2 = this._mapDrawingStyles.get(t2);
    return i2 ? e2 ? JSON.parse(JSON.stringify(i2)) : i2 : null;
  }
  getDrawingStyle(t2) {
    return this._getDrawingStyle(t2, true);
  }
  getDrawingStyles() {
    return JSON.parse(JSON.stringify(Array.from(this._mapDrawingStyles.values())));
  }
  _updateDrawingStyle(t2, e2) {
    const i2 = this._mapDrawingStyles.get(t2);
    if (i2) for (let t3 in e2) i2.hasOwnProperty(t3) && (i2[t3] = e2[t3]);
  }
  updateDrawingStyle(t2, e2) {
    this._updateDrawingStyle(t2, e2);
    for (let t3 of this._arrDrawingLayer) t3.renderAll();
  }
  createDrawingLayer(t2, e2) {
    const i2 = (t3) => {
      for (let e3 of this._arrDrawingLayer) if (e3.getId() === t3) return true;
      return false;
    };
    if (void 0 === e2) {
      for (let t3 = 100; ; t3++) if (!i2(t3)) {
        e2 = t3;
        break;
      }
    } else if (i2(e2)) throw new Error("Existed drawing layer id.");
    const r3 = new x(t2, e2, this._mapDrawingStyles, { enableRetinaScaling: false });
    return r3._manager = this, this._arrDrawingLayer.push(r3), this._switchPointerEvent(), r3;
  }
  deleteDrawingLayer(t2) {
    const e2 = this.getDrawingLayer(t2);
    if (!e2) return;
    const i2 = this._arrDrawingLayer;
    e2.dispose(), i2.splice(i2.indexOf(e2), 1), this._switchPointerEvent();
  }
  clearDrawingLayers() {
    for (let t2 of this._arrDrawingLayer) t2.dispose();
    this._arrDrawingLayer.length = 0;
  }
  getDrawingLayer(t2) {
    for (let e2 of this._arrDrawingLayer) if (e2.getId() === t2) return e2;
    return null;
  }
  getDrawingLayers() {
    return Array.from(this._arrDrawingLayer);
  }
  getSelectedDrawingItems() {
    if (!this._arrDrawingLayer.length) return;
    const t2 = this._arrDrawingLayer[0].fabricCanvas.getActiveObjects(), e2 = [];
    for (let i2 of t2) e2.push(i2.getDrawingItem());
    return e2;
  }
  setDimensions(t2, e2) {
    this._arrDrawingLayer.length && this._arrDrawingLayer[0]._setDimensions(t2, e2);
  }
  setObjectFit(t2) {
    for (let e2 of this._arrDrawingLayer) e2 && e2._setObjectFit(t2);
  }
  getObjectFit() {
    return this._arrDrawingLayer.length ? this._arrDrawingLayer[0]._getObjectFit() : null;
  }
  setVisible(t2) {
    this._arrDrawingLayer.length && (this._arrDrawingLayer[0].fabricCanvas.wrapperEl.style.display = t2 ? "block" : "none");
  }
  _switchPointerEvent() {
    if (this._arrDrawingLayer.length) for (let t2 of this._arrDrawingLayer) t2.getMode();
  }
};
var O = class {
  constructor(t2) {
    this._controlTarget = null, this._arrUsers = [], this._mapAction_UserArgs = /* @__PURE__ */ new Map(), this._mapProperty_UserValue = /* @__PURE__ */ new Map(), this._mapAction_Callbacks = /* @__PURE__ */ new Map(), this._controlTarget = t2;
  }
  setControlTarget(t2) {
    this._controlTarget = t2;
  }
  getControlTarget() {
    return this._controlTarget;
  }
  register(t2) {
    this._arrUsers.includes(t2) || this._arrUsers.push(t2);
  }
  logout(t2) {
    const e2 = this._arrUsers.indexOf(t2);
    -1 !== e2 && (this.clearUserDisiredAction({ user: t2 }), this.clearUserDisiredValue({ user: t2 }), this._arrUsers.splice(e2, 1));
  }
  getRegisteredUsers() {
    return this._arrUsers;
  }
  ifUserExisted(t2) {
    return this._arrUsers.includes(t2);
  }
  setDisiredValue(t2, e2, i2, r3) {
    if (!this._arrUsers.includes(t2)) throw new Error("Unregistered user.");
    r3 && (this._controlTarget[e2] = i2), this._mapProperty_UserValue.get(e2) ? this._mapProperty_UserValue.get(e2).set(t2, i2) : this._mapProperty_UserValue.set(e2, /* @__PURE__ */ new Map([[t2, i2]]));
  }
  clearUserDisiredValue(t2) {
    if (t2 && (t2.user || t2.property)) {
      if (t2.property && t2.user) {
        const e2 = this._mapProperty_UserValue.get(t2.property);
        if (!e2) return;
        e2.delete(t2.user);
      } else if (t2.property) this._mapProperty_UserValue.delete(t2.property);
      else if (t2.user) for (let e2 of this._mapProperty_UserValue.values()) e2.delete(t2.user);
    } else this._mapProperty_UserValue = /* @__PURE__ */ new Map();
  }
  getValue(t2) {
    if (!this._controlTarget) throw new Error("Control target is not set.");
    return this._controlTarget[t2];
  }
  getPropertyDisiredValue(t2) {
    if (this._mapProperty_UserValue.get(t2)) {
      const e2 = [], i2 = this._mapProperty_UserValue.get(t2);
      for (let t3 of i2.values()) e2.push(t3);
      return e2;
    }
    return null;
  }
  setDisiredAction(t2, e2, i2, r3) {
    if (!this._arrUsers.includes(t2)) throw new Error("Unregistered user.");
    return i2 || (i2 = []), r3 ? this._controlTarget[e2](...i2) : (this._mapAction_UserArgs.get(e2) ? this._mapAction_UserArgs.get(e2).set(t2, i2) : this._mapAction_UserArgs.set(e2, /* @__PURE__ */ new Map([[t2, i2]])), this._render(e2));
  }
  clearUserDisiredAction(t2) {
    if (t2 && (t2.user || t2.actionName)) {
      if (t2.actionName && t2.user) {
        const e2 = this._mapAction_UserArgs.get(t2.actionName);
        if (!e2) return;
        e2.delete(t2.user);
      } else if (t2.actionName) this._mapAction_UserArgs.delete(t2.actionName);
      else if (t2.user) for (let e2 of this._mapAction_UserArgs.values()) e2.delete(t2.user);
      this.render();
    } else this._mapAction_UserArgs = /* @__PURE__ */ new Map();
  }
  addCallback(t2, e2) {
    const i2 = this._mapAction_Callbacks.get(t2);
    i2 ? i2.push(e2) : this._mapAction_Callbacks.set(t2, [e2]);
  }
  removeCallback(t2, e2) {
    const i2 = this._mapAction_Callbacks.get(t2);
    if (!i2) return;
    const r3 = i2.indexOf(e2);
    -1 !== r3 && i2.splice(r3, 1);
  }
  clearCallback(t2) {
    t2 ? this._mapAction_Callbacks.delete(t2) : this._mapAction_Callbacks.clear();
  }
  _fireCallback(t2) {
    const e2 = this._mapAction_Callbacks.get(t2);
    if (e2) for (let t3 of e2) {
      if (!t3) return;
      setTimeout(t3.bind(this._controlTarget), 0);
    }
  }
  _render(t2) {
    const e2 = this._mapAction_UserArgs.get(t2);
    if (!e2) throw new Error("Unrecorded action.");
    if (e2.size === this._arrUsers.length) {
      let i2 = [];
      for (let t3 of e2.values()) t3.length > 0 && (i2 = t3);
      if (this._controlTarget[t2]) {
        const e3 = this._controlTarget[t2](...i2);
        return this._mapAction_UserArgs.delete(t2), this._fireCallback(t2), e3;
      }
    }
  }
  render(t2) {
    if (t2) return this._render(t2);
    for (let t3 of this._mapAction_UserArgs.keys()) this._render(t3);
  }
};
var E = class _E {
  static multiply(t2, e2) {
    const i2 = [];
    for (let r3 = 0; r3 < 3; r3++) {
      const n3 = e2.slice(3 * r3, 3 * r3 + 3);
      for (let e3 = 0; e3 < 3; e3++) {
        const r4 = [t2[e3], t2[e3 + 3], t2[e3 + 6]].reduce((t3, e4, i3) => t3 + e4 * n3[i3], 0);
        i2.push(r4);
      }
    }
    return i2;
  }
  static identity() {
    return [1, 0, 0, 0, 1, 0, 0, 0, 1];
  }
  static translate(t2, e2, i2) {
    return _E.multiply(t2, [1, 0, 0, 0, 1, 0, e2, i2, 1]);
  }
  static rotate(t2, e2) {
    var i2 = Math.cos(e2), r3 = Math.sin(e2);
    return _E.multiply(t2, [i2, -r3, 0, r3, i2, 0, 0, 0, 1]);
  }
  static scale(t2, e2, i2) {
    return _E.multiply(t2, [e2, 0, 0, 0, i2, 0, 0, 0, 1]);
  }
};
var D;
!function(t2) {
  t2.GREY = "grey", t2.GREY32 = "grey32", t2.RGBA = "rgba", t2.RBGA = "rbga", t2.GRBA = "grba", t2.GBRA = "gbra", t2.BRGA = "brga", t2.BGRA = "bgra";
}(D || (D = {}));
var M = (t2, e2, i2, r3) => {
  if (!i2) return t2;
  let n3 = e2 + Math.round((t2 - e2) / i2) * i2;
  return r3 && (n3 = Math.min(n3, r3)), n3;
};
var I = class _I {
  static getVersion() {
    return this._version;
  }
  static async detectEnvironment() {
    return await (async () => ({ wasm: o, worker: a, getUserMedia: h, camera: await l(), browser: s.browser, version: s.version, OS: s.OS }))();
  }
  static set engineResourcePath(e2) {
    if (this._hasEngineResourceLoaded) throw new Error("`engineResourcePath` is not allowed to change after `createInstance` is called.");
    _I._engineResourcePath = ((e3) => {
      if (null == e3 && (e3 = "./"), !t) {
        let t2 = document.createElement("a");
        t2.href = e3, e3 = t2.href;
      }
      return e3.endsWith("/") || (e3 += "/"), e3;
    })(e2);
  }
  static get engineResourcePath() {
    return this._engineResourcePath;
  }
  static isStorageAvailable(t2) {
    let e2;
    try {
      e2 = window[t2];
      const i2 = "__storage_test__";
      return e2.setItem(i2, i2), e2.removeItem(i2), true;
    } catch (t3) {
      return t3 instanceof DOMException && (22 === t3.code || 1014 === t3.code || "QuotaExceededError" === t3.name || "NS_ERROR_DOM_QUOTA_REACHED" === t3.name) && e2 && 0 !== e2.length;
    }
  }
  static isDCEFrame(t2) {
    return !(!t2 || "object" != typeof t2 || Array.isArray(t2)) && ("data" in t2 && ("region" in t2 && ("sx" in t2 && ("sy" in t2 && ("width" in t2 && ("height" in t2 && (("colorMode" in t2 || "pixelFormat" in t2) && ("timeSpent" in t2 && ("timeStamp" in t2 && ("isCropped" in t2 && ("toCanvas" in t2 && ("_sWidth" in t2 && ("_sHeight" in t2 && "_bUseWebGL" in t2)))))))))))));
  }
  static async testCameraAccess() {
    try {
      if (!navigator || !navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) return { ok: false, message: "Insecure context." };
      (await navigator.mediaDevices.getUserMedia({ video: true })).getTracks().forEach((t2) => {
        t2.stop();
      });
    } catch (t2) {
      if ("OverconstrainedError" === t2.name || "NotFoundError" === t2.name) return { ok: false, message: "No camera detected." };
      if ("NotAllowedError" === t2.name) return { ok: false, message: "No permission to access camera." };
      if ("AbortError" === t2.name) return { ok: false, message: "Some problem occurred which prevented the device from being used." };
      if ("NotReadableError" === t2.name) return { ok: false, message: "A hardware error occurred." };
      if ("SecurityError" === t2.name) return { ok: false, message: "User media support is disabled." };
      throw t2;
    }
    return { ok: true, message: "Successfully accessed the camera." };
  }
  set maxCvsSideLength(t2) {
    if (t2 <= 0) throw new Error("Invalid value.");
    this._maxCvsSideLength = t2;
  }
  get maxCvsSideLength() {
    if (void 0 !== this._maxCvsSideLength) return this._maxCvsSideLength;
    if (this._controler) {
      const t2 = this._controler.getPropertyDisiredValue("maxCvsSideLength");
      if (t2 && 1 === t2.length) return t2[0];
    }
    return this._defaultMaxCvsSideLength;
  }
  static set defaultUIElementURL(t2) {
    _I._defaultUIElementURL = t2;
  }
  static get defaultUIElementURL() {
    var t2;
    return null === (t2 = _I._defaultUIElementURL) || void 0 === t2 ? void 0 : t2.replace("@engineResourcePath/", _I.engineResourcePath);
  }
  getUIElement() {
    return this.UIElement;
  }
  async setUIElement(t2) {
    if (this._bOpen) throw new Error("It is not allowed to change the UIElement when the camera is open.");
    if ("string" == typeof t2 || t2 instanceof String) {
      if (!t2.trim().startsWith("<")) {
        let e3 = await fetch(t2);
        if (!e3.ok) throw Error("setUIElement(elementOrUrl): Network Error: " + e3.statusText);
        t2 = await e3.text();
      }
      if (!t2.trim().startsWith("<")) throw Error("setUIElement(elementOrUrl): Can't get valid HTMLElement.");
      let e2 = document.createElement("div");
      e2.innerHTML = t2;
      for (let t3 = 0; t3 < e2.childElementCount; ++t3) {
        let i2 = e2.children[t3];
        i2 instanceof HTMLStyleElement && (this.styleEls.push(i2), document.head.append(i2));
      }
      (t2 = 1 == e2.childElementCount ? e2.children[0] : e2).remove();
    }
    this.UIElement = t2, this._uiOriginalState = { display: t2 && t2.style.display, inDom: document.body.contains(t2) };
  }
  appendAndShowUI() {
    this.UIElement && (this.UIElement.parentNode || (this.UIElement.style.position = "fixed", this.UIElement.style.left = "0", this.UIElement.style.top = "0", document.body.append(this.UIElement)), "none" == this.UIElement.style.display && (this.UIElement.style.display = ""));
  }
  hideUI() {
    this.UIElement && (this.UIElement.style.display = "none");
  }
  get singleFrameMode() {
    return this._singleFrameMode;
  }
  set singleFrameMode(t2) {
    var e2;
    if ("boolean" != typeof t2 && !["image", "camera"].includes(t2)) throw new Error("Invalid value.");
    if (this._bOpen) throw new Error("It is not allowed to change `singleFrameMode` when the camera is open.");
    this._singleFrameMode = t2;
    const i2 = null === (e2 = this._singleFrameInputContainer) || void 0 === e2 ? void 0 : e2.firstElementChild;
    i2 && ("camera" === t2 ? (i2.setAttribute("capture", ""), i2.setAttribute("accept", "image/*")) : 1 != t2 && "image" !== t2 || (i2.removeAttribute("capture"), i2.setAttribute("accept", ".jpg,.jpeg,.icon,.gif,.svg,.webp,.png,.bmp")));
  }
  set frameColorMode(t2) {
    this._framePixelFormat = t2;
  }
  get frameColorMode() {
    if (void 0 !== this._framePixelFormat) return this._framePixelFormat;
    if (this._controler) {
      const t2 = this._controler.getPropertyDisiredValue("framePixelFormat") || this._controler.getPropertyDisiredValue("frameColorMode");
      if (t2 && 1 === t2.length) return t2[0];
    }
    return this._defaultFramePixelFormat;
  }
  set framePixelFormat(t2) {
    this._framePixelFormat = t2;
  }
  get framePixelFormat() {
    if (void 0 !== this._framePixelFormat) return this._framePixelFormat;
    if (this._controler) {
      const t2 = this._controler.getPropertyDisiredValue("framePixelFormat") || this._controler.getPropertyDisiredValue("frameColorMode");
      if (t2 && 1 === t2.length) return t2[0];
    }
    return this._defaultFramePixelFormat;
  }
  set bOpen(t2) {
    if (this._bOpen = t2, t2) {
      this._updateScanRegionCanvas(), this._updateScanAreaDiv(), this._updateViewDecorator();
      for (let t3 of this._arrScanRegionOverlays) t3 && this._updateScanRegionOverlay(t3);
      this._updateDrawingLayersSize(), this.ifShowScanRegionMask ? this.showScanRegionMask() : this.hideScanRegionMask(), this.ifShowScanRegionLaser ? this.showScanRegionLaser() : this.hideScanRegionLaser(), this.showViewDecorator(), this.showScanRegionOverlays(), this._drawingLayerManager.setVisible(true);
    } else this._softwareScale = 1;
  }
  set ifSaveLastUsedCamera(t2) {
    t2 ? _I.isStorageAvailable("localStorage") ? this._ifSaveLastUsedCamera = true : (this._ifSaveLastUsedCamera = false, console.warn("Local storage is unavailable")) : this._ifSaveLastUsedCamera = false;
  }
  get ifSaveLastUsedCamera() {
    return this._ifSaveLastUsedCamera;
  }
  get video() {
    return this._video;
  }
  setVideoFit(t2) {
    if (t2 = t2.toLowerCase(), !["contain", "cover"].includes(t2)) throw new Error(`Unsupported value '${t2}'.`);
    if (this.videoFit = t2, this._video && (this._video.style.objectFit = t2, !this._isSingleFrameModeEnabled())) {
      this._updateScanRegionCanvas(), this._updateScanAreaDiv(), this._updateViewDecorator();
      for (let t3 of this._arrScanRegionOverlays) t3 && this._updateScanRegionOverlay(t3);
      this._updateVideoContainerStyle(), this._drawingLayerManager.setObjectFit(t2);
    }
  }
  getVideoFit() {
    return this.videoFit;
  }
  _showElClassName() {
    this._videoContainer && this._videoContainer.classList.add("div-video-container"), this._cvsScanRegion && this._cvsScanRegion.classList.add("cvs-scan-region-mask"), this._cvsViewDecorator && this._cvsViewDecorator.classList.add("cvs-view-decorator"), this._scanRegionOverlayContainer && this._scanRegionOverlayContainer.classList.add("div-scan-region-overlay-container"), this._layerBaseCvs && this._layerBaseCvs.classList.add("cvs-drawing-layer-base"), this._layerBaseCvs && this._layerBaseCvs.parentElement.classList.add("div-drawing-layer-container"), this._cvsOriginalImage && this._cvsOriginalImage.classList.add("cvs-original-image"), this._cvsSingleFrameMode && this._cvsSingleFrameMode.classList.add("cvs-single-frame"), this._singleFrameInputContainer && this._singleFrameInputContainer.classList.add("div-single-frame-input-container");
  }
  _hideElClassName() {
    this._videoContainer && (this._videoContainer.className = ""), this._cvsScanRegion && (this._cvsScanRegion.className = ""), this._cvsViewDecorator && (this._cvsViewDecorator.className = ""), this._scanRegionOverlayContainer && (this._scanRegionOverlayContainer.className = ""), this._layerBaseCvs && (this._layerBaseCvs.className = ""), this._layerBaseCvs && (this._layerBaseCvs.className = ""), this._cvsOriginalImage && (this._cvsOriginalImage.className = ""), this._cvsSingleFrameMode && (this._cvsSingleFrameMode.className = ""), this._singleFrameInputContainer && (this._singleFrameInputContainer.className = "");
  }
  set ifShowScanRegionMask(t2) {
    this._bShowScanRegionMask = t2, t2 ? this.showScanRegionMask() : this.hideScanRegionMask();
  }
  get ifShowScanRegionMask() {
    return this._bShowScanRegionMask;
  }
  showScanRegionMask() {
    this._cvsScanRegion && ("none" == this._cvsScanRegion.style.display && (this._cvsScanRegion.style.display = ""), this._recordedStates.maskShow = true);
  }
  hideScanRegionMask() {
    this._cvsScanRegion && (this._cvsScanRegion.style.display = "none", this._recordedStates.maskShow = false);
  }
  set ifShowScanRegionLaser(t2) {
    this._bShowScanRegionLaser = t2, t2 ? this.showScanRegionLaser() : this.hideScanRegionLaser();
  }
  get ifShowScanRegionLaser() {
    if (void 0 !== this._bShowScanRegionLaser) return this._bShowScanRegionLaser;
    if (this._controler) {
      const t2 = this._controler.getPropertyDisiredValue("ifShowScanRegionLaser");
      if (t2 && t2.length) {
        let e2 = 0;
        for (let i2 of t2) i2 || e2++;
        return e2 !== this._controler.getRegisteredUsers().length;
      }
    }
    return this._defaultBShowScanRegionLaser;
  }
  showScanRegionLaser() {
    this._divScanLight && ("none" == this._divScanLight.style.display && (this._divScanLight.style.display = "block"), this._recordedStates.laserShow = true);
  }
  hideScanRegionLaser() {
    this._divScanLight && (this._divScanLight.style.display = "none", this._recordedStates.laserShow = false);
  }
  _checkValidRegion(t2) {
    return null === t2 || !!t2 && (!!(t2.hasOwnProperty("regionLeft") && t2.hasOwnProperty("regionTop") && t2.hasOwnProperty("regionRight") && t2.hasOwnProperty("regionBottom") && t2.hasOwnProperty("regionMeasuredByPercentage")) && (!(t2.regionLeft < 0 || t2.regionTop < 0 || t2.regionRight < 0 || t2.regionBottom < 0) && (!t2.regionMeasuredByPercentage || !(t2.regionLeft > 100 || t2.regionTop > 100 || t2.regionRight > 100 || t2.regionBottom > 100))));
  }
  set scanRegion(t2) {
    if (!this._checkValidRegion(t2)) throw new Error("Invalid region.");
    this._scanRegion = JSON.parse(JSON.stringify(t2)), this._updateScanRegionCanvas(), this._updateScanAreaDiv();
    for (let t3 of this._arrScanRegionOverlays) t3 && this._updateScanRegionOverlay(t3);
  }
  setScanRegion(t2) {
    this.scanRegion = t2;
  }
  getScanRegion() {
    return JSON.parse(JSON.stringify(this._scanRegion));
  }
  _calculateCvsSize() {
    var t2, e2;
    let i2, r3, n3;
    if (this._isSingleFrameModeEnabled() ? (i2 = this._imgWidth, r3 = this._imgHeight, n3 = "contain") : (i2 = null === (t2 = this._video) || void 0 === t2 ? void 0 : t2.videoWidth, r3 = null === (e2 = this._video) || void 0 === e2 ? void 0 : e2.videoHeight, n3 = this.getVideoFit()), !i2 || !r3) throw new Error("Invalid content dimensions.");
    return { width: i2, height: r3, objectFit: n3 };
  }
  addScanRegionOverlayCanvas() {
    this._assertOpen();
    const t2 = document.createElement("canvas");
    if (this._updateScanRegionOverlay(t2), !this._scanRegionOverlayContainer) {
      const t3 = document.createElement("div");
      if (this._scanRegionOverlayContainer = t3, t3.style.position = "absolute", t3.style.left = "0", t3.style.top = "0", t3.style.width = "100%", t3.style.height = "100%", t3.style.overflow = "hidden", t3.style.pointerEvents = "none", this._layerBaseCvs) this._layerBaseCvs.parentElement.after(t3);
      else if (this._cvsScanRegion) this._cvsScanRegion.after(t3);
      else if (this._cvsOriginalImage) this._cvsOriginalImage.after(t3);
      else if (this._cvsSingleFrameMode) this._cvsSingleFrameMode.after(t3);
      else {
        if (!this._videoContainer) throw new Error("Unable to find video element");
        this._videoContainer.after(t3);
      }
      this._recordedStates.overlayShow = true;
    }
    return this._scanRegionOverlayContainer.append(t2), this._arrScanRegionOverlays.push(t2), t2;
  }
  removeScanRegionOverlayCanvas(t2) {
    const e2 = this._arrScanRegionOverlays.indexOf(t2);
    -1 !== e2 && (t2.remove(), this._arrScanRegionOverlays.splice(e2, 1));
  }
  _updateScanRegionOverlay(t2) {
    if (!t2) return;
    let e2;
    try {
      e2 = this._calculateCvsSize();
    } catch (t3) {
      if ("Invalid content dimensions." === (t3.message || t3)) return;
      throw t3;
    }
    const { width: i2, height: r3, objectFit: n3 } = e2;
    if (i2 <= 0 || r3 <= 0) return t2.width = 0, void (t2.height = 0);
    const s3 = this._getRegionInPixels(i2, r3, this._scanRegion), o3 = this.getFrameSize(i2, r3, this._scanRegion, this.maxCvsSideLength), a3 = o3.dWidth, h3 = o3.dHeight;
    t2.width == a3 && t2.height == h3 || (t2.width = a3, t2.height = h3);
    const l3 = window.getComputedStyle(this._elContainer), c3 = parseFloat(l3.width), u3 = parseFloat(l3.height), d3 = c3 / u3, f3 = i2 / r3;
    let g3, p3, m3, v3, _3 = 1;
    "contain" === n3 ? (f3 > d3 ? (_3 = c3 / i2, g3 = 0, p3 = (u3 - r3 * _3) / 2) : (_3 = u3 / r3, g3 = (c3 - i2 * _3) / 2, p3 = 0), g3 += s3.regionLeft * _3, p3 += s3.regionTop * _3, m3 = (s3.regionRight - s3.regionLeft) * _3, v3 = (s3.regionBottom - s3.regionTop) * _3) : "cover" === n3 ? (f3 > d3 ? (_3 = u3 / r3, g3 = s3.regionLeft * _3 - (i2 * _3 - c3) / 2, p3 = s3.regionTop * _3) : (_3 = c3 / i2, g3 = s3.regionLeft * _3, p3 = s3.regionTop * _3 - (r3 * _3 - u3) / 2), m3 = (s3.regionRight - s3.regionLeft) * _3, v3 = (s3.regionBottom - s3.regionTop) * _3) : (g3 = 0, p3 = 0, m3 = 0, v3 = 0), t2.style.position = "absolute", t2.style.left = g3 + "px", t2.style.top = p3 + "px", t2.style.width = m3 + "px", t2.style.height = v3 + "px";
  }
  showScanRegionOverlays() {
    this._scanRegionOverlayContainer && ("none" == this._scanRegionOverlayContainer.style.display && (this._scanRegionOverlayContainer.style.display = ""), this._recordedStates.overlayShow = true);
  }
  hideScanRegionOverlays() {
    this._scanRegionOverlayContainer && (this._scanRegionOverlayContainer.style.display = "none", this._recordedStates.overlayShow = false);
  }
  setViewDecorator(t2, e2) {
    if (!t2) return void (this._cvsViewDecorator && (this._cvsViewDecorator.remove(), this._cvsViewDecorator = null));
    if (!e2) throw new Error("Invalid area.");
    this._assertOpen();
    let i2 = [];
    if ("string" == typeof t2 ? i2.push(t2) : Array.isArray(t2) && (i2 = JSON.parse(JSON.stringify(t2))), !this._cvsViewDecorator) {
      if (this._cvsViewDecorator = document.createElement("canvas"), this._scanRegionOverlayContainer) this._scanRegionOverlayContainer.after(this._cvsViewDecorator);
      else if (this._layerBaseCvs) this._layerBaseCvs.parentElement.after(this._cvsViewDecorator);
      else if (this._cvsScanRegion) this._cvsScanRegion.after(this._cvsViewDecorator);
      else if (this._cvsOriginalImage) this._cvsOriginalImage.after(this._cvsViewDecorator);
      else if (this._cvsSingleFrameMode) this._cvsSingleFrameMode.after(this._cvsViewDecorator);
      else {
        if (!this._videoContainer) throw new Error("Unable to find video element");
        this._videoContainer.after(this._cvsViewDecorator);
      }
      this._recordedStates.decoratorShow = true;
    }
    this._decoratorArea = JSON.parse(JSON.stringify(e2)), this._decoratorType.length = 0;
    const r3 = ["rectangle", "focus"], n3 = ["crossline", "crosshair"];
    let s3 = false, o3 = false;
    for (let t3 of i2) t3 = t3.toLowerCase(), r3.includes(t3) && !s3 && (s3 = true, this._decoratorType.push(t3)), n3.includes(t3) && !o3 && (o3 = true, !this._decoratorType.includes(t3) && this._decoratorType.push(t3));
    this._updateViewDecorator();
  }
  getViewDecorator() {
    return { type: JSON.parse(JSON.stringify(this._decoratorType)), area: JSON.parse(JSON.stringify(this._decoratorArea)), canvas: this._cvsViewDecorator };
  }
  showViewDecorator() {
    this._cvsViewDecorator && ("none" == this._cvsViewDecorator.style.display && (this._cvsViewDecorator.style.display = ""), this._recordedStates.decoratorShow = true);
  }
  hideViewDecorator() {
    this._cvsViewDecorator && (this._cvsViewDecorator.style.display = "none", this._recordedStates.decoratorShow = false);
  }
  setViewDecoratorLineWidth(t2, e2) {
    if ("string" != typeof t2) throw new Error("The 'type' should be a string.");
    if (t2 = t2.toLowerCase(), !this._viewDecoratorInfo.hasOwnProperty(t2)) throw new Error(`The type of '${t2}' doesn't exist.`);
    if (!this._viewDecoratorInfo[t2].hasOwnProperty("lineWidth")) throw new Error(`It is not allowed to change the property 'lineWidth' when the decorator type is '${t2}'.`);
    this._viewDecoratorInfo[t2].lineWidth = e2, this._updateViewDecorator();
  }
  setViewDecoratorStrokeStyle(t2, e2) {
    if ("string" != typeof t2) throw new Error("The 'type' should be a string.");
    if (t2 = t2.toLowerCase(), !this._viewDecoratorInfo.hasOwnProperty(t2)) throw new Error(`The type of '${t2}' doesn't exist.`);
    if (!this._viewDecoratorInfo[t2].hasOwnProperty("strokeStyle")) throw new Error(`It is not allowed to change the property 'strokeStyle' when the decorator type is '${t2}'.`);
    this._viewDecoratorInfo[t2].strokeStyle = e2, this._updateViewDecorator();
  }
  setViewDecoratorFillStyle(t2, e2) {
    if ("string" != typeof t2) throw new Error("The 'type' should be a string.");
    if (t2 = t2.toLowerCase(), !this._viewDecoratorInfo.hasOwnProperty(t2)) throw new Error(`The type of '${t2}' doesn't exist.`);
    if (!this._viewDecoratorInfo[t2].hasOwnProperty("fillStyle")) throw new Error(`It is not allowed to change the property 'fillStyle' when the decorator type is '${t2}'.`);
    this._viewDecoratorInfo[t2].fillStyle = e2, this._updateViewDecorator();
  }
  setViewDecoratorMaskFillStyle(t2, e2) {
    if ("string" != typeof t2) throw new Error("The 'type' should be a string.");
    if (t2 = t2.toLowerCase(), !this._viewDecoratorInfo.hasOwnProperty(t2)) throw new Error(`The type of '${t2}' doesn't exist.`);
    if (!this._viewDecoratorInfo[t2].hasOwnProperty("maskFillStyle")) throw new Error(`It is not allowed to change the property 'maskFillStyle' when the decorator type is '${t2}'.`);
    this._viewDecoratorInfo[t2].maskFillStyle = e2, this._updateViewDecorator();
  }
  _updateViewDecorator() {
    if (!this._bOpen) return;
    if (!this._cvsViewDecorator || !this._decoratorArea) return;
    let t2;
    if (this._isSingleFrameModeEnabled()) t2 = "contain";
    else {
      if (!this._video) return;
      t2 = this.getVideoFit();
    }
    const e2 = this._cvsViewDecorator;
    e2.style.position = "absolute", e2.style.width = "100%", e2.style.height = "100%", e2.style.left = "0", e2.style.top = "0", e2.style.objectFit = t2, e2.style.pointerEvents = "none";
    const i2 = this.getVisibleRegion(true);
    if (!i2) return;
    const r3 = i2.regionRight - i2.regionLeft, n3 = i2.regionBottom - i2.regionTop;
    if (e2.width == r3 && e2.height == n3 || (e2.width = r3, e2.height = n3), r3 <= 0 || n3 <= 0) return;
    const s3 = e2.getContext("2d");
    s3.clearRect(0, 0, e2.width, e2.height);
    const o3 = this._decoratorArea.x / 100 * r3, a3 = this._decoratorArea.y / 100 * n3, h3 = this._decoratorArea.width / 100 * r3, l3 = this._decoratorArea.height / 100 * n3;
    for (let t3 of this._decoratorType) {
      if ("rectangle" === t3) {
        s3.fillStyle = this._viewDecoratorInfo.rectangle.maskFillStyle, s3.fillRect(0, 0, e2.width, e2.height), s3.clearRect(Math.round(o3), Math.round(a3), Math.round(h3), Math.round(l3)), s3.fillStyle = this._viewDecoratorInfo.rectangle.fillStyle, s3.fillRect(Math.round(o3), Math.round(a3), Math.round(h3), Math.round(l3)), s3.lineWidth = this._viewDecoratorInfo.rectangle.lineWidth, s3.strokeStyle = this._viewDecoratorInfo.rectangle.strokeStyle;
        const t4 = s3.lineWidth / 2;
        s3.strokeRect(Math.round(o3 - t4), Math.round(a3 - t4), Math.round(h3 + s3.lineWidth), Math.round(l3 + s3.lineWidth));
      }
      if ("focus" === t3) {
        s3.fillStyle = this._viewDecoratorInfo.focus.maskFillStyle, s3.fillRect(0, 0, e2.width, e2.height), s3.clearRect(Math.round(o3), Math.round(a3), Math.round(h3), Math.round(l3)), s3.fillStyle = this._viewDecoratorInfo.focus.fillStyle, s3.fillRect(Math.round(o3), Math.round(a3), Math.round(h3), Math.round(l3)), s3.lineWidth = this._viewDecoratorInfo.focus.lineWidth, s3.strokeStyle = this._viewDecoratorInfo.focus.strokeStyle;
        const t4 = s3.lineWidth / 2, i3 = [0, 0.25, 0.75, 1], r4 = [0, 0.25, 0.75, 1];
        s3.beginPath();
        for (let t5 = 0; t5 < i3.length; t5++) if (0 == t5 || 3 == t5) for (let e3 = 0; e3 < r4.length; e3 += 2) s3.moveTo(Math.round(o3 + i3[t5] * h3), Math.round(a3 + r4[e3] * l3)), s3.lineTo(Math.round(o3 + i3[t5] * h3), Math.round(a3 + r4[e3 + 1] * l3));
        for (let e3 = 0; e3 < r4.length; e3++) if (0 == e3 || 3 == e3) for (let n4 = 0; n4 < i3.length; n4 += 2) s3.moveTo(Math.round(o3 + i3[n4] * h3 - t4), Math.round(a3 + r4[e3] * l3)), s3.lineTo(Math.round(o3 + i3[n4 + 1] * h3 + t4), Math.round(a3 + r4[e3] * l3));
        s3.stroke();
      }
      if ("crossline" === t3 && (s3.beginPath(), s3.lineWidth = this._viewDecoratorInfo.crossline.lineWidth, s3.strokeStyle = this._viewDecoratorInfo.crossline.strokeStyle, s3.moveTo(Math.round(o3), Math.round(a3 + l3 / 2)), s3.lineTo(Math.round(o3 + h3), Math.round(a3 + l3 / 2)), s3.moveTo(Math.round(o3 + h3 / 2), Math.round(a3)), s3.lineTo(Math.round(o3 + h3 / 2), Math.round(a3 + l3)), s3.stroke()), "crosshair" === t3) {
        s3.beginPath();
        const t4 = 0.05 * Math.min(h3, l3);
        s3.lineWidth = this._viewDecoratorInfo.crosshair.lineWidth, s3.strokeStyle = this._viewDecoratorInfo.crosshair.strokeStyle, s3.moveTo(Math.round(o3 + (h3 - t4) / 2), Math.round(a3 + l3 / 2)), s3.lineTo(Math.round(o3 + (h3 + t4) / 2), Math.round(a3 + l3 / 2)), s3.moveTo(Math.round(o3 + h3 / 2), Math.round(a3 + (l3 - t4) / 2)), s3.lineTo(Math.round(o3 + h3 / 2), Math.round(a3 + (l3 + t4) / 2)), s3.stroke();
      }
    }
  }
  getVisibleRegion(t2) {
    let e2;
    this._assertOpen();
    try {
      e2 = this._calculateCvsSize();
    } catch (t3) {
      if ("Invalid content dimensions." === (t3.message || t3)) return null;
      throw t3;
    }
    const { width: i2, height: r3, objectFit: n3 } = e2;
    let s3 = (() => {
      const t3 = parseFloat(window.getComputedStyle(this._elContainer).width), e3 = parseFloat(window.getComputedStyle(this._elContainer).height);
      let s4, o3 = { regionBottom: r3, regionRight: i2, regionLeft: 0, regionTop: 0, regionMeasuredByPercentage: false };
      return "cover" === n3 ? t3 / e3 < i2 / r3 ? (s4 = e3 / r3, o3.regionLeft = Math.floor((i2 - t3 / s4) / 2), o3.regionRight = Math.ceil(i2 - o3.regionLeft), o3.regionTop = 0, o3.regionBottom = r3) : (s4 = t3 / i2, o3.regionTop = Math.floor((r3 - e3 / s4) / 2), o3.regionBottom = Math.ceil(r3 - o3.regionTop), o3.regionLeft = 0, o3.regionRight = i2) : "none" === n3 && (t3 < i2 && e3 < r3 ? (o3.regionLeft = Math.floor((i2 - t3) / 2), o3.regionRight = Math.ceil(i2 - o3.regionLeft), o3.regionTop = Math.floor((r3 - e3) / 2), o3.regionBottom = Math.ceil(r3 - o3.regionTop)) : t3 < i2 ? (o3.regionLeft = Math.floor((i2 - t3) / 2), o3.regionRight = Math.ceil(i2 - o3.regionLeft), o3.regionTop = 0, o3.regionBottom = r3) : e3 < r3 && (o3.regionTop = Math.floor((r3 - e3) / 2), o3.regionBottom = Math.ceil(r3 - o3.regionTop), o3.regionLeft = 0, o3.regionRight = i2)), o3;
    })();
    return t2 ? s3.regionMeasuredByPercentage = false : (s3.regionBottom = Math.ceil(s3.regionBottom / r3 * 100), s3.regionRight = Math.ceil(s3.regionRight / i2 * 100), s3.regionLeft = Math.floor(s3.regionLeft / i2 * 100), s3.regionTop = Math.floor(s3.regionTop / r3 * 100), s3.regionMeasuredByPercentage = true), s3;
  }
  setScanRegionMaskStyle(t2) {
    t2 && (t2.fillStyle && (this.regionMaskFillStyle = t2.fillStyle), t2.strokeStyle && (this.regionMaskStrokeStyle = t2.strokeStyle), t2.lineWidth && (this.regionMaskLineWidth = t2.lineWidth), this._updateScanRegionCanvas());
  }
  _getRegionInPixels(t2, e2, i2) {
    if (!(t2 <= 0 || e2 <= 0)) {
      if (!i2) return { regionLeft: 0, regionTop: 0, regionRight: t2, regionBottom: e2, regionMeasuredByPercentage: false };
      if (i2.regionMeasuredByPercentage) return { regionLeft: Math.round(i2.regionLeft / 100 * t2), regionTop: Math.round(i2.regionTop / 100 * e2), regionRight: Math.round(i2.regionRight / 100 * t2), regionBottom: Math.round(i2.regionBottom / 100 * e2), regionMeasuredByPercentage: false };
      return JSON.parse(JSON.stringify(i2));
    }
  }
  _updateScanRegionCanvas() {
    if (!this._bOpen) return;
    let t2;
    try {
      t2 = this._calculateCvsSize();
    } catch (t3) {
      if ("Invalid content dimensions." === (t3.message || t3)) return;
      throw t3;
    }
    const { width: e2, height: i2, objectFit: r3 } = t2;
    if (e2 <= 0 || i2 <= 0) return void (this._cvsScanRegion && (this._cvsScanRegion.width = 0, this._cvsScanRegion.height = 0));
    const n3 = this._getRegionInPixels(e2, i2, this._scanRegion);
    if (!this._cvsScanRegion) {
      if (this._cvsScanRegion = document.createElement("canvas"), this._cvsOriginalImage) this._cvsOriginalImage.after(this._cvsScanRegion);
      else if (this._cvsSingleFrameMode) this._cvsSingleFrameMode.after(this._cvsScanRegion);
      else {
        if (!this._videoContainer) throw new Error("Unable to find video element");
        this._videoContainer.after(this._cvsScanRegion);
      }
      this._recordedStates.maskShow = true;
    }
    const s3 = this._cvsScanRegion;
    s3.style.position = "absolute", s3.style.width = "100%", s3.style.height = "100%", s3.style.left = "0", s3.style.top = "0", s3.style.objectFit = r3, s3.style.pointerEvents = "none", s3.width == e2 && s3.height == i2 || (s3.width = e2, s3.height = i2);
    const o3 = s3.getContext("2d");
    if (o3.clearRect(0, 0, s3.width, s3.height), 0 != n3.regionLeft || n3.regionRight != e2 || 0 != n3.regionTop || n3.regionBottom != i2) {
      const t3 = n3.regionLeft, e3 = n3.regionTop, i3 = n3.regionRight - n3.regionLeft, r4 = n3.regionBottom - n3.regionTop;
      o3.fillStyle = this.regionMaskFillStyle, o3.fillRect(0, 0, s3.width, s3.height), o3.clearRect(Math.round(t3), Math.round(e3), Math.round(i3), Math.round(r4)), o3.strokeStyle = this.regionMaskStrokeStyle, o3.lineWidth = this.regionMaskLineWidth;
      const a3 = o3.lineWidth / 2;
      o3.strokeRect(Math.round(t3 - a3), Math.round(e3 - a3), Math.round(i3 + o3.lineWidth), Math.round(r4 + o3.lineWidth));
    }
  }
  _updateScanAreaDiv() {
    if (!this._bOpen) return;
    let t2;
    try {
      t2 = this._calculateCvsSize();
    } catch (t3) {
      if ("Invalid content dimensions." === (t3.message || t3)) return;
      throw t3;
    }
    const { width: e2, height: i2, objectFit: r3 } = t2;
    if (!this._divScanArea) return;
    if (e2 <= 0 || i2 <= 0) return this._divScanArea.style.width = "0", void (this._divScanArea.style.height = "0");
    const n3 = this._getRegionInPixels(e2, i2, this._scanRegion), s3 = window.getComputedStyle(this._elContainer), o3 = parseFloat(s3.width), a3 = parseFloat(s3.height), h3 = o3 / a3, l3 = e2 / i2;
    let c3, u3, d3, f3, g3 = 1;
    if ("contain" === r3) h3 < l3 ? (g3 = o3 / e2, c3 = 0, u3 = (a3 - i2 * g3) / 2) : (g3 = a3 / i2, c3 = (o3 - e2 * g3) / 2, u3 = 0), c3 += n3.regionLeft * g3, u3 += n3.regionTop * g3, d3 = (n3.regionRight - n3.regionLeft) * g3, f3 = (n3.regionBottom - n3.regionTop) * g3;
    else if ("cover" === r3) if (h3 < l3) {
      g3 = a3 / i2, c3 = n3.regionLeft * g3 - (e2 * g3 - o3) / 2, c3 = Math.max(c3, 0), c3 = Math.min(c3, parseFloat(s3.width)), u3 = n3.regionTop * g3;
      let t3 = n3.regionRight * g3 - (e2 * g3 - o3) / 2;
      t3 = Math.max(t3, 0), t3 = Math.min(t3, parseFloat(s3.width)), d3 = t3 - c3, f3 = (n3.regionBottom - n3.regionTop) * g3;
    } else {
      g3 = o3 / e2, c3 = n3.regionLeft * g3, u3 = n3.regionTop * g3 - (i2 * g3 - a3) / 2, u3 = Math.max(u3, 0), u3 = Math.min(u3, parseFloat(s3.height));
      let t3 = n3.regionBottom * g3 - (i2 * g3 - a3) / 2;
      t3 = Math.max(t3, 0), t3 = Math.min(t3, parseFloat(s3.height)), d3 = (n3.regionRight - n3.regionLeft) * g3, f3 = t3 - u3;
    }
    else c3 = 0, u3 = 0, d3 = 0, f3 = 0;
    this._divScanArea.style.left = c3 + "px", this._divScanArea.style.top = u3 + "px", this._divScanArea.style.width = d3 + "px", this._divScanArea.style.height = f3 + "px";
  }
  set croppingRegions(t2) {
    this._croppingRegions = t2, this._bFetchingLoopStarted && (this.bIncreaseRegionIndexAuto && (this._croppingRegionIndex = 0), this._fetchingLoop(false));
  }
  get croppingRegions() {
    if (void 0 !== this._croppingRegions) return this._croppingRegions;
    if (this._controler) {
      const t2 = this._controler.getPropertyDisiredValue("croppingRegions");
      if (t2 && 1 === t2.length) return t2[0];
    }
    return this._defaultCroppingRegions;
  }
  set croppingRegionIndex(t2) {
    t2 < 0 ? (this.bIncreaseRegionIndexAuto = true, this._croppingRegionIndex = 0) : (this.bIncreaseRegionIndexAuto = false, this._croppingRegionIndex = t2);
  }
  get croppingRegionIndex() {
    return this._croppingRegionIndex;
  }
  set loopInterval(t2) {
    if (t2 < 0) throw new Error("'Invalid value.");
    this._loopInterval = t2, this._bFetchingLoopStarted && this._fetchingLoop(false);
  }
  get loopInterval() {
    if (void 0 !== this._loopInterval) return this._loopInterval;
    if (this._controler) {
      const t2 = this._controler.getPropertyDisiredValue("loopInterval");
      if (t2 && 1 === t2.length) return t2[0];
    }
    return this._defaultLoopInterval;
  }
  set maxNumberOfFramesInBuffer(t2) {
    if (t2 <= 0) throw new Error("Invalid value.");
    for (this._maxNumberOfFramesInBuffer = t2; this._frameQueue && this._frameQueue.length > this.maxNumberOfFramesInBuffer; ) this._frameQueue.shift();
  }
  get maxNumberOfFramesInBuffer() {
    if (void 0 !== this._maxNumberOfFramesInBuffer) return this._maxNumberOfFramesInBuffer;
    if (this._controler) {
      const t2 = this._controler.getPropertyDisiredValue("maxNumberOfFramesInBuffer");
      if (t2 && 1 === t2.length) return t2[0];
    }
    return this._defaultMaxNumberOfFramesInBuffer;
  }
  get numberOfFramesInBuffer() {
    return this._frameQueue.length;
  }
  set refreshInterval(t2) {
    this._refreshInterval = t2;
  }
  get refreshInterval() {
    if (void 0 !== this._refreshInterval) return this._refreshInterval;
    if (this._controler) {
      const t2 = this._controler.getPropertyDisiredValue("refreshInterval");
      if (t2 && 1 === t2.length) return t2[0];
    }
    return this._defaultRefreshInterval;
  }
  static async createInstance(t2) {
    let e2 = new _I();
    ("string" == typeof t2 || t2 instanceof String) && (t2 = JSON.parse(t2));
    for (let i2 in t2) e2[i2] = t2[i2];
    return this._hasEngineResourceLoaded = true, _I.onWarning && (location && "file:" === location.protocol ? setTimeout(() => {
      _I.onWarning && _I.onWarning({ id: 1, message: "The page is opened over file:// and Dynamsoft Camera Enhancer may not work properly. Please open the page via https://." });
    }, 0) : false !== window.isSecureContext && navigator && navigator.mediaDevices && navigator.mediaDevices.getUserMedia || setTimeout(() => {
      _I.onWarning && _I.onWarning({ id: 2, message: "Dynamsoft Camera Enhancer may not work properly in a non-secure context. Please open the page via https://." });
    }, 0)), e2._drawingLayerManager = new T(), e2;
  }
  static async playVideo(t2, e2, i2) {
    if (!t2) throw new Error("Invalid 'videoEl'.");
    if (!e2) throw new Error("Invalid 'source'.");
    return new Promise(async (r3, n3) => {
      let s3;
      const o3 = () => {
        t2.removeEventListener("loadstart", c3), t2.removeEventListener("abort", u3), t2.removeEventListener("play", d3), t2.removeEventListener("error", f3), t2.removeEventListener("loadedmetadata", m3);
      };
      let a3 = false;
      const h3 = () => {
        a3 = true, s3 && clearTimeout(s3), o3(), r3(t2);
      }, l3 = (t3) => {
        s3 && clearTimeout(s3), o3(), n3(t3);
      }, c3 = () => {
        t2.addEventListener("abort", u3, { once: true });
      }, u3 = () => {
        const t3 = new Error("Video playing was interrupted.");
        t3.name = "AbortError", l3(t3);
      }, d3 = () => {
        h3();
      }, f3 = () => {
        l3(new Error(`Video error ${t2.error.code}: ${t2.error.message}.`));
      };
      let g3;
      const p3 = new Promise((t3) => {
        g3 = t3;
      }), m3 = () => {
        g3();
      };
      if (t2.addEventListener("loadstart", c3, { once: true }), t2.addEventListener("play", d3, { once: true }), t2.addEventListener("error", f3, { once: true }), t2.addEventListener("loadedmetadata", m3, { once: true }), "string" == typeof e2 || e2 instanceof String ? t2.src = e2 : t2.srcObject = e2, t2.autoplay && await new Promise((t3) => {
        setTimeout(t3, 1e3);
      }), !a3) {
        i2 && (s3 = setTimeout(() => {
          o3(), n3(new Error("Failed to play video. Timeout."));
        }, i2));
        try {
          t2.src && await t2.load(), await t2.play(), h3();
        } catch (t3) {
          console.warn("1st play error: " + ((null == t3 ? void 0 : t3.message) || t3));
        }
        if (!a3) {
          await p3;
          try {
            await t2.play(), h3();
          } catch (t3) {
            console.warn("2rd play error: " + ((null == t3 ? void 0 : t3.message) || t3)), l3(t3);
          }
        }
      }
    });
  }
  static findBestRearCameraInIOS(t2) {
    if (!t2 || !t2.length) return null;
    const e2 = ["", "", "", "", "", "", "", "", "", "", "", "", "zadn", "zadn", "tylny", "trasera", "traseira", "taka", "stranja", "spate", "sau", "rck", "posteriore", "posterior", "hts", "belakang", "baksidan", "bakre", "bak", "bagside", "back", "a", "arrire", "arka", "achterzijde"], i2 = ["", "", "", "", "", "", "", "", "", "", "", "", "", "l", "trjobiektywowy", "trostruka", "trojn", "trojit", "trippelt", "trippel", "tripl", "triple", "tripla", "tiga", "kolmois", "ba camera"], r3 = [" ", "", "", "", "", " ", " ", " ", "  ", " ", " ", " ", " ", "ift geni", "laajakulmainen kaksois", "kp rng mt sau", "ketts, szles ltszg", "grande angular dupla", "ganda", "dwuobiektywowy", "dwikamera", "dvostruka iroka", "duln irokohl", "dulna irokouhl", "dupla grande-angular", "dubl", "dubbel vidvinkel", "dual-weitwinkel", "dual wide", "dual con gran angular", "dual", "double", "doppia con grandangolo", "doble", "dobbelt vidvinkelkamera"], n3 = t2.filter((t3) => {
      const i3 = t3.label.toLowerCase();
      return e2.some((t4) => i3.includes(t4));
    });
    if (!n3.length) return null;
    const s3 = n3.find((t3) => {
      const e3 = t3.label.toLowerCase();
      return i2.some((t4) => e3.includes(t4));
    });
    if (s3) return s3.deviceId;
    const o3 = n3.find((t3) => {
      const e3 = t3.label.toLowerCase();
      return r3.some((t4) => e3.includes(t4));
    });
    return o3 ? o3.deviceId : n3[0].deviceId;
  }
  static findBestRearCamera(t2) {
    if (!t2 || !t2.length) return null;
    if (["iPhone", "iPad", "Mac"].includes(s.OS)) return _I.findBestRearCameraInIOS(t2);
    const e2 = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "zadn", "zadn", "tylny", "trs", "trasera", "traseira", "taka", "stranja", "spate", "sau", "rck", "rear", "posteriore", "posterior", "hts", "darrere", "belakang", "baksidan", "bakre", "bak", "bagside", "back", "a", "arrire", "arka", "achterzijde"];
    for (let i2 of t2) {
      const t3 = i2.label.toLowerCase();
      if (t3 && e2.some((e3) => t3.includes(e3)) && /\b0(\b)?/.test(t3)) return i2.deviceId;
    }
    return ["Android", "HarmonyOS"].includes(s.OS) ? t2[t2.length - 1].deviceId : null;
  }
  constructor() {
    this._maxCvsSideLength = void 0, this._defaultMaxCvsSideLength = null, this._predefinedResolutions = [{ width: 160, height: 120 }, { width: 320, height: 240 }, { width: 480, height: 360 }, { width: 640, height: 480 }, { width: 800, height: 600 }, { width: 960, height: 720 }, { width: 1280, height: 720 }, { width: 1920, height: 1080 }, { width: 2560, height: 1440 }, { width: 3840, height: 2160 }], this._mapCameraResolutions = /* @__PURE__ */ new Map(), this._bWebGLSupported = true, this.extraBindings = [], this._cvsSingleFrameMode = null, this._cvsOriginalImage = null, this._imgWidth = 0, this._imgHeight = 0, this._singleFrameInputContainer = null, this._clickIptSingleFrameMode = () => {
      if (!this._isSingleFrameModeEnabled()) return;
      if (this.getDrawingLayers().some((t3) => "editor" == t3.getMode())) return;
      let t2;
      if (this._singleFrameInputContainer) t2 = this._singleFrameInputContainer.firstElementChild;
      else {
        t2 = document.createElement("input"), t2.setAttribute("type", "file"), "camera" === this.singleFrameMode ? (t2.setAttribute("capture", ""), t2.setAttribute("accept", "image/*")) : 1 != this.singleFrameMode && "image" !== this.singleFrameMode || (t2.removeAttribute("capture"), t2.setAttribute("accept", ".jpg,.jpeg,.icon,.gif,.svg,.webp,.png,.bmp")), t2.addEventListener("change", async () => {
          const e3 = t2.files[0];
          t2.value = "";
          const i2 = await (async (t3) => {
            let e4 = null, i3 = null;
            if ("undefined" != typeof createImageBitmap) try {
              if (e4 = await createImageBitmap(t3), e4) return e4;
            } catch (t4) {
            }
            var r4;
            return e4 || (i3 = await (r4 = t3, new Promise((t4, e5) => {
              let i4 = URL.createObjectURL(r4), n4 = new Image();
              n4.src = i4, n4.onload = () => {
                URL.revokeObjectURL(n4.src), t4(n4);
              }, n4.onerror = (t5) => {
                e5(new Error("Can't convert blob to image : " + (t5 instanceof Event ? t5.type : t5)));
              };
            }))), i3;
          })(e3), r3 = i2 instanceof HTMLImageElement ? i2.naturalWidth : i2.width, n3 = i2 instanceof HTMLImageElement ? i2.naturalHeight : i2.height;
          this._imgWidth = r3, this._imgHeight = n3;
          const s3 = (t3) => {
            const e4 = Date.now();
            if (0 === r3 || 0 === n3) return null;
            if (t3 instanceof HTMLImageElement && !t3.complete) throw new Error("The source is not loaded.");
            const i3 = this._scanRegion, s4 = this.getFrameSize(r3, n3, i3, this.maxCvsSideLength);
            if (!s4) return null;
            let o4 = true;
            r3 === s4.sWidth && n3 === s4.sHeight && (o4 = false);
            const a4 = this.mapPixelFormatString_Enum.get(this.framePixelFormat.toLowerCase()), h3 = { data: null, region: i3 ? JSON.parse(JSON.stringify(i3)) : null, sx: s4.sx, sy: s4.sy, width: s4.dWidth, height: s4.dHeight, colorMode: null, pixelFormat: null, timeSpent: null, timeStamp: null, isCropped: o4, toCanvas: this._toCanvas, _sWidth: s4.sWidth, _sHeight: s4.sHeight, _bUseWebGL: null }, l3 = this._getImageData(t3, r3, n3, s4, null, { pixelFormat: a4 });
            if (!l3) return null;
            const c3 = Date.now();
            if (_I._onLog && _I._onLog("DCE: _getVideoData(region?) END: " + c3), h3.data = l3.data, h3.pixelFormat = h3.colorMode = l3.pixelFormat, h3._bUseWebGL = l3._bUseWebGL, h3.timeSpent = c3 - e4, h3.timeStamp = c3, l3.pixelFormat === D.GREY) h3.stride = h3.width;
            else h3.stride = 4 * h3.width;
            return h3;
          };
          ((t3) => {
            let e4 = this._cvsSingleFrameMode;
            if (!e4) {
              if (e4 = document.createElement("canvas"), !this._videoContainer) throw new Error("Unable to find video element");
              this._videoContainer.after(e4), e4.style.position = "absolute", e4.style.width = "100%", e4.style.height = "100%", e4.style.left = "0", e4.style.top = "0", e4.style.objectFit = "contain", e4.style.pointerEvents = "none", this._cvsSingleFrameMode = e4;
            }
            e4.width == r3 && e4.height == n3 || (e4.width = r3, e4.height = n3);
            const i3 = e4.getContext("2d");
            i3.clearRect(0, 0, e4.width, e4.height), i3.drawImage(t3, 0, 0);
          })(i2), this._updateScanRegionCanvas(), this._updateScanAreaDiv(), this._updateViewDecorator();
          for (let t3 of this._arrScanRegionOverlays) t3 && this._updateScanRegionOverlay(t3);
          let o3;
          this._updateDrawingLayersSize();
          try {
            o3 = s3(i2);
          } catch (t3) {
            throw t3;
          }
          const a3 = this.mapCameraEvents.get("singleframeacquired");
          for (let t3 of a3) if (t3) try {
            const e4 = { data: new Uint8Array(o3.data), region: JSON.parse(JSON.stringify(o3.region)), sx: o3.sx, sy: o3.sy, width: o3.width, height: o3.height, stride: o3.stride, colorMode: o3.colorMode, pixelFormat: o3.pixelFormat, timeSpent: o3.timeSpent, timeStamp: o3.timeStamp, isCropped: o3.isCropped, toCanvas: o3.toCanvas, _sWidth: o3._sWidth, _sHeight: o3._sHeight, _bUseWebGL: o3._bUseWebGL };
            await t3.apply(this, [e4]);
          } catch (t4) {
            console.error(t4);
          }
        }), t2.style.position = "absolute", t2.style.top = "-9999px", t2.style.backgroundColor = "transparent", t2.style.color = "transparent";
        const e2 = document.createElement("div");
        e2.append(t2), e2.style.position = "absolute", e2.style.width = "1px", e2.style.height = "1px", e2.style.overflow = "hidden", e2.style.pointerEvents = "none", this._elContainer.prepend(e2), this._singleFrameInputContainer = e2;
      }
      null == t2 || t2.click();
    }, this.styleEls = [], this._framePixelFormat = void 0, this._defaultFramePixelFormat = "rgba", this.mapPixelFormatString_Enum = /* @__PURE__ */ new Map([["grey", D.GREY], ["grey32", D.GREY32], ["rgba", D.RGBA], ["rbga", D.RBGA], ["grba", D.GRBA], ["gbra", D.GBRA], ["brga", D.BRGA], ["bgra", D.BGRA]]), this.shaderPixelFormat = D.RGBA, this.maxVideoCvsLength = 3, this._reusedCvs = null, this._reusedWebGLCvs = null, this._tempDataContainer = null, this._webGLTexture = null, this._webGLProgramInfo = null, this._webGLBuffers = null, this._softwareScale = 1, this._scaleCenter = { x: 0, y: 0 }, this._focusParameters = { maxTimeout: 400, minTimeout: 300, kTimeout: void 0, oldDistance: null, fds: null, isDoingFocus: 0, taskBackToContinous: null, curFocusTaskId: 0, focusCancelableTime: 1500, defaultFocusAreaSizeRatio: 6, focusBackToContinousTime: 5e3, tapFocusMinDistance: null, tapFocusMaxDistance: null, _focusArea: null }, this._tapFocusEnabled = true, this._focusSupported = true, this._tapDoFocus = async (t2) => {
      if (this._touchMoved) return void (this._touchMoved = false);
      if (!this._tapFocusEnabled) return;
      if (!this._bOpen) return;
      if (this._isSingleFrameModeEnabled()) return;
      if (!this._video || this._video.paused) return;
      if (!this._videoTrack) return;
      if (!this._focusSupported) return;
      if (this.getDrawingLayers().some((t3) => "editor" == t3.getMode())) return;
      if (!this._focusParameters.fds && (this._focusParameters.fds = (await this.getCapabilities()).focusDistance, !this._focusParameters.fds)) return void (this._focusSupported = false);
      if (null == this._focusParameters.kTimeout && (this._focusParameters.kTimeout = (this._focusParameters.maxTimeout - this._focusParameters.minTimeout) / (1 / this._focusParameters.fds.min - 1 / this._focusParameters.fds.max)), 1 == this._focusParameters.isDoingFocus) return;
      let e2, i2, r3, n3;
      if (this._focusParameters.taskBackToContinous && (clearTimeout(this._focusParameters.taskBackToContinous), this._focusParameters.taskBackToContinous = null), t2 instanceof MouseEvent) e2 = t2.clientX, i2 = t2.clientY;
      else {
        if (!(t2 instanceof TouchEvent)) throw new Error("Unknown event type.");
        if (!t2.changedTouches.length) return;
        e2 = t2.changedTouches[0].clientX, i2 = t2.changedTouches[0].clientY;
      }
      const s3 = this.getVideoFit(), o3 = this._video.videoWidth, a3 = this._video.videoHeight, h3 = this._elContainer.getBoundingClientRect(), l3 = h3.left, c3 = h3.top, u3 = window.getComputedStyle(this._elContainer), d3 = parseFloat(u3.width), f3 = parseFloat(u3.height), g3 = d3 / f3, p3 = o3 / a3;
      let m3 = 1;
      if ("contain" === s3) if (p3 > g3) {
        m3 = d3 / o3, r3 = (e2 - l3) / m3;
        n3 = (i2 - c3 - (f3 - d3 / p3) / 2) / m3;
      } else {
        m3 = f3 / a3, n3 = (i2 - c3) / m3;
        r3 = (e2 - l3 - (d3 - f3 * p3) / 2) / m3;
      }
      else {
        if ("cover" !== s3) throw new Error("Unsupported object-fit.");
        if (p3 > g3) {
          m3 = f3 / a3, n3 = (i2 - c3) / m3;
          r3 = (e2 - l3 + (f3 * p3 - d3) / 2) / m3;
        } else {
          m3 = d3 / o3, r3 = (e2 - l3) / m3;
          n3 = (i2 - c3 + (d3 / p3 - f3) / 2) / m3;
        }
      }
      const v3 = { x: r3 + "px", y: n3 + "px" }, _3 = 2 * Math.round(Math.min(o3, a3) / this._focusParameters.defaultFocusAreaSizeRatio / 2) + "px", y3 = _3;
      await this._setLocalFocus(v3, _3, y3, this._focusParameters.tapFocusMinDistance, this._focusParameters.tapFocusMaxDistance), this._focusParameters.taskBackToContinous = setTimeout(() => {
        this._videoTrack && this._videoTrack.applyConstraints({ advanced: [{ focusMode: "continuous" }] }).catch(() => {
        });
      }, this._focusParameters.focusBackToContinousTime);
    }, this._touchMoved = false, this._touchMoveEvent = () => {
      this._touchMoved = true;
    }, this._recordedStates = {}, this.playCallbackInfo = null, this._toCanvas = function() {
      const t2 = document.createElement("canvas");
      let e2;
      t2.width = this.width, t2.height = this.height;
      if ("grey" === (this.pixelFormat || this.colorMode)) {
        e2 = new Uint8ClampedArray(this.width * this.height * 4);
        for (let t3 = 0; t3 < e2.length; t3 += 4) e2[t3] = this.data[t3 / 4], e2[t3 + 1] = this.data[t3 / 4], e2[t3 + 2] = this.data[t3 / 4], e2[t3 + 3] = 255;
      } else e2 = new Uint8ClampedArray(this.data.buffer);
      const i2 = new ImageData(e2, this.width, this.height);
      return t2.getContext("2d").putImageData(i2, 0, 0), t2;
    }, this._onCameraSelChange = async () => {
      await this.selectCamera(this._selCam.value), this._bOpen || this.stop();
    }, this._onResolutionSelChange = async () => {
      let t2, e2;
      if (this._selRsl && -1 != this._selRsl.selectedIndex) {
        let i2 = this._selRsl.options[this._selRsl.selectedIndex];
        t2 = i2.getAttribute("data-width"), e2 = i2.getAttribute("data-height");
      }
      await this.setResolution(t2, e2), this._bOpen || this.stop();
    }, this._onCloseBtnClick = () => {
      this.close(true);
    }, this._bOpen = false, this.isCameraEnhancer = true, this.isDisposed = false, this.disposed = false, this.videoSrc = null, this.cameraOpenTimeout = 4e3, this.videoSettings = { video: { width: { ideal: 1280 }, height: { ideal: 720 }, facingMode: { ideal: "environment" } } }, this.iPlayRound = 0, this.promisePlay = null, this._ifSaveLastUsedCamera = false, this.ifSkipCameraInspection = false, this._allCameras = [], this._currentCamera = null, this._videoTrack = null, this._lastDeviceId = void 0, this._vc_bPlayingVideoBeforeHide = false, this._ev_documentHideEvent = () => {
      this._isSingleFrameModeEnabled() || ("visible" === document.visibilityState ? (_I._onLog && _I._onLog("DCE: document visible."), this._video && this._bOpen && (async () => {
        let t2 = false;
        if (this._video.paused) {
          _I._onLog && _I._onLog("document visible. Not auto resume. 1st resume start.");
          try {
            await this._video.play(), t2 = true;
          } catch (t3) {
            _I._onLog && _I._onLog("document visible. 1st resume video failed, try open instead.");
          }
          t2 || await this.play();
        }
        if (await new Promise((t3) => setTimeout(t3, 300)), this._video.paused) {
          _I._onLog && _I._onLog("document visible. 1st open failed. 2rd resume start."), t2 = false;
          try {
            await this._video.play(), t2 = true;
          } catch (t3) {
            _I._onLog && _I._onLog("document visible. 2rd resume video failed, try open instead.");
          }
          t2 || await this.play();
        }
      })()) : "hidden" === document.visibilityState && (_I._onLog && _I._onLog("DCE: document hidden."), this._video && this._bOpen && (this._video.paused || this.pause())));
    }, this.containerClassName = "dce-video-container", this._elContainer = null, this._videoContainer = null, this._video = null, this.videoFit = "contain", this._cvsScanRegion = null, this._divScanArea = null, this._divScanLight = null, this._bgLoading = null, this._selCam = null, this._bgCamera = null, this._selRsl = null, this._optGotRsl = null, this._btnClose = null, this._selMinLtr = null, this._optGotMinLtr = null, this.regionMaskFillStyle = "rgba(0,0,0,0.5)", this.regionMaskStrokeStyle = "rgb(254,142,20)", this.regionMaskLineWidth = 2, this._bShowScanRegionMask = true, this._bShowScanRegionLaser = void 0, this._defaultBShowScanRegionLaser = false, this._scanRegion = null, this._arrScanRegionOverlays = [], this._layerBaseCvs = null, this._drawingLayerOfTip = null, this._tipArgs = { x: void 0, y: void 0, width: void 0, duration: void 0, autoShowSuggestedTip: void 0 }, this._hideTipTimeoutId = null, this.onTipSuggested = null, this._cvsViewDecorator = null, this._decoratorType = [], this._decoratorArea = null, this._viewDecoratorInfo = { rectangle: { lineWidth: 4, strokeStyle: "rgb(254,142,20)", fillStyle: "transparent", maskFillStyle: "transparent" }, focus: { lineWidth: 4, strokeStyle: "rgb(254,142,20)", fillStyle: "transparent", maskFillStyle: "transparent" }, crossline: { lineWidth: 2, strokeStyle: "rgb(254,142,20)" }, crosshair: { lineWidth: 4, strokeStyle: "rgb(254,142,20)" } }, this._croppingRegions = void 0, this._defaultCroppingRegions = [null], this.bIncreaseRegionIndexAuto = true, this._croppingRegionIndex = 0, this._loopInterval = void 0, this._defaultLoopInterval = 0, this._maxNumberOfFramesInBuffer = void 0, this._defaultMaxNumberOfFramesInBuffer = 1, this._frameQueue = [], this._bFetchingLoopStarted = false, this._refreshInterval = void 0, this._defaultRefreshInterval = -1, this._updateLayersTimeout = 500, this._updateLayers = () => {
      this._cvsScanRegion && (this._cvsScanRegion.style.display = "none"), this._divScanLight && (this._divScanLight.style.display = "none"), this._cvsViewDecorator && (this._cvsViewDecorator.style.display = "none");
      for (let t2 of this._arrScanRegionOverlays) t2 && (t2.style.display = "none");
      this._resizeTimeoutId && clearTimeout(this._resizeTimeoutId), this._resizeTimeoutId = setTimeout(() => {
        if (!this.isDisposed || !this.disposed) {
          this.ifShowScanRegionMask && this.showScanRegionMask(), this.ifShowScanRegionLaser && this.showScanRegionLaser(), this._cvsViewDecorator && this.showViewDecorator(), this._updateScanRegionCanvas(), this._updateScanAreaDiv(), this._updateViewDecorator();
          for (let t2 of this._arrScanRegionOverlays) t2 && (t2.style.display = "", this._updateScanRegionOverlay(t2));
          this._updateDrawingLayersSize(), this._updateVideoContainerStyle();
        }
      }, this._updateLayersTimeout);
    }, this._windowResizeListener = () => {
      this._windowWidth !== document.documentElement.clientWidth && (this._windowWidth = document.documentElement.clientWidth, this._updateLayers());
    }, this.mapCameraEvents = /* @__PURE__ */ new Map([["cameraopen", []], ["cameraclose", []], ["camerachange", []], ["resolutionchange", []], ["played", []], ["singleframeacquired", []], ["frameaddedtobuffer", []]]), this._controler = null, navigator && navigator.mediaDevices && navigator.mediaDevices.getUserMedia ? this._singleFrameMode = false : this._singleFrameMode = true;
  }
  _isSingleFrameModeEnabled() {
    return 0 != this.singleFrameMode;
  }
  async play(t2, e2, i2, r3) {
    let n3;
    if (this._video && this.videoSrc) {
      _I._onLog && (n3 = Date.now(), _I._onLog("DCE: start loading static video: " + n3));
      const t3 = await _I.playVideo(this._video, this.videoSrc, this.cameraOpenTimeout);
      if (_I._onLog && _I._onLog("DCE: finish loading static video. Costs: " + (Date.now() - n3)), !this._video) return t3.pause(), this.playCallbackInfo = { width: 0, height: 0, deviceId: null }, { width: 0, height: 0, deviceId: null };
      const e3 = { width: this._video.videoWidth, height: this._video.videoHeight, deviceId: this._currentCamera && this._currentCamera.deviceId };
      this.playCallbackInfo = JSON.parse(JSON.stringify(e3));
      const i3 = this.mapCameraEvents.get("played");
      for (let t4 of i3) {
        if (!t4) continue;
        const i4 = JSON.parse(JSON.stringify(e3));
        setTimeout(() => {
          this.isDisposed && this.disposed || t4.apply(this, [i4]);
        }, 0);
      }
      return this._recordedStates.videoPlaying = true, e3;
    }
    if (this._isSingleFrameModeEnabled()) return r3 && r3.notTriggerSingleFrameClick || this._clickIptSingleFrameMode(), this.playCallbackInfo = { width: 0, height: 0, deviceId: null }, { width: 0, height: 0, deviceId: null };
    if (!this._video) throw new Error("'video' is null or undefined.");
    const s3 = ++this.iPlayRound;
    if (this.promisePlay && (await this.promisePlay, s3 < this.iPlayRound)) return this.playCallbackInfo = { width: this._video.videoWidth, height: this._video.videoHeight, deviceId: this._currentCamera && this._currentCamera.deviceId }, { width: this._video.videoWidth, height: this._video.videoHeight, deviceId: this._currentCamera && this._currentCamera.deviceId };
    this.promisePlay = (async () => {
      var n4;
      try {
        this._video && this._video.srcObject && this.stop(), _I._onLog && _I._onLog("DCE: ======before video========");
        const s4 = () => {
          if (!this._video) throw h3 && h3.getTracks().forEach((t3) => {
            t3.stop();
          }), this._videoTrack = null, this._currentCamera = null, new Error("'video' is null or undefined.");
        }, o4 = this.getVideoSettings();
        let a3, h3;
        if ("boolean" == typeof o4.video && (o4.video = {}), t2) delete o4.video.facingMode, o4.video.deviceId = { exact: t2 };
        else if (o4.video.deviceId) ;
        else if (this._lastDeviceId) delete o4.video.facingMode, o4.video.deviceId = { exact: this._lastDeviceId };
        else if (this.ifSaveLastUsedCamera && _I.isStorageAvailable && window.localStorage.getItem("dce_last_camera_id")) {
          delete o4.video.facingMode, o4.video.deviceId = { ideal: window.localStorage.getItem("dce_last_camera_id") };
          const t3 = JSON.parse(window.localStorage.getItem("dce_last_apply_width")), e3 = JSON.parse(window.localStorage.getItem("dce_last_apply_height"));
          t3 && e3 && (o4.video.width = t3, o4.video.height = e3);
        } else if (this.ifSkipCameraInspection) ;
        else if (o4.video.facingMode) {
          if (await this.getAllCameras(false), !this._video) throw new Error("'video' is null or undefined.");
          let t3 = o4.video.facingMode;
          if (t3 instanceof Array && t3.length && (t3 = t3[0]), t3 = t3.exact || t3.ideal || t3, "environment" === t3) {
            a3 = true;
            const t4 = _I.findBestRearCamera(this._allCameras);
            t4 && (delete o4.video.facingMode, o4.video.deviceId = { exact: t4 });
          }
        }
        e2 && (o4.video.width = { ideal: e2 }), i2 && (o4.video.height = { ideal: i2 }), _I._onLog && _I._onLog("======try getUserMedia========");
        let l3 = [0, 500, 1e3, 2e3], c3 = null;
        const u3 = async (t3) => {
          for (let e3 of l3) {
            e3 && (await new Promise((t4) => setTimeout(t4, e3)), s4());
            try {
              _I._onLog && _I._onLog("ask " + JSON.stringify(t3)), h3 = await navigator.mediaDevices.getUserMedia(t3), s4();
              break;
            } catch (t4) {
              if ("NotFoundError" === t4.name || "NotAllowedError" === t4.name || "AbortError" === t4.name || "OverconstrainedError" === t4.name) throw t4;
              c3 = t4, _I._onLog && _I._onLog(t4.message || t4);
            }
          }
        };
        try {
          if (await u3(o4), h3 || "object" != typeof o4.video || (o4.video.deviceId && (delete o4.video.deviceId, await u3(o4)), !h3 && o4.video.facingMode && (delete o4.video.facingMode, await u3(o4)), h3 || !o4.video.width && !o4.video.height || (delete o4.video.width, delete o4.video.height, await u3(o4))), !h3) throw c3;
        } catch (t3) {
          throw null == h3 || h3.getTracks().forEach((t4) => {
            t4.stop();
          }), "NotFoundError" === t3.name && (DOMException ? t3 = new DOMException("No camera available, please use a device with an accessible camera.", t3.name) : (t3 = new Error("No camera available, please use a device with an accessible camera.")).name = "NotFoundError"), t3;
        }
        const d3 = () => {
          const t3 = h3.getVideoTracks();
          let e3, i3;
          if (t3.length && (e3 = this._videoTrack = t3[0]), this._video && e3) {
            const t4 = e3.getSettings();
            if (t4) {
              for (let r4 of this._allCameras) if (t4.deviceId === r4.deviceId) {
                r4._checked = true, r4.label = e3.label, i3 = r4;
                break;
              }
            }
          }
          this._currentCamera = i3;
        };
        if (await this.getAllCameras(false), s4(), a3 && !this.ifSkipCameraInspection) {
          d3();
          const t3 = _I.findBestRearCamera(this._allCameras), e3 = null === (n4 = this._currentCamera) || void 0 === n4 ? void 0 : n4.deviceId;
          t3 && t3 != e3 && (h3.getTracks().forEach((t4) => {
            t4.stop();
          }), o4.video.deviceId = { exact: t3 }, await u3(o4));
        }
        _I._onLog && _I._onLog("DCE: ======play video========"), s4(), await _I.playVideo(this._video, h3, this.cameraOpenTimeout), s4(), _I._onLog && _I._onLog("DCE: ======played video========"), this._bgLoading && (this._bgLoading.style.animationPlayState = "paused");
        const f3 = "got " + this._video.videoWidth + "x" + this._video.videoHeight;
        this._optGotRsl && (this._optGotRsl.setAttribute("data-width", this._video.videoWidth), this._optGotRsl.setAttribute("data-height", this._video.videoHeight), this._optGotRsl.innerText = f3, this._selRsl && this._optGotRsl.parentNode == this._selRsl && (this._selRsl.value = "got")), _I._onLog && _I._onLog("DCE: got " + f3), d3(), this._renderSelCameraInfo();
        const g3 = { width: this._video.videoWidth, height: this._video.videoHeight, deviceId: this._currentCamera && this._currentCamera.deviceId };
        if (g3.deviceId && (this._lastDeviceId = g3.deviceId, this.ifSaveLastUsedCamera && _I.isStorageAvailable && (window.localStorage.setItem("dce_last_camera_id", this._lastDeviceId), o4.video.width && o4.video.height && (window.localStorage.setItem("dce_last_apply_width", JSON.stringify(o4.video.width)), window.localStorage.setItem("dce_last_apply_height", JSON.stringify(o4.video.height))))), !r3 || !r3.notTriggerPlayedEvent) {
          const t3 = this.mapCameraEvents.get("played");
          for (let e3 of t3) {
            if (!e3) continue;
            const t4 = JSON.parse(JSON.stringify(g3));
            setTimeout(() => {
              this.isDisposed && this.disposed || e3.apply(this, [t4]);
            }, 0);
          }
        }
        return this.promisePlay = null, g3;
      } catch (t3) {
        throw this.promisePlay = null, this._bgLoading && (this._bgLoading.style.display = "none"), "NotFoundError" === t3.name && (DOMException ? t3 = new DOMException("No camera available, please use a device with an accessible camera.", t3.name) : (t3 = new Error("No camera available, please use a device with an accessible camera.")).name = "NotFoundError"), t3;
      }
    })(), _I._onLog && (n3 = Date.now(), _I._onLog("DCE: start opening camera: " + n3));
    const o3 = await this.promisePlay;
    return _I._onLog && _I._onLog("DCE: finish opening camera. Costs: " + (Date.now() - n3)), this.playCallbackInfo = JSON.parse(JSON.stringify(o3)), this._recordedStates.videoPlaying = true, o3;
  }
  async resume() {
    this._assertOpen(), this._video && (await this._video.play(), this._recordedStates.videoPlaying = true), this.ifShowScanRegionLaser && this.showScanRegionLaser();
  }
  pause() {
    this._assertOpen(), this._video && (this._video.pause(), this._recordedStates.videoPlaying = false), this.ifShowScanRegionLaser && this.hideScanRegionLaser();
  }
  isPaused() {
    var t2;
    return !this._isSingleFrameModeEnabled() && true === (null === (t2 = this._video) || void 0 === t2 ? void 0 : t2.paused);
  }
  _bindUI() {
    if (!this.UIElement) throw new Error("Need to define `UIElement` before opening.");
    const t2 = [this.UIElement];
    for (let e2 = 0; e2 < t2.length; ++e2) for (let i2 of t2[e2].children) t2.push(i2);
    for (let e2 of t2) {
      if (!this._video && e2.classList.contains(this.containerClassName)) {
        this._elContainer = e2;
        const t3 = document.createElement("video");
        t3.style.position = "absolute", t3.style.left = "0", t3.style.top = "0", t3.style.width = "100%", t3.style.height = "100%", t3.style.objectFit = this.getVideoFit(), t3.setAttribute("autoplay", "true"), t3.setAttribute("playsinline", "true"), t3.setAttribute("muted", "true"), ["iPhone", "iPad", "Mac"].includes(s.OS) && s.version >= 17 && t3.setAttribute("poster", "data:image/gif;base64,R0lGODlhAQABAIEAAAAAAAAAAAAAAAAAACH5BAEAAAAALAAAAAABAAEAAAgEAAEEBAA7"), this._video = t3;
        const i2 = document.createElement("div");
        i2.append(t3), i2.style.position = "absolute", i2.style.left = "0", i2.style.top = "0", i2.style.width = "100%", i2.style.height = "100%", i2.style.overflow = "hidden", this._videoContainer = i2, e2.prepend(i2);
      } else !this._divScanArea && e2.classList.contains("dce-scanarea") ? this._divScanArea = e2 : !this._divScanLight && e2.classList.contains("dce-scanlight") ? this._divScanLight = e2 : !this._bgLoading && e2.classList.contains("dce-bg-loading") ? this._bgLoading = e2 : !this._bgCamera && e2.classList.contains("dce-bg-camera") ? this._bgCamera = e2 : !this._selCam && e2.classList.contains("dce-sel-camera") ? this._selCam = e2 : !this._selRsl && e2.classList.contains("dce-sel-resolution") ? (this._selRsl = e2, this.videoSrc || this._isSingleFrameModeEnabled() || this._selRsl.options.length || (this._selRsl.innerHTML = [this._optGotRsl ? "" : '<option class="dce-opt-gotResolution" value="got"></option>', '<option data-width="1920" data-height="1080">ask 1920x1080</option>', '<option data-width="1280" data-height="720">ask 1280x720</option>', '<option data-width="640" data-height="480">ask 640x480</option>'].join(""), this._optGotRsl = this._optGotRsl || this._selRsl.options[0])) : !this._optGotRsl && e2.classList.contains("dce-opt-gotResolution") ? this._optGotRsl = e2 : !this._btnClose && e2.classList.contains("dce-btn-close") ? this._btnClose = e2 : !this._selMinLtr && e2.classList.contains("dlr-sel-minletter") ? (this._selMinLtr = e2, this._selMinLtr.options.length || (this._selMinLtr.innerHTML = [this._optGotMinLtr ? "" : '<option class="dlr-opt-gotMinLtr" value="got"></option>', '<option value="0" selected>any letter</option>', '<option value="3">3+ letters</option>', '<option value="5">5+ letters</option>', '<option value="8">8+ letters</option>', '<option value="12">12+ letters</option>', '<option value="17">17+ letters</option>', '<option value="30">30+ letters</option>', '<option value="50">50+ letters</option>', '<option value="80">80+ letters</option>', '<option value="120">120+ letters</option>'].join(""), this._optGotMinLtr = this._optGotMinLtr || this._selMinLtr.options[0])) : !this._optGotMinLtr && e2.classList.contains("dlr-opt-gotMinLtr") && (this._optGotMinLtr = e2);
      if (this.extraBindings && this.extraBindings.length) for (let t3 of this.extraBindings) try {
        t3(e2);
      } catch (t4) {
      }
    }
    if (!this._video) throw this._unbindUI(), Error(`Can not find the video container element with class '${this.containerClassName}'`);
    this._isSingleFrameModeEnabled() || this.videoSrc ? (this._isSingleFrameModeEnabled() && (this._elContainer && (this._elContainer.addEventListener("click", this._clickIptSingleFrameMode), this._elContainer.setAttribute("title", "Take a photo")), this._bgCamera && (this._bgCamera.style.display = "block")), this._selCam && (this._selCam.style.display = "none"), this._selRsl && (this._selRsl.style.display = "none"), this._selMinLtr && (this._selMinLtr.style.display = "none")) : (this._elContainer && (["Android", "HarmonyOS"].includes(s.OS) ? (this._elContainer.addEventListener("touchend", this._tapDoFocus), this._elContainer.addEventListener("touchmove", this._touchMoveEvent)) : this._elContainer.addEventListener("click", this._tapDoFocus)), this._selCam && (this._selCam.style.display = "block", this._selCam.addEventListener("change", this._onCameraSelChange)), this._selRsl && (this._selRsl.style.display = "block", this._selRsl.addEventListener("change", this._onResolutionSelChange)), this._selMinLtr && (this._selMinLtr.style.display = "block"), this._bgLoading && (this._bgLoading.style.display = "block")), this._btnClose && this._btnClose.addEventListener("click", this._onCloseBtnClick), document.addEventListener("visibilitychange", this._ev_documentHideEvent), window.ResizeObserver && (this._resizeObserver || (this._resizeObserver = new ResizeObserver((t3) => {
      for (let e2 of t3) e2.target === this._elContainer && this._updateLayers();
    })), this._elContainer && this._resizeObserver.observe(this._elContainer)), this._windowWidth = document.documentElement.clientWidth, window.addEventListener("resize", this._windowResizeListener);
  }
  _unbindUI() {
    this._isSingleFrameModeEnabled() ? (this._elContainer && (this._elContainer.removeEventListener("click", this._clickIptSingleFrameMode), this._elContainer.removeAttribute("title")), this._bgCamera && (this._bgCamera.style.display = "none")) : this._bgLoading && (this._bgLoading.style.display = "none"), this._elContainer && (this._elContainer.removeEventListener("click", this._tapDoFocus), this._elContainer.removeEventListener("touchend", this._tapDoFocus), this._elContainer.removeEventListener("touchmove", this._touchMoveEvent)), this._selCam && this._selCam.removeEventListener("change", this._onCameraSelChange), this._selRsl && this._selRsl.removeEventListener("change", this._onResolutionSelChange), this._btnClose && this._btnClose.removeEventListener("click", this._onCloseBtnClick), this.hideScanRegionLaser(), this.hideViewDecorator(), this.hideScanRegionOverlays(), this._drawingLayerManager.setVisible(false), this._hideOriginalImageCvs(), this._videoContainer && this._videoContainer.remove(), this._video = null, this._videoContainer = null, this._elContainer = null, this._selCam = null, this._selRsl = null, this._optGotRsl = null, this._btnClose = null, this._selMinLtr = null, this._optGotMinLtr = null, this._divScanArea = null, this._divScanLight = null, this._cvsScanRegion && (this._cvsScanRegion.remove(), this._cvsScanRegion = null), this._singleFrameInputContainer && (this._singleFrameInputContainer.remove(), this._singleFrameInputContainer = null), this._cvsSingleFrameMode && (this._cvsSingleFrameMode.remove(), this._cvsSingleFrameMode = null), document.removeEventListener("visibilitychange", this._ev_documentHideEvent), window.ResizeObserver && this._resizeObserver && this._resizeObserver.disconnect(), window.removeEventListener("resize", this._windowResizeListener);
  }
  _assertOpen() {
    if (!this._bOpen) throw Error("The camera is not open.");
  }
  async open(t2) {
    this.UIElement || await this.setUIElement(_I.defaultUIElementURL), this._bindUI(), t2 && this.appendAndShowUI();
    let e2 = await this.play();
    this.bOpen = true, this._focusParameters.fds = null, this._focusParameters.kTimeout = void 0, this._focusSupported = true, this._tapFocusEnabled && !this._isSingleFrameModeEnabled() && (this._focusParameters.fds = (await this.getCapabilities()).focusDistance, this._focusParameters.fds || (this._focusSupported = false, this._tapFocusEnabled = false));
    const i2 = this.mapCameraEvents.get("cameraopen");
    for (let t3 of i2) {
      if (!t3) continue;
      const i3 = JSON.parse(JSON.stringify(e2));
      setTimeout(() => {
        this.isDisposed && this.disposed || t3.apply(this, [i3]);
      }, 0);
    }
    return e2;
  }
  close(t2) {
    if (!this._video) return;
    this.stop(), this._hideOriginalImage(false), this.hideTip(), this._unbindUI(), t2 && this.hideUI(), this.stopFetchingLoop(), this.bOpen = false;
    const e2 = this.mapCameraEvents.get("cameraclose");
    for (let t3 of e2) {
      if (!t3) continue;
      const e3 = { width: 0, height: 0, deviceId: null };
      setTimeout(() => {
        this.isDisposed && this.disposed || t3.apply(this, [e3]);
      }, 0);
    }
  }
  stop() {
    this._video && this._video.srcObject && (_I._onLog && _I._onLog("DCE: ======stop video========"), this._video.srcObject.getTracks().forEach((t2) => {
      t2.stop();
    }), this._video.srcObject = null, this._videoTrack = null, this._currentCamera = null), this._video && this.videoSrc && (_I._onLog && _I._onLog("DCE: ======stop existing video========"), this._video.pause(), this._video.currentTime = 0), this._bgLoading && (this._bgLoading.style.animationPlayState = ""), this._frameQueue.length = 0, this._reusedCvs && this._reusedCvs.ctx2d && this._reusedCvs.ctx2d.clearRect(0, 0, this._reusedCvs.width, this._reusedCvs.height), this.forceLoseContext();
  }
  async getAllCameras(t2 = true) {
    let e2 = (await navigator.mediaDevices.enumerateDevices()).filter((t3) => "videoinput" === t3.kind);
    if (t2 && e2 && e2.length && !e2[0].deviceId) {
      let t3 = await navigator.mediaDevices.getUserMedia({ video: true });
      e2 = (await navigator.mediaDevices.enumerateDevices()).filter((t4) => "videoinput" === t4.kind), t3.getTracks().forEach((t4) => {
        t4.stop();
      });
    }
    const i2 = [], r3 = [];
    if (this._allCameras) for (let t3 of this._allCameras) t3._checked && r3.push(t3);
    for (let t3 = 0; t3 < e2.length; t3++) {
      let n3, s3 = e2[t3];
      for (let t4 of r3) if (s3.deviceId == t4.deviceId) {
        n3 = t4;
        break;
      }
      n3 || (n3 = { deviceId: s3.deviceId, label: s3.label ? s3.label : "camera " + t3, _checked: false }), n3.deviceId && i2.push(n3);
    }
    return this._allCameras = i2, _I._onLog && _I._onLog("DCE: " + JSON.stringify(this._allCameras)), i2;
  }
  _renderSelCameraInfo() {
    if (!this._selCam) return;
    let t2;
    this._selCam.textContent = "";
    for (let e2 of this._allCameras) {
      const i2 = document.createElement("option");
      i2.value = e2.deviceId, i2.innerText = e2.label, this._selCam.append(i2), e2.deviceId && this._currentCamera && this._currentCamera.deviceId == e2.deviceId && (t2 = i2);
    }
    this._selCam.value = t2 ? t2.value : "";
  }
  getSelectedCamera() {
    if (!this._bOpen) {
      let t2 = "";
      const e2 = this.videoSettings.video.deviceId;
      e2 && (t2 = e2.exact || e2.ideal || e2);
      for (let e3 of this._allCameras) if (e3.deviceId === t2) return JSON.parse(JSON.stringify(e3));
      return { deviceId: t2, label: "", _checked: false };
    }
    return this._currentCamera;
  }
  async selectCamera(t2) {
    let e2 = "";
    if (t2 && (e2 = t2.deviceId || t2), this.videoSettings.video.deviceId = { exact: e2 }, !this._bOpen || this._video.paused) return null;
    let i2 = null;
    this._currentCamera && (i2 = this._currentCamera.deviceId);
    const r3 = this._video.videoWidth, n3 = this._video.videoHeight, s3 = await this.play(t2.deviceId || t2);
    if (this._focusParameters.fds = null, this._focusParameters.kTimeout = void 0, this._focusSupported = true, this._tapFocusEnabled && !this._isSingleFrameModeEnabled() && (this._focusParameters.fds = (await this.getCapabilities()).focusDistance, this._focusParameters.fds || (this._focusSupported = false, this._tapFocusEnabled = false)), i2 !== s3.deviceId) {
      const t3 = this.mapCameraEvents.get("camerachange");
      for (let e3 of t3) {
        if (!e3) continue;
        const t4 = JSON.parse(JSON.stringify(s3));
        setTimeout(() => {
          this.isDisposed && this.disposed || e3.apply(this, [t4]);
        }, 0);
      }
    }
    if (r3 !== s3.width || n3 !== s3.height) {
      this._updateScanRegionCanvas(), this._updateScanAreaDiv(), this._updateViewDecorator();
      for (let t4 of this._arrScanRegionOverlays) t4 && this._updateScanRegionOverlay(t4);
      this._updateDrawingLayersSize(), this._updateVideoContainerStyle();
      const t3 = this.mapCameraEvents.get("resolutionchange");
      for (let e3 of t3) {
        if (!e3) continue;
        const t4 = JSON.parse(JSON.stringify(s3));
        setTimeout(() => {
          this.isDisposed && this.disposed || e3.apply(this, [t4]);
        }, 0);
      }
    }
    return s3;
  }
  getResolution() {
    if (this._bOpen) return [this._video.videoWidth, this._video.videoHeight];
    {
      let t2 = 0, e2 = 0;
      const i2 = this.videoSettings.video.width, r3 = this.videoSettings.video.height;
      return i2 && (t2 = i2.exact || i2.ideal || i2), r3 && (e2 = r3.exact || r3.ideal || r3), [t2, e2];
    }
  }
  async setResolution(t2, e2) {
    let i2, r3;
    if (t2 instanceof Array ? (i2 = t2[0], r3 = t2[1]) : (i2 = t2, r3 = e2), this.videoSettings.video.width = { ideal: i2 }, this.videoSettings.video.height = { ideal: r3 }, !this._bOpen || this._video.paused) return null;
    const n3 = this._video.videoWidth, s3 = this._video.videoHeight, o3 = await this.play(null, i2, r3);
    if (n3 !== o3.width || s3 !== o3.height) {
      this._updateScanRegionCanvas(), this._updateScanAreaDiv(), this._updateViewDecorator();
      for (let t4 of this._arrScanRegionOverlays) t4 && this._updateScanRegionOverlay(t4);
      this._updateDrawingLayersSize(), this._updateVideoContainerStyle();
      const t3 = this.mapCameraEvents.get("resolutionchange");
      for (let e3 of t3) {
        if (!e3) continue;
        const t4 = JSON.parse(JSON.stringify(o3));
        setTimeout(() => {
          this.isDisposed && this.disposed || e3.apply(this, [t4]);
        }, 0);
      }
    }
    return o3;
  }
  async getResolutions(t2) {
    var e2, i2;
    let r3 = "";
    const n3 = (t3, e3) => {
      const i3 = this._mapCameraResolutions.get(t3);
      if (!i3 || !i3.length) return false;
      for (let t4 of i3) if (t4[0] === e3.width && t4[1] === e3.height) return true;
      return false;
    }, s3 = async (t3, e3, i3) => {
      const r4 = { video: { deviceId: { exact: t3 }, width: { ideal: e3 }, height: { ideal: i3 } } };
      let n4 = null;
      try {
        n4 = await navigator.mediaDevices.getUserMedia(r4);
      } catch (t4) {
        return null;
      }
      if (!n4) return null;
      const s4 = n4.getVideoTracks();
      let o3 = null;
      try {
        const t4 = s4[0].getSettings();
        o3 = { width: t4.width, height: t4.height };
      } catch (t4) {
        const e4 = document.createElement("video");
        e4.srcObject = n4, o3 = { width: e4.videoWidth, height: e4.videoHeight }, e4.srcObject = null;
      }
      return s4.forEach((t4) => {
        t4.stop();
      }), o3;
    };
    if (!this._bOpen) {
      const o3 = null === (i2 = null === (e2 = this.videoSettings) || void 0 === e2 ? void 0 : e2.video) || void 0 === i2 ? void 0 : i2.deviceId;
      if (!o3) return null;
      if (r3 = o3.hasOwnProperty("exact") ? this.videoSettings.video.deviceId.exact : o3.hasOwnProperty("ideal") ? this.videoSettings.video.deviceId.ideal : this.videoSettings.video.deviceId, !r3) return null;
      let a3 = this._mapCameraResolutions.get(r3);
      if (a3 && !t2) return this._mapCameraResolutions.get(r3);
      this._mapCameraResolutions.set(r3, []), a3 = this._mapCameraResolutions.get(r3);
      for (let t3 of this._predefinedResolutions) {
        const e3 = await s3(r3, t3.width, t3.height);
        e3 && !n3(r3, e3) && a3.push([e3.width, e3.height]);
      }
      return a3;
    }
    if (this._currentCamera) {
      r3 = this._currentCamera.deviceId;
      let e3 = this._mapCameraResolutions.get(r3);
      if (e3 && !t2) return this._mapCameraResolutions.get(r3);
      this._mapCameraResolutions.set(r3, []), e3 = this._mapCameraResolutions.get(r3);
      let i3 = this._videoTrack;
      for (let t3 of this._predefinedResolutions) {
        await i3.applyConstraints({ width: { ideal: t3.width }, height: { ideal: t3.height } });
        const s4 = i3.getSettings(), o3 = { width: s4.width, height: s4.height };
        n3(r3, o3) || e3.push([o3.width, o3.height]);
      }
      return this._video.srcObject.getTracks().forEach((t3) => {
        t3.stop();
      }), await this.play(r3, null, null, { notTriggerPlayedEvent: true }), e3;
    }
    return null;
  }
  on(t2, e2) {
    if (!e2) return;
    const i2 = this.mapCameraEvents.get(t2.toLowerCase());
    if (!i2) throw new Error(`Event '${t2}' does not exist.`);
    i2.includes(e2) || i2.push(e2);
  }
  off(t2, e2) {
    const i2 = this.mapCameraEvents.get(t2.toLowerCase());
    if (!i2) throw new Error(`Event '${t2}' does not exist.`);
    const r3 = i2.indexOf(e2);
    -1 !== r3 && i2.splice(r3, 1);
  }
  offAll(t2) {
    if (t2) {
      if ("string" == typeof t2) {
        const e2 = this.mapCameraEvents.get(t2);
        e2 && (e2.length = 0);
      }
    } else for (let t3 of this.mapCameraEvents.values()) t3 && (t3.length = 0);
  }
  getVideoSettings() {
    return JSON.parse(JSON.stringify(this.videoSettings));
  }
  updateVideoSettings(t2) {
    if (this.videoSettings = JSON.parse(JSON.stringify(t2)), this._lastDeviceId = null, this._bOpen) return this.play();
  }
  isOpen() {
    return this._bOpen;
  }
  getCapabilities() {
    if (this._assertOpen(), this._isSingleFrameModeEnabled()) throw new Error("'getCapabilities()' is unavailable in singleFrameMode.");
    return this._videoTrack && this._videoTrack.getCapabilities ? this._videoTrack.getCapabilities() : {};
  }
  getCameraSettings() {
    if (this._assertOpen(), this._isSingleFrameModeEnabled()) throw new Error("'getCameraSettings()' is unavailable in singleFrameMode.");
    return this._videoTrack ? this._videoTrack.getSettings() : null;
  }
  getConstraints() {
    if (this._assertOpen(), this._isSingleFrameModeEnabled()) throw new Error("'getConstraints()' is unavailable in singleFrameMode.");
    return this._videoTrack ? this._videoTrack.getConstraints() : null;
  }
  async applyConstraints(t2) {
    if (this._assertOpen(), this._isSingleFrameModeEnabled()) throw new Error("'applyConstraints()' is unavailable in singleFrameMode.");
    if (!this._videoTrack) throw new Error('"_videoTrack" is null.');
    if (!this._videoTrack.applyConstraints) throw Error("Not supported.");
    return await this._videoTrack.applyConstraints(t2);
  }
  async turnOnTorch() {
    if (this._assertOpen(), this._isSingleFrameModeEnabled()) throw new Error("'turnOnTorch()' is unavailable in singleFrameMode.");
    if (this.getCapabilities().torch) return await this._videoTrack.applyConstraints({ advanced: [{ torch: true }] });
    throw Error("Not supported.");
  }
  async turnOffTorch() {
    if (this._assertOpen(), this._isSingleFrameModeEnabled()) throw new Error("'turnOffTorch()' is unavailable in singleFrameMode.");
    if (this.getCapabilities().torch) return await this._videoTrack.applyConstraints({ advanced: [{ torch: false }] });
    throw Error("Not supported.");
  }
  async setColorTemperature(t2) {
    if (this._assertOpen(), this._isSingleFrameModeEnabled()) throw new Error("'setColorTemperature()' is unavailable in singleFrameMode.");
    let e2 = this.getCapabilities().colorTemperature;
    if (!e2) throw Error("Not supported.");
    return t2 < e2.min ? t2 = e2.min : t2 > e2.max && (t2 = e2.max), await this._videoTrack.applyConstraints({ advanced: [{ colorTemperature: t2, whiteBalanceMode: "manual" }] });
  }
  getColorTemperature() {
    if (this._assertOpen(), this._isSingleFrameModeEnabled()) throw new Error("'getColorTemperature()' is unavailable in singleFrameMode.");
    return this._videoTrack ? this._videoTrack.getSettings().colorTemperature || 0 : null;
  }
  async setExposureCompensation(t2) {
    if (this._assertOpen(), this._isSingleFrameModeEnabled()) throw new Error("'setExposureCompensation()' is unavailable in singleFrameMode.");
    let e2 = this.getCapabilities().exposureCompensation;
    if (!e2) throw Error("Not supported.");
    return t2 < e2.min ? t2 = e2.min : t2 > e2.max && (t2 = e2.max), await this._videoTrack.applyConstraints({ advanced: [{ exposureCompensation: t2 }] });
  }
  getExposureCompensation() {
    if (this._assertOpen(), this._isSingleFrameModeEnabled()) throw new Error("'getExposureCompensation()' is unavailable in singleFrameMode.");
    return this._videoTrack ? this._videoTrack.getSettings().exposureCompensation || 0 : null;
  }
  async _setHardwareScale(t2) {
    if (this._assertOpen(), this._isSingleFrameModeEnabled()) throw new Error("'_setHardwareScale()' is unavailable in singleFrameMode.");
    if (t2 < 1) throw new RangeError("Invalid value.");
    if (!this._videoTrack) return;
    const e2 = this.getCapabilities().zoom;
    if (!e2) throw new Error("Not supported.");
    return t2 < e2.min ? t2 = e2.min : t2 > e2.max && (t2 = e2.max), t2 = M(t2, e2.min, e2.step, e2.max), await this._videoTrack.applyConstraints({ advanced: [{ zoom: t2 }] }), t2;
  }
  _getHardwareScale() {
    if (this._assertOpen(), this._isSingleFrameModeEnabled()) throw new Error("'_getHardwareScale()' is unavailable in singleFrameMode.");
    return this._videoTrack ? this._videoTrack.getSettings().zoom || 1 : null;
  }
  _setSoftwareScale(t2, e2) {
    if (this._assertOpen(), this._isSingleFrameModeEnabled()) throw new Error("'_setSoftwareScale()' is unavailable in singleFrameMode.");
    if (t2 < 1) throw new RangeError("Invalid value.");
    e2 && this._setScaleCenter(e2), this._softwareScale = t2, this._scaleVideo(t2, e2);
  }
  _getSoftwareScale() {
    return this._softwareScale;
  }
  _setScaleCenter(t2) {
    if (this._assertOpen(), this._isSingleFrameModeEnabled()) throw new Error("'_setScaleCenter()' is unavailable in singleFrameMode.");
    if (!t2 || "string" != typeof t2.x || "string" != typeof t2.y) throw new Error("Invalid center.");
    const e2 = this._video.videoWidth, i2 = this._video.videoHeight;
    let r3 = 0, n3 = 0;
    if (t2.x.endsWith("px")) r3 = parseFloat(t2.x);
    else {
      if (!t2.x.endsWith("%")) throw new Error("Invalid scale center.");
      r3 = parseFloat(t2.x) / 100 * e2;
    }
    if (t2.y.endsWith("px")) n3 = parseFloat(t2.y);
    else {
      if (!t2.y.endsWith("%")) throw new Error("Invalid scale center.");
      n3 = parseFloat(t2.y) / 100 * i2;
    }
    this._scaleCenter = { x: r3, y: n3 };
  }
  _resetScaleCenter() {
    if (this._assertOpen(), this._isSingleFrameModeEnabled()) throw new Error("'_resetScaleCenter()' is unavailable in singleFrameMode.");
    const t2 = this._video.videoWidth, e2 = this._video.videoHeight;
    this._scaleCenter = { x: t2 / 2, y: e2 / 2 };
  }
  _isVideoCenter(t2) {
    if (this._assertOpen(), this._isSingleFrameModeEnabled()) throw new Error("'_isVideoCenter()' is unavailable in singleFrameMode.");
    return t2 && t2.x == this._video.videoWidth / 2 && t2.y == this._video.videoHeight / 2;
  }
  async _setZoom(t2) {
    if (this._assertOpen(), this._isSingleFrameModeEnabled()) throw new Error("'setZoom()' is unavailable in singleFrameMode.");
    if (t2 < 1) throw new RangeError("Invalid value.");
    this._resetScaleCenter();
    try {
      if (this._isVideoCenter(this._scaleCenter)) {
        const e2 = await this._setHardwareScale(t2);
        let i2 = this._getHardwareScale();
        1 == i2 && 1 != e2 && (i2 = e2), t2 > i2 ? this._setSoftwareScale(t2 / i2) : this._setSoftwareScale(1);
      } else await this._setHardwareScale(1), this._setSoftwareScale(t2);
    } catch (e2) {
      if ("Not supported." !== (e2.message || e2)) throw e2;
      this._setSoftwareScale(t2);
    }
  }
  async setZoom(t2) {
    if ("number" != typeof t2 && "object" != typeof t2) throw new TypeError("Illegal type of argument.");
    if ("number" == typeof t2) return this._setZoom(t2);
    if (this._assertOpen(), this._isSingleFrameModeEnabled()) throw new Error("'setZoom()' is unavailable in singleFrameMode.");
    if (t2) {
      if ("number" != typeof t2.factor) throw new TypeError("Illegal type of 'factor'.");
      if (t2.factor < 1) throw new RangeError("Invalid value.");
      t2.centerPoint ? this._setScaleCenter(t2.centerPoint) : this._resetScaleCenter();
      try {
        if (this._isVideoCenter(this._scaleCenter)) {
          const e2 = await this._setHardwareScale(t2.factor);
          let i2 = this._getHardwareScale();
          1 == i2 && 1 != e2 && (i2 = e2), t2.factor > i2 ? this._setSoftwareScale(t2.factor / i2) : this._setSoftwareScale(1);
        } else await this._setHardwareScale(1), this._setSoftwareScale(t2.factor);
      } catch (e2) {
        if ("Not supported." !== (e2.message || e2)) throw e2;
        this._setSoftwareScale(t2.factor);
      }
    }
  }
  getZoom() {
    if (this._assertOpen(), this._isSingleFrameModeEnabled()) throw new Error("'getZoom()' is unavailable in singleFrameMode.");
    if (!this._videoTrack) return null;
    return this._getHardwareScale() * this._softwareScale;
  }
  getZoomSettings() {
    if (this._assertOpen(), this._isSingleFrameModeEnabled()) throw new Error("'getZoom()' is unavailable in singleFrameMode.");
    if (!this._videoTrack) return null;
    return { factor: this._getHardwareScale() * this._softwareScale };
  }
  async resetZoom() {
    await this.setZoom({ factor: 1 });
  }
  async setFrameRate(t2) {
    if (this._assertOpen(), this._isSingleFrameModeEnabled()) throw new Error("'setFrameRate()' is unavailable in singleFrameMode.");
    let e2 = this.getCapabilities().frameRate;
    if (!e2) throw Error("Not supported.");
    return t2 < e2.min ? t2 = e2.min : t2 > e2.max && (t2 = e2.max), await this._videoTrack.applyConstraints({ width: { ideal: Math.max(this._video.videoWidth, this._video.videoHeight) }, frameRate: t2 });
  }
  getFrameRate() {
    if (this._assertOpen(), this._isSingleFrameModeEnabled()) throw new Error("'getFrameRate()' is unavailable in singleFrameMode.");
    return this._videoTrack ? this._videoTrack.getSettings().frameRate : null;
  }
  async _setFocus(t2, e2) {
    if (this._assertOpen(), this._isSingleFrameModeEnabled()) throw new Error("'setFocus()' is unavailable in singleFrameMode.");
    if ("string" != typeof t2) throw Error("Invalid focus mode.");
    t2 = t2.toLowerCase();
    const i2 = this.getCapabilities().focusMode, r3 = this.getCapabilities().focusDistance;
    if (!i2) throw Error("Not supported.");
    if (!i2.includes(t2)) throw Error("Unsupported mode.");
    if (e2 >= 0) {
      if (!r3) throw Error("Manual focus unsupported.");
      return e2 < r3.min ? e2 = r3.min : e2 > r3.max && (e2 = r3.max), e2 = M(e2, r3.min, r3.step, r3.max), await this._videoTrack.applyConstraints({ advanced: [{ focusMode: t2, focusDistance: e2 }] });
    }
    return await this._videoTrack.applyConstraints({ advanced: [{ focusMode: t2 }] });
  }
  async setFocus(t2, e2) {
    if ("string" == typeof t2) return this._setFocus(t2, e2);
    if (this._assertOpen(), this._isSingleFrameModeEnabled()) throw new Error("'setFocus()' is unavailable in singleFrameMode.");
    if (!t2) return;
    const i2 = this.getCapabilities(), r3 = i2.focusMode, n3 = i2.focusDistance;
    if (!r3) throw Error("Not supported.");
    if ("string" != typeof t2.mode) throw Error("Invalid focus mode.");
    const s3 = t2.mode.toLowerCase();
    if (!r3.includes(s3)) throw Error("Unsupported focus mode.");
    if ("manual" !== s3) return this._focusParameters._focusArea = null, await this._videoTrack.applyConstraints({ advanced: [{ focusMode: s3 }] });
    if (!n3) throw Error("Manual focus unsupported.");
    if (t2.hasOwnProperty("distance")) {
      let e3 = t2.distance;
      return e3 < n3.min ? e3 = n3.min : e3 > n3.max && (e3 = n3.max), e3 = M(e3, n3.min, n3.step, n3.max), this._focusParameters._focusArea = null, await this._videoTrack.applyConstraints({ advanced: [{ focusMode: s3, focusDistance: e3 }] });
    }
    if (!t2.area) throw new Error("'distance' or 'area' should be specified in 'manual' mode.");
    {
      const e3 = t2.area.centerPoint;
      let i3 = t2.area.width, r4 = t2.area.height;
      if (!i3 || !r4) {
        const t3 = this._video.videoWidth, e4 = this._video.videoHeight;
        i3 || (i3 = 2 * Math.round(Math.min(t3, e4) / this._focusParameters.defaultFocusAreaSizeRatio / 2) + "px"), r4 || (r4 = 2 * Math.round(Math.min(t3, e4) / this._focusParameters.defaultFocusAreaSizeRatio / 2) + "px");
      }
      this._focusParameters._focusArea = { centerPoint: { x: e3.x, y: e3.y }, width: i3, height: r4 }, await this._setLocalFocus(e3, i3, r4);
    }
  }
  getFocus() {
    if (this._assertOpen(), this._isSingleFrameModeEnabled()) throw new Error("'_getHardwareScale()' is unavailable in singleFrameMode.");
    if (!this._videoTrack) return null;
    const t2 = this._videoTrack.getSettings().focusMode;
    return t2 ? "continuous" === t2 ? { mode: t2 } : { mode: t2, distance: this._videoTrack.getSettings().focusDistance } : null;
  }
  getFocusSettings() {
    if (this._assertOpen(), this._isSingleFrameModeEnabled()) throw new Error("'_getHardwareScale()' is unavailable in singleFrameMode.");
    if (!this._videoTrack) return null;
    const t2 = this._videoTrack.getSettings(), e2 = t2.focusMode;
    return e2 ? "manual" === e2 ? this._focusParameters._focusArea ? { mode: "manual", area: JSON.parse(JSON.stringify(this._focusParameters._focusArea)) } : { mode: "manual", distance: t2.focusDistance } : { mode: e2 } : null;
  }
  async _setFocusAndGetContract(t2, e2) {
    const i2 = (t3) => {
      if (!this._bOpen || !this._videoTrack || this.video.paused || t3.focusTaskId != this._focusParameters.curFocusTaskId) {
        this._bOpen && this._videoTrack && !this.video.paused || (this._focusParameters.isDoingFocus = 0);
        const e3 = new Error(`Focus task ${t3.focusTaskId} canceled.`);
        throw e3.name = "DeprecatedTaskError", e3;
      }
      1 === this._focusParameters.isDoingFocus && Date.now() - t3.timeStart > this._focusParameters.focusCancelableTime && (this._focusParameters.isDoingFocus = -1);
    };
    let r3;
    e2 = M(e2, this._focusParameters.fds.min, this._focusParameters.fds.step, this._focusParameters.fds.max), await this._videoTrack.applyConstraints({ advanced: [{ focusMode: "manual", focusDistance: e2 }] }), i2(t2), r3 = null == this._focusParameters.oldDistance ? this._focusParameters.kTimeout * Math.max(Math.abs(1 / this._focusParameters.fds.min - 1 / e2), Math.abs(1 / this._focusParameters.fds.max - 1 / e2)) + this._focusParameters.minTimeout : this._focusParameters.kTimeout * Math.abs(1 / this._focusParameters.oldDistance - 1 / e2) + this._focusParameters.minTimeout, this._focusParameters.oldDistance = e2, await new Promise((t3) => {
      setTimeout(t3, r3);
    }), i2(t2);
    let n3 = t2.focusL - t2.focusW / 2, s3 = t2.focusT - t2.focusH / 2, o3 = t2.focusW, a3 = t2.focusH;
    if (n3 >= this.video.videoWidth || s3 >= this.video.videoHeight) throw new Error("Invalid area.");
    n3 + o3 > this.video.videoWidth && (o3 = this.video.videoWidth - n3), s3 + a3 > this.video.videoHeight && (a3 = this.video.videoHeight - s3);
    const h3 = this._getImageData(this.video, this.video.videoWidth, this.video.videoHeight, { sx: n3, sy: s3, sWidth: o3, sHeight: a3, dWidth: o3, dHeight: a3 }, null, { pixelFormat: D.RGBA });
    if (!h3) return this._setFocusAndGetContract(t2, e2);
    const l3 = h3.data;
    let c3 = 0;
    for (let t3 = 0, e3 = l3.length - 8; t3 < e3; ++t3) {
      let e4 = l3[t3] - l3[t3 + 8];
      ++t3;
      let i3 = l3[t3] - l3[t3 + 8];
      ++t3;
      let r4 = l3[t3] - l3[t3 + 8];
      ++t3, c3 += e4 * e4 + i3 * i3 + r4 * r4;
    }
    return -c3;
  }
  async _doFocusDetail(t2, e2, i2, r3, n3, s3, o3) {
    let a3;
    if (e2 = M(e2, this._focusParameters.fds.min, this._focusParameters.fds.step, this._focusParameters.fds.max), r3 = M(r3, this._focusParameters.fds.min, this._focusParameters.fds.step, this._focusParameters.fds.max), s3 ? s3 = M(s3, this._focusParameters.fds.min, this._focusParameters.fds.step, this._focusParameters.fds.max) : (s3 = M(Math.sqrt((e2 || this._focusParameters.fds.step) * (r3 || this._focusParameters.fds.step)), this._focusParameters.fds.min, this._focusParameters.fds.step, this._focusParameters.fds.max), o3 = await this._setFocusAndGetContract(t2, s3)), o3 <= i2 && o3 <= n3 ? a3 = 3 : i2 < n3 && i2 < o3 ? a3 = 1 : n3 < i2 && n3 < o3 && (a3 = 2), (r3 - e2) / 2 <= this._focusParameters.fds.step) return 3 === a3 || (1 === a3 ? await this._videoTrack.applyConstraints({ advanced: [{ focusMode: "manual", focusDistance: e2 }] }) : 2 === a3 && await this._videoTrack.applyConstraints({ advanced: [{ focusMode: "manual", focusDistance: r3 }] })), true;
    if (1 === a3) return await this._doFocusDetail(t2, e2, i2, s3, o3);
    if (2 === a3) return await this._doFocusDetail(t2, s3, o3, r3, n3);
    if (3 !== a3) return i2 = await this._setFocusAndGetContract(t2, e2), n3 = await this._setFocusAndGetContract(t2, r3), await this._doFocusDetail(t2, e2, i2, r3, n3);
    let h3 = M(Math.sqrt((e2 || this._focusParameters.fds.step) * (s3 || this._focusParameters.fds.step)), this._focusParameters.fds.min, this._focusParameters.fds.step, this._focusParameters.fds.max), l3 = M(Math.sqrt((r3 || this._focusParameters.fds.step) * (s3 || this._focusParameters.fds.step)), this._focusParameters.fds.min, this._focusParameters.fds.step, this._focusParameters.fds.max);
    if (Math.abs(1 / this._focusParameters.oldDistance - 1 / h3) <= Math.abs(1 / this._focusParameters.oldDistance - 1 / l3)) {
      let a4 = await this._setFocusAndGetContract(t2, h3);
      if (a4 < o3) return await this._doFocusDetail(t2, e2, i2, s3, o3, h3, a4);
      if (a4 == o3) return await this._doFocusDetail(t2, h3, a4, s3, o3);
      let c3 = await this._setFocusAndGetContract(t2, l3);
      if (a4 > o3 && o3 < c3) return await this._doFocusDetail(t2, h3, a4, l3, c3, s3, o3);
      if (o3 == c3) return await this._doFocusDetail(t2, s3, o3, l3, c3);
      if (o3 > c3) return await this._doFocusDetail(t2, s3, o3, r3, n3, l3, c3);
    } else {
      let a4 = await this._setFocusAndGetContract(t2, l3);
      if (o3 > a4) return await this._doFocusDetail(t2, s3, o3, r3, n3, l3, a4);
      if (o3 == a4) return await this._doFocusDetail(t2, s3, o3, l3, a4);
      let c3 = await this._setFocusAndGetContract(t2, h3);
      if (c3 > o3 && o3 < a4) return await this._doFocusDetail(t2, h3, c3, l3, a4, s3, o3);
      if (c3 == o3) return await this._doFocusDetail(t2, h3, c3, s3, o3);
      if (c3 < o3) return await this._doFocusDetail(t2, e2, i2, s3, o3, h3, c3);
    }
    return false;
  }
  async _setLocalFocus(t2, e2, i2, r3, n3) {
    if (1 == this._focusParameters.isDoingFocus) return false;
    if (!t2 || "string" != typeof t2.x || "string" != typeof t2.y) throw new Error("Invalid centerPoint.");
    if (!e2 || "string" != typeof e2) throw new Error("Invalid width.");
    if (!i2 || "string" != typeof i2) throw new Error("Invalid height.");
    const s3 = this._video.videoWidth, o3 = this._video.videoHeight;
    let a3 = 0, h3 = 0;
    if (t2.x.endsWith("px")) a3 = parseFloat(t2.x);
    else {
      if (!t2.x.endsWith("%")) throw new Error("Invalid centerPoint.");
      a3 = parseFloat(t2.x) / 100 * s3;
    }
    if (t2.y.endsWith("px")) h3 = parseFloat(t2.y);
    else {
      if (!t2.y.endsWith("%")) throw new Error("Invalid centerPoint.");
      h3 = parseFloat(t2.y) / 100 * o3;
    }
    let l3 = 0;
    if (e2.endsWith("px")) l3 = parseFloat(e2);
    else {
      if (!e2.endsWith("%")) throw new Error("Invalid width.");
      l3 = parseFloat(e2) / 100 * s3;
    }
    let c3 = 0;
    if (i2.endsWith("px")) c3 = parseFloat(i2);
    else {
      if (!i2.endsWith("%")) throw new Error("Invalid height.");
      c3 = parseFloat(i2) / 100 * o3;
    }
    if (1 !== this._softwareScale) {
      const t3 = this._softwareScale, e3 = this._scaleCenter;
      l3 /= t3, c3 /= t3, a3 = (1 - 1 / t3) * e3.x + a3 / t3, h3 = (1 - 1 / t3) * e3.y + h3 / t3;
    }
    if (!this._focusSupported) throw new Error("Manual focus unsupported.");
    if (!this._focusParameters.fds && (this._focusParameters.fds = (await this.getCapabilities()).focusDistance, !this._focusParameters.fds)) throw this._focusSupported = false, new Error("Manual focus unsupported.");
    null == this._focusParameters.kTimeout && (this._focusParameters.kTimeout = (this._focusParameters.maxTimeout - this._focusParameters.minTimeout) / (1 / this._focusParameters.fds.min - 1 / this._focusParameters.fds.max)), this._focusParameters.isDoingFocus = 1;
    const u3 = { focusL: a3, focusT: h3, focusW: l3, focusH: c3, focusTaskId: ++this._focusParameters.curFocusTaskId, timeStart: Date.now() }, d3 = async (t3, e3, i3) => {
      try {
        (null == e3 || e3 < this._focusParameters.fds.min) && (e3 = this._focusParameters.fds.min), (null == i3 || i3 > this._focusParameters.fds.max) && (i3 = this._focusParameters.fds.max), this._focusParameters.oldDistance = null;
        let r4 = M(Math.sqrt(i3 * (e3 || this._focusParameters.fds.step)), this._focusParameters.fds.min, this._focusParameters.fds.step, this._focusParameters.fds.max), n4 = M(Math.sqrt((e3 || this._focusParameters.fds.step) * r4), this._focusParameters.fds.min, this._focusParameters.fds.step, this._focusParameters.fds.max), s4 = M(Math.sqrt(r4 * i3), this._focusParameters.fds.min, this._focusParameters.fds.step, this._focusParameters.fds.max), o4 = await this._setFocusAndGetContract(t3, s4), a4 = await this._setFocusAndGetContract(t3, n4), h4 = await this._setFocusAndGetContract(t3, r4);
        if (a4 > h4 && h4 < o4) {
          const e4 = await this._doFocusDetail(t3, n4, a4, s4, o4, r4, h4);
          return this._focusParameters.isDoingFocus = 0, e4;
        }
        if (a4 < h4 && a4 < o4) {
          let i4 = await this._setFocusAndGetContract(t3, e3);
          const s5 = await this._doFocusDetail(t3, e3, i4, r4, h4, n4, a4);
          return this._focusParameters.isDoingFocus = 0, s5;
        }
        if (h4 > o4 && a4 > o4) {
          let e4 = await this._setFocusAndGetContract(t3, i3);
          const n5 = await this._doFocusDetail(t3, r4, h4, i3, e4, s4, o4);
          return this._focusParameters.isDoingFocus = 0, n5;
        }
        if (a4 == h4 && h4 < o4) {
          const e4 = await this._doFocusDetail(t3, n4, a4, r4, h4);
          return this._focusParameters.isDoingFocus = 0, e4;
        }
        if (h4 == o4 && a4 > h4) {
          const e4 = await this._doFocusDetail(t3, r4, h4, s4, o4);
          return this._focusParameters.isDoingFocus = 0, e4;
        }
        return d3(t3, e3, i3);
      } catch (t4) {
        if ("DeprecatedTaskError" !== t4.name) throw t4;
      }
    };
    return d3(u3, r3, n3);
  }
  async enableTapToFocus() {
    if (this._assertOpen(), this._isSingleFrameModeEnabled()) throw new Error("'enableTapToFocus()' is unavailable in singleFrameMode.");
    if (!this._videoTrack) throw new Error("Video is not playing.");
    if (!this._focusSupported) throw new Error("Tapping to focus unsupported.");
    if (!this._focusParameters.fds && (this._focusParameters.fds = (await this.getCapabilities()).focusDistance, !this._focusParameters.fds)) throw this._focusSupported = false, this._tapFocusEnabled = false, new Error("Tapping to focus unsupported.");
    this._tapFocusEnabled = true;
  }
  disableTapToFocus() {
    this._tapFocusEnabled = false;
  }
  isTapToFocusEnabled() {
    return this._tapFocusEnabled;
  }
  _updateVideoContainerStyle() {
    if (!this._video) return;
    if (this._isSingleFrameModeEnabled()) return;
    const t2 = this._getSoftwareScale(), e2 = this._videoContainer;
    if ("contain" === this.videoFit && t2 > 1) {
      const t3 = this._video.videoWidth, i2 = this._video.videoHeight, r3 = window.getComputedStyle(this._elContainer), n3 = parseFloat(r3.width), s3 = parseFloat(r3.height), o3 = t3 / i2;
      if (n3 / s3 < o3) {
        let t4 = n3 / o3;
        e2.style.left = "0", e2.style.top = (s3 - t4) / 2 / s3 * 100 + "%", e2.style.width = "100%", e2.style.height = t4 / s3 * 100 + "%";
      } else {
        let t4 = s3 * o3;
        e2.style.left = (n3 - t4) / 2 / n3 * 100 + "%", e2.style.top = "0", e2.style.width = t4 / n3 * 100 + "%", e2.style.height = "100%";
      }
    } else e2.style.left = "0", e2.style.top = "0", e2.style.width = "100%", e2.style.height = "100%";
  }
  _scaleVideo(t2, e2) {
    if (this._video && !this._isSingleFrameModeEnabled()) {
      if (t2 < 1) throw new RangeError("Invalid scale value.");
      if (e2 && this._setScaleCenter(e2), 1 === t2) this._video.style.transform = "";
      else {
        const e3 = this.getVideoFit(), i2 = this._video.videoWidth, r3 = this._video.videoHeight, n3 = window.getComputedStyle(this._elContainer), s3 = parseFloat(n3.width), o3 = parseFloat(n3.height), a3 = s3 / o3, h3 = i2 / r3;
        let l3 = 1;
        "contain" === e3 ? l3 = a3 < h3 ? s3 / (i2 / t2) : o3 / (r3 / t2) : "cover" === e3 && (l3 = h3 > a3 ? o3 / (i2 / t2) : s3 / (r3 / t2));
        const c3 = l3 * (1 - 1 / t2) * (i2 / 2 - this._scaleCenter.x), u3 = l3 * (1 - 1 / t2) * (r3 / 2 - this._scaleCenter.y);
        this._video.style.transform = `translate(${c3}px, ${u3}px) scale(${t2})`;
      }
      this._updateVideoContainerStyle();
    }
  }
  getFrameSize(t2, e2, i2, r3) {
    if (!t2 || !e2) return null;
    let n3, s3, o3, a3, h3 = t2, l3 = e2;
    const c3 = { regionLeft: 0, regionTop: 0, regionRight: h3, regionBottom: l3, regionMeasuredByPercentage: false };
    i2 ? (i2.regionMeasuredByPercentage ? (c3.regionLeft = i2.regionLeft * h3 / 100, c3.regionTop = i2.regionTop * l3 / 100, c3.regionRight = i2.regionRight * h3 / 100, c3.regionBottom = i2.regionBottom * l3 / 100) : (c3.regionLeft = i2.regionLeft, c3.regionTop = i2.regionTop, c3.regionRight = i2.regionRight, c3.regionBottom = i2.regionBottom), n3 = Math.round(c3.regionLeft), s3 = Math.round(c3.regionTop), h3 = Math.round(c3.regionRight - c3.regionLeft), l3 = Math.round(c3.regionBottom - c3.regionTop)) : (n3 = 0, s3 = 0, h3 = Math.round(h3), l3 = Math.round(l3));
    const u3 = Math.max(h3, l3);
    if (r3 && r3 > 0 && u3 > r3) {
      const t3 = r3 / u3;
      h3 > l3 ? (o3 = r3, a3 = Math.round(l3 * t3)) : (o3 = Math.round(h3 * t3), a3 = r3);
    } else o3 = h3, a3 = l3;
    return o3 <= 0 || a3 <= 0 ? null : { sx: n3, sy: s3, sWidth: h3, sHeight: l3, dWidth: o3, dHeight: a3 };
  }
  getFrame() {
    if (this._assertOpen(), this._isSingleFrameModeEnabled()) throw new Error("'getFrame()' is unavailable in singleFrameMode.");
    return this._getVideoData();
  }
  getImage() {
    return this.getFrame();
  }
  _drawImage(t2, e2, i2, r3, n3, s3, o3) {
    if (this.isDisposed && this.disposed) throw Error("The 'CameraEnhancer' instance has been disposed.");
    if (!i2 || !r3) return null;
    if (e2 instanceof HTMLVideoElement && 4 !== e2.readyState || e2 instanceof HTMLImageElement && !e2.complete) throw new Error("The source is not loaded.");
    let a3;
    _I._onLog && (a3 = Date.now(), _I._onLog("DCE: _drawImage(), START: " + a3));
    let h3 = 0, l3 = 0, c3 = i2, u3 = r3, d3 = 0, f3 = 0, g3 = i2, p3 = r3;
    n3 && (n3.sx && (h3 = Math.round(n3.sx)), n3.sy && (l3 = Math.round(n3.sy)), n3.sWidth && (c3 = Math.round(n3.sWidth)), n3.sHeight && (u3 = Math.round(n3.sHeight)), n3.dx && (d3 = Math.round(n3.dx)), n3.dy && (f3 = Math.round(n3.dy)), n3.dWidth && (g3 = Math.round(n3.dWidth)), n3.dHeight && (p3 = Math.round(n3.dHeight)));
    let m3 = D.RGBA;
    o3 && o3.pixelFormat && (m3 = o3.pixelFormat);
    const v3 = t2;
    if (!o3 || !o3.bUseWebGL) {
      _I._onLog && _I._onLog("DCE: _drawImage() in context2d."), v3.ctx2d || (v3.ctx2d = v3.getContext("2d", { willReadFrequently: true }));
      const t3 = v3.ctx2d;
      if (!t3) throw new Error("Unable to get 'CanvasRenderingContext2D' from canvas.");
      return (v3.width < d3 + g3 || v3.height < f3 + p3) && (v3.width = d3 + g3, v3.height = f3 + p3), t3.drawImage(e2, h3, l3, c3, u3, d3, f3, g3, p3), _I._onLog && _I._onLog("DCE: _drawImage() in context2d end. Costs: " + (Date.now() - a3)), { context: t3, pixelFormat: D.RGBA, _bUseWebGL: false };
    }
    _I._onLog && _I._onLog("DCE: _drawImage() in WebGL.");
    try {
      (v3.width < d3 + g3 || v3.height < f3 + p3) && (v3.width = d3 + g3, v3.height = f3 + p3, v3.ctxWebGL && v3.ctxWebGL.viewport(0, 0, d3 + g3, f3 + p3));
      const t3 = v3.ctxWebGL || v3.getContext("webgl", { antialias: false }) || v3.getContext("experimental-webgl", { antialias: false });
      if (!t3) {
        _I._onLog && _I._onLog("DCE: WebGL unavailable.");
        const t4 = new Error("WebGL error: unable to initialize WebGL. Your browser or machine may not support it.");
        throw t4.name = "WebGLError", t4;
      }
      if (!v3.ctxWebGL || m3 !== this.shaderPixelFormat) {
        v3.ctxWebGL = t3;
        const e3 = (t4) => {
          const e4 = t4.createBuffer();
          t4.bindBuffer(t4.ARRAY_BUFFER, e4);
          t4.bufferData(t4.ARRAY_BUFFER, new Float32Array([0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1]), t4.STATIC_DRAW);
          const i4 = t4.createBuffer();
          t4.bindBuffer(t4.ARRAY_BUFFER, i4);
          return t4.bufferData(t4.ARRAY_BUFFER, new Float32Array([0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1]), t4.STATIC_DRAW), { positions: e4, texCoords: i4 };
        }, i3 = (t4) => {
          const e4 = t4.createTexture();
          return t4.bindTexture(t4.TEXTURE_2D, e4), t4.texParameteri(t4.TEXTURE_2D, t4.TEXTURE_MAG_FILTER, t4.LINEAR), t4.texParameteri(t4.TEXTURE_2D, t4.TEXTURE_MIN_FILTER, t4.LINEAR), t4.texParameteri(t4.TEXTURE_2D, t4.TEXTURE_WRAP_S, t4.CLAMP_TO_EDGE), t4.texParameteri(t4.TEXTURE_2D, t4.TEXTURE_WRAP_T, t4.CLAMP_TO_EDGE), e4;
        }, r4 = (t4, e4) => {
          const i4 = t4.createProgram();
          if (e4.forEach((e5) => t4.attachShader(i4, e5)), t4.linkProgram(i4), !t4.getProgramParameter(i4, t4.LINK_STATUS)) {
            const e5 = new Error(`An error occured linking the program: ${t4.getProgramInfoLog(i4)}.`);
            throw e5.name = "WebGLError", e5;
          }
          return t4.useProgram(i4), i4;
        }, n5 = (t4, e4, i4) => {
          const r5 = t4.createShader(e4);
          if (t4.shaderSource(r5, i4), t4.compileShader(r5), !t4.getShaderParameter(r5, t4.COMPILE_STATUS)) {
            const e5 = new Error(`An error occured compiling the shader: ${t4.getShaderInfoLog(r5)}.`);
            throw e5.name = "WebGLError", e5;
          }
          return r5;
        }, s4 = "\n                        attribute vec2 a_position;\n                        attribute vec2 a_texCoord;\n    \n                        uniform mat3 u_matrix;\n                        uniform mat3 u_textureMatrix;\n    \n                        varying vec2 v_texCoord;\n                        void main(void) {\n                        gl_Position = vec4((u_matrix * vec3(a_position, 1)).xy, 0, 1.0);\n                        v_texCoord = vec4((u_textureMatrix * vec3(a_texCoord, 1)).xy, 0, 1.0).xy;\n                        }\n                    ";
        let o5 = "rgb";
        ["rgba", "rbga", "grba", "gbra", "brga", "bgra"].includes(m3) && (o5 = m3.slice(0, 3));
        const a4 = `
                        precision mediump float;
                        varying vec2 v_texCoord;
                        uniform sampler2D u_image;
                        uniform float uColorFactor;
    
                        void main() {
                            vec4 sample = texture2D(u_image, v_texCoord);
                            float grey = 0.21 * sample.r + 0.71 * sample.g + 0.07 * sample.b;
                            gl_FragColor = vec4(sample.${o5} * (1.0 - uColorFactor) + (grey * uColorFactor), sample.a);
                        }
                    `, h4 = n5(t3, t3.VERTEX_SHADER, s4), l4 = r4(t3, [h4, n5(t3, t3.FRAGMENT_SHADER, a4)]);
        this._webGLProgramInfo = { program: l4, attribLocations: { vertexPosition: t3.getAttribLocation(l4, "a_position"), texPosition: t3.getAttribLocation(l4, "a_texCoord") }, uniformLocations: { uSampler: t3.getUniformLocation(l4, "u_image"), uColorFactor: t3.getUniformLocation(l4, "uColorFactor"), uMatrix: t3.getUniformLocation(l4, "u_matrix"), uTextureMatrix: t3.getUniformLocation(l4, "u_textureMatrix") } }, this._webGLBuffers = e3(t3), this._webGLTexture = i3(t3), this.shaderPixelFormat = m3;
      }
      const n4 = (t4, e3, i3) => {
        t4.bindBuffer(t4.ARRAY_BUFFER, e3), t4.enableVertexAttribArray(i3), t4.vertexAttribPointer(i3, 2, t4.FLOAT, false, 0, 0);
      }, o4 = (t4, e3, i3) => {
        const r4 = t4.RGBA, n5 = t4.RGBA, s4 = t4.UNSIGNED_BYTE;
        t4.bindTexture(t4.TEXTURE_2D, e3), t4.texImage2D(t4.TEXTURE_2D, 0, r4, n5, s4, i3);
      }, _3 = (t4, e3, s4, o5) => {
        t4.clearColor(0, 0, 0, 1), t4.clearDepth(1), t4.enable(t4.DEPTH_TEST), t4.depthFunc(t4.LEQUAL), t4.clear(t4.COLOR_BUFFER_BIT | t4.DEPTH_BUFFER_BIT), n4(t4, s4.positions, e3.attribLocations.vertexPosition), n4(t4, s4.texCoords, e3.attribLocations.texPosition), t4.activeTexture(t4.TEXTURE0), t4.bindTexture(t4.TEXTURE_2D, o5), t4.uniform1i(e3.uniformLocations.uSampler, 0), t4.uniform1f(e3.uniformLocations.uColorFactor, [D.GREY, D.GREY32].includes(m3) ? 1 : 0);
        let a4, v4, _4 = E.translate(E.identity(), -1, -1);
        _4 = E.scale(_4, 2, 2), _4 = E.scale(_4, 1 / t4.canvas.width, 1 / t4.canvas.height), a4 = E.translate(_4, d3, f3), a4 = E.scale(a4, g3, p3), t4.uniformMatrix3fv(e3.uniformLocations.uMatrix, false, a4), v4 = E.translate(E.identity(), h3 / i2, l3 / r3), v4 = E.scale(v4, c3 / i2, u3 / r3), t4.uniformMatrix3fv(e3.uniformLocations.uTextureMatrix, false, v4), t4.drawArrays(t4.TRIANGLES, 0, 6);
      };
      let y3;
      if (o4(t3, this._webGLTexture, e2), _3(t3, this._webGLProgramInfo, this._webGLBuffers, this._webGLTexture), s3) {
        if (s3.length < g3 * p3 * 4) throw new Error("Unexpected size of the 'bufferContainer'.");
        y3 = s3;
      } else y3 = new Uint8Array(g3 * p3 * 4);
      if (t3.readPixels(d3, f3, g3, p3, t3.RGBA, t3.UNSIGNED_BYTE, y3), 255 !== y3[3]) {
        _I._onLog && _I._onLog("DCE: WebGL drawing incorrect."), this._bWebGLSupported = false;
        const t4 = new Error("WebGL error: incorrect WebGL drawing.");
        throw t4.name = "WebGLError", t4;
      }
      return _I._onLog && _I._onLog("DCE: _drawImage() in WebGL end. Costs: " + (Date.now() - a3)), { context: t3, pixelFormat: m3 === D.GREY ? D.GREY32 : m3, _bUseWebGL: true };
    } catch (t3) {
      throw this._bWebGLSupported = false, t3.name = "WebGLError", t3;
    }
  }
  _readCvsData(t2, e2, i2) {
    let r3, n3 = 0, s3 = 0, o3 = t2.canvas.width, a3 = t2.canvas.height;
    if (e2 && (e2.x && (n3 = e2.x), e2.y && (s3 = e2.y), e2.width && (o3 = e2.width), e2.height && (a3 = e2.height)), t2 instanceof WebGLRenderingContext) {
      const e3 = t2;
      if (i2) {
        if (i2.length < o3 * a3 * 4) throw new Error("Unexpected size of the 'bufferContainer'.");
        e3.readPixels(n3, s3, o3, a3, e3.RGBA, e3.UNSIGNED_BYTE, i2), r3 = new Uint8Array(i2.buffer, 0, o3 * a3 * 4);
      } else r3 = new Uint8Array(o3 * a3 * 4), e3.readPixels(n3, s3, o3, a3, e3.RGBA, e3.UNSIGNED_BYTE, r3);
    } else if (t2 instanceof CanvasRenderingContext2D) {
      let e3;
      if (e3 = t2.getImageData(n3, s3, o3, a3), r3 = new Uint8Array(e3.data.buffer), i2) {
        if (i2.length < r3.length) throw new Error("Unexpected size of the 'bufferContainer'.");
        i2.set(r3);
      }
    }
    return r3;
  }
  _transformPixelFormat(t2, e2, i2, r3) {
    let n3, s3;
    if (_I._onLog && (n3 = Date.now(), _I._onLog("DCE: _transformPixelFormat(), START: " + n3)), e2 === i2) return _I._onLog && _I._onLog("DCE: _transformPixelFormat() end. Costs: " + (Date.now() - n3)), r3 ? new Uint8Array(t2) : t2;
    const o3 = [D.RGBA, D.RBGA, D.GRBA, D.GBRA, D.BRGA, D.BGRA];
    if (o3.includes(e2)) if (i2 === D.GREY) {
      s3 = new Uint8Array(t2.length / 4);
      for (let e3 = 0; e3 < t2.length; e3 += 4) {
        const i3 = 0.21 * t2[e3] + 0.71 * t2[e3 + 1] + 0.07 * t2[e3 + 2];
        s3[e3 / 4] = i3;
      }
    } else if (i2 === D.GREY32) {
      s3 = r3 ? new Uint8Array(t2) : t2;
      for (let e3 = 0; e3 < t2.length; e3 += 4) {
        const i3 = 0.21 * t2[e3] + 0.71 * t2[e3 + 1] + 0.07 * t2[e3 + 2];
        s3[e3] = i3, s3[e3 + 1] = i3, s3[e3 + 2] = i3;
      }
    } else {
      if (!o3.includes(i2)) throw new Error("Unable to transform.");
      if (r3) {
        s3 = new Uint8Array(t2);
        const r4 = e2.indexOf("r"), n4 = e2.indexOf("g"), o4 = e2.indexOf("b"), a3 = i2.indexOf("r"), h3 = i2.indexOf("g"), l3 = i2.indexOf("b");
        for (let e3 = 0; e3 < t2.length; e3 += 4) s3[e3 + a3] = t2[e3 + r4], s3[e3 + h3] = t2[e3 + n4], s3[e3 + l3] = t2[e3 + o4];
      } else {
        s3 = t2;
        const r4 = e2.indexOf("r"), n4 = e2.indexOf("g"), o4 = e2.indexOf("b"), a3 = i2.indexOf("r"), h3 = i2.indexOf("g"), l3 = i2.indexOf("b");
        for (let e3 = 0; e3 < t2.length; e3 += 4) {
          let i3 = [t2[e3], t2[e3 + 1], t2[e3 + 2]];
          s3[e3 + a3] = i3[r4], s3[e3 + h3] = i3[n4], s3[e3 + l3] = i3[o4];
        }
      }
    }
    else if (e2 === D.GREY) {
      if (i2 !== D.GREY32) throw new Error("Unable to transform.");
      s3 = new Uint8Array(4 * t2.length);
      for (let e3 = 0; e3 < t2.length; e3++) s3[4 * e3] = t2[e3], s3[4 * e3 + 1] = t2[e3], s3[4 * e3 + 2] = t2[e3], s3[4 * e3 + 3] = 255;
    } else {
      if (e2 !== D.GREY32) throw new Error("Unable to transform.");
      if (i2 !== D.GREY) throw new Error("Unable to transform.");
      s3 = new Uint8Array(t2.length / 4);
      for (let e3 = 0; e3 < t2.length; e3 += 4) s3[e3 / 4] = t2[e3];
    }
    return _I._onLog && _I._onLog("DCE: _transformPixelFormat() end. Costs: " + (Date.now() - n3)), s3;
  }
  _getImageData(t2, e2, i2, r3, n3, s3) {
    if (this.isDisposed && this.disposed) throw Error("The 'CameraEnhancer' instance has been disposed.");
    if (!e2 || !i2) return null;
    if (r3.sx > e2 || r3.sy > i2 || r3.sx + r3.sWidth > e2 || r3.sy + r3.sHeight > i2) throw new Error("Invalid position.");
    if (t2 instanceof HTMLVideoElement && 4 !== t2.readyState || t2 instanceof HTMLImageElement && !t2.complete) throw new Error("The source is not loaded.");
    let o3;
    _I._onLog && (o3 = Date.now(), _I._onLog("DCE: _getImageData(), START: " + o3));
    const a3 = Math.round(r3.sx), h3 = Math.round(r3.sy), l3 = Math.round(r3.sWidth), c3 = Math.round(r3.sHeight), u3 = Math.round(r3.dWidth), d3 = Math.round(r3.dHeight);
    let f3 = D.RGBA;
    s3 && s3.pixelFormat && (f3 = s3.pixelFormat);
    let g3, p3, m3, v3 = this._bWebGLSupported;
    s3 && 0 == s3.bUseWebGL && (v3 = false), v3 ? (this._reusedWebGLCvs || (this._reusedWebGLCvs = document.createElement("canvas")), g3 = this._reusedWebGLCvs) : (this._reusedCvs || (this._reusedCvs = document.createElement("canvas")), g3 = this._reusedCvs);
    try {
      if (v3) if (_I._onLog && _I._onLog("DCE: _getImageData() in WebGL."), n3) if (f3 === D.GREY) {
        if (m3 = new Uint8Array(u3 * d3 * 4), p3 = this._drawImage(g3, t2, e2, i2, { sx: a3, sy: h3, sWidth: l3, sHeight: c3, dWidth: u3, dHeight: d3 }, m3, { pixelFormat: f3, bUseWebGL: v3 }), m3 = this._transformPixelFormat(m3, p3.pixelFormat, f3), n3) {
          if (n3.length < m3.length) throw new Error("Unexpected size of the 'bufferContainer'.");
          n3.set(m3);
        }
      } else p3 = this._drawImage(g3, t2, e2, i2, { sx: a3, sy: h3, sWidth: l3, sHeight: c3, dWidth: u3, dHeight: d3 }, n3, { pixelFormat: f3, bUseWebGL: v3 }), m3 = new Uint8Array(n3.buffer, 0, u3 * d3 * 4), m3 = this._transformPixelFormat(m3, p3.pixelFormat, f3);
      else f3 === D.GREY ? ((!this._tempDataContainer || this._tempDataContainer.length < u3 * d3 * 4) && (this._tempDataContainer = new Uint8Array(u3 * d3 * 4)), m3 = new Uint8Array(this._tempDataContainer.buffer, 0, u3 * d3 * 4)) : m3 = new Uint8Array(u3 * d3 * 4), p3 = this._drawImage(g3, t2, e2, i2, { sx: a3, sy: h3, sWidth: l3, sHeight: c3, dWidth: u3, dHeight: d3 }, m3, { pixelFormat: f3, bUseWebGL: v3 }), m3 = this._transformPixelFormat(m3, p3.pixelFormat, f3);
      else if (_I._onLog && _I._onLog("DCE: _getImageData() in context2d."), p3 = this._drawImage(g3, t2, e2, i2, { sx: a3, sy: h3, sWidth: l3, sHeight: c3, dWidth: u3, dHeight: d3 }, null, { pixelFormat: D.RGBA, bUseWebGL: v3 }), m3 = this._readCvsData(p3.context, { width: u3, height: d3 }, null), m3 = this._transformPixelFormat(m3, p3.pixelFormat, f3), n3) {
        if (n3.length < m3.length) throw new Error("Unexpected size of the 'bufferContainer'.");
        n3.set(m3);
      }
    } catch (r4) {
      if ("WebGLError" === r4.name) return _I._onLog && _I._onLog("DCE: _getImageData() in WebGL failed, try again in context2d."), this.forceLoseContext(), this._bWebGLSupported = false, this._getImageData(t2, e2, i2, { sx: a3, sy: h3, sWidth: l3, sHeight: c3, dWidth: u3, dHeight: d3 }, n3, s3);
      throw r4;
    }
    return _I._onLog && _I._onLog("DCE: _getImageData() end. Costs: " + (Date.now() - o3)), { data: m3, pixelFormat: f3, _bUseWebGL: p3._bUseWebGL };
  }
  forceLoseContext() {
    if (!this._reusedWebGLCvs) return;
    const t2 = this._reusedWebGLCvs.ctxWebGL;
    t2 && !t2.isContextLost() && t2.getExtension("WEBGL_lose_context") && t2.getExtension("WEBGL_lose_context").loseContext(), this._webGLTexture = null, this._webGLProgramInfo = null, this._webGLBuffers = null, this._reusedWebGLCvs = null;
  }
  _getVideoData(t2, e2) {
    if (this.isDisposed && this.disposed) throw Error("The 'CameraEnhancer' instance has been disposed.");
    if (this._assertOpen(), this._isSingleFrameModeEnabled()) throw new Error("'_getVideoData()' is unavailable in singleFrameMode.");
    if (!this._video || 4 !== this._video.readyState) return null;
    const i2 = Date.now();
    _I._onLog && _I._onLog("DCE: _getVideoData() START: " + i2);
    let r3 = this._scanRegion;
    e2 && e2.hasOwnProperty("region") && (r3 = e2.region);
    let n3 = this.mapPixelFormatString_Enum.get(this.framePixelFormat.toLowerCase());
    e2 && e2.pixelFormat && (n3 = this.mapPixelFormatString_Enum.get(e2.pixelFormat.toLowerCase()));
    let s3 = this._softwareScale;
    e2 && e2.scale && (s3 = e2.scale);
    const o3 = this._video.videoWidth, a3 = this._video.videoHeight;
    let h3 = this._scaleCenter;
    if (e2 && e2.scaleCenter) {
      if ("string" != typeof e2.scaleCenter.x || "string" != typeof e2.scaleCenter.y) throw new Error("Invalid scale center.");
      let t3 = 0, i3 = 0;
      if (e2.scaleCenter.x.endsWith("px")) t3 = parseFloat(e2.scaleCenter.x);
      else {
        if (!e2.scaleCenter.x.endsWith("%")) throw new Error("Invalid scale center.");
        t3 = parseFloat(e2.scaleCenter.x) / 100 * o3;
      }
      if (e2.scaleCenter.y.endsWith("px")) i3 = parseFloat(e2.scaleCenter.y);
      else {
        if (!e2.scaleCenter.y.endsWith("%")) throw new Error("Invalid scale center.");
        i3 = parseFloat(e2.scaleCenter.y) / 100 * a3;
      }
      h3.x = Math.round(t3), h3.y = Math.round(i3);
    }
    if (0 === o3 || 0 === a3) return null;
    const l3 = this.getFrameSize(o3, a3, r3, this.maxCvsSideLength);
    if (!l3) return null;
    let c3 = true;
    o3 === l3.sWidth && a3 === l3.sHeight && (c3 = false);
    const u3 = { data: null, region: r3 ? JSON.parse(JSON.stringify(r3)) : null, sx: l3.sx, sy: l3.sy, width: l3.dWidth, height: l3.dHeight, colorMode: null, pixelFormat: null, timeSpent: null, timeStamp: null, isCropped: c3, toCanvas: this._toCanvas, _sWidth: l3.sWidth, _sHeight: l3.sHeight, _bUseWebGL: null };
    1 !== s3 && (l3.sWidth = Math.round(l3.sWidth / s3), l3.sHeight = Math.round(l3.sHeight / s3), l3.sx = Math.round((1 - 1 / s3) * h3.x + l3.sx / s3), l3.sy = Math.round((1 - 1 / s3) * h3.y + l3.sy / s3));
    const d3 = this._getImageData(this._video, o3, a3, l3, t2, { pixelFormat: n3 });
    if (!d3) return null;
    const f3 = Date.now();
    if (_I._onLog && _I._onLog("DCE: _getVideoData() END: " + f3), u3.data = d3.data, u3.pixelFormat = u3.colorMode = d3.pixelFormat, u3._bUseWebGL = d3._bUseWebGL, u3.timeSpent = f3 - i2, u3.timeStamp = f3, d3.pixelFormat === D.GREY) u3.stride = u3.width;
    else u3.stride = 4 * u3.width;
    return u3;
  }
  getCurrentRegion() {
    let t2 = null;
    if (this._scanRegion) t2 = this._scanRegion;
    else if (this.croppingRegions) {
      if (this._croppingRegionIndex >= this.croppingRegions.length || this._croppingRegionIndex < 0) throw new Error("The 'croppingRegionIndex' is out of bounds.");
      t2 = this.croppingRegions[this._croppingRegionIndex], this.bIncreaseRegionIndexAuto && ++this._croppingRegionIndex >= this.croppingRegions.length && (this._croppingRegionIndex = 0);
    }
    return t2;
  }
  _fetchingLoop(t2) {
    if (this.isDisposed && this.disposed) return;
    if (!this._bOpen || !this.isFetchingLoopStarted()) return void this.stopFetchingLoop();
    const e2 = () => {
      _I._onLog && _I._onLog("DCE: start fetching a frame into buffer: " + Date.now());
      const t3 = this.getCurrentRegion();
      let e3 = this._getVideoData(null, { region: t3 });
      if (!e3) return void (_I._onLog && _I._onLog("DCE: get a invalid frame, abandon it: " + Date.now()));
      for (; this._frameQueue && this._frameQueue.length >= this.maxNumberOfFramesInBuffer; ) this._frameQueue.shift();
      this._frameQueue.push(e3), _I._onLog && _I._onLog("DCE: finish fetching a frame into buffer: " + Date.now());
      const i3 = this.mapCameraEvents.get("frameaddedtobuffer");
      for (let t4 of i3) t4 && setTimeout(() => {
        this.isDisposed && this.disposed || t4.apply(this);
      }, 0);
    }, i2 = () => {
      this.isDisposed && this.disposed || (this._frameLoopTimeoutId2 && clearTimeout(this._frameLoopTimeoutId2), this.refreshInterval <= 0 || (this._frameLoopTimeoutId2 = setTimeout(() => {
        this.isDisposed && this.disposed || (this._bOpen && this.isFetchingLoopStarted() ? (_I._onLog && _I._onLog("DCE: second timeout executes: " + Date.now()), e2(), i2()) : this.stopFetchingLoop());
      }, this.refreshInterval)));
    };
    t2 && (this._frameQueue.length < this.maxNumberOfFramesInBuffer ? (e2(), this.refreshInterval > 0 && i2()) : 0 === this.refreshInterval && e2()), this._frameLoopTimeoutId && clearTimeout(this._frameLoopTimeoutId), this._frameLoopTimeoutId = setTimeout(() => {
      this.isDisposed && this.disposed || this._fetchingLoop(true);
    }, this.loopInterval);
  }
  startFetchingLoop() {
    if (this.isDisposed && this.disposed) throw Error("The 'CameraEnhancer' instance has been disposed.");
    if (this._assertOpen(), this._isSingleFrameModeEnabled()) throw Error("'startFetchingLoop()' is unavailable in singleFrameMode.");
    this.isFetchingLoopStarted() || (this._bFetchingLoopStarted = true, this._recordedStates.fetchingLoopStart = true, _I._onLog && _I._onLog("DCE: start fetching loop: " + Date.now()), this._fetchingLoop(true));
  }
  isFetchingLoopStarted() {
    return this._bFetchingLoopStarted;
  }
  stopFetchingLoop() {
    this._bFetchingLoopStarted && (_I._onLog && _I._onLog("DCE: stop fetching loop: " + Date.now()), this._frameLoopTimeoutId && clearTimeout(this._frameLoopTimeoutId), this._frameQueue.length = 0, this._bFetchingLoopStarted = false, this._recordedStates.fetchingLoopStart = false);
  }
  getFrameFromBuffer(t2) {
    return this._frameQueue && this._frameQueue.length ? t2 ? t2 < this._frameQueue.length ? (this._frameLoopTimeoutId2 && clearTimeout(this._frameLoopTimeoutId2), this._frameQueue.splice(t2, 1)[0]) : void 0 : (this._frameLoopTimeoutId2 && clearTimeout(this._frameLoopTimeoutId2), this._frameQueue.pop()) : null;
  }
  clearFrameBuffer() {
    this._frameQueue && (this._frameQueue.length = 0);
  }
  _createDrawingLayerBaseCvs() {
    let t2;
    this._assertOpen();
    try {
      t2 = this._calculateCvsSize();
    } catch (t3) {
      throw t3;
    }
    let { width: e2, height: i2, objectFit: r3 } = t2;
    (e2 <= 0 || i2 <= 0) && (e2 = 2, i2 = 2);
    const n3 = document.createElement("canvas");
    if (n3.width == e2 && n3.height == i2 || (n3.width = e2, n3.height = i2), n3.style.objectFit = r3, this._cvsScanRegion) this._cvsScanRegion.after(n3);
    else if (this._cvsOriginalImage) this._cvsOriginalImage.after(n3);
    else if (this._cvsSingleFrameMode) this._cvsSingleFrameMode.after(n3);
    else {
      if (!this._videoContainer) throw new Error("Unable to find video element");
      this._videoContainer.after(n3);
    }
    return n3;
  }
  _updateDrawingLayersSize(t2) {
    let e2;
    try {
      e2 = t2 && t2.width && t2.height && t2.objectFit ? { width: t2.width, height: t2.height, objectFit: t2.objectFit } : this._calculateCvsSize();
    } catch (t3) {
      if ("Invalid content dimensions." === (t3.message || t3)) return;
      throw t3;
    }
    const { width: i2, height: r3, objectFit: n3 } = e2;
    this._drawingLayerManager.setDimensions({ width: i2, height: r3 }, { backstoreOnly: true }), this._drawingLayerManager.setObjectFit(n3);
  }
  _createDrawingLayer(t2) {
    this._layerBaseCvs || (this._layerBaseCvs = this._createDrawingLayerBaseCvs());
    const e2 = this._layerBaseCvs;
    return this._drawingLayerManager.createDrawingLayer(e2, t2);
  }
  deleteDrawingLayer(t2) {
    this._drawingLayerManager.deleteDrawingLayer(t2), this._drawingLayerManager.getDrawingLayers().length || this._layerBaseCvs && (this._layerBaseCvs.remove(), this._layerBaseCvs = null);
  }
  createDrawingLayer() {
    return this._createDrawingLayer();
  }
  getDrawingLayer(t2) {
    const e2 = this._drawingLayerManager.getDrawingLayer(t2);
    return e2 || ([1, 2, 3].includes(t2) ? this._createDrawingLayer(t2) : null);
  }
  getDrawingLayers() {
    return this._drawingLayerManager.getDrawingLayers().filter((t2) => t2.getId() >= 0);
  }
  getSelectedDrawingItems() {
    return this._drawingLayerManager.getSelectedDrawingItems();
  }
  createDrawingStyle(t2) {
    return this._drawingLayerManager.createDrawingStyle(t2);
  }
  getDrawingStyle(t2) {
    return this._drawingLayerManager.getDrawingStyle(t2);
  }
  getDrawingStyles() {
    return this._drawingLayerManager.getDrawingStyles();
  }
  updateDrawingStyle(t2, e2) {
    return this._drawingLayerManager.updateDrawingStyle(t2, e2);
  }
  clearDrawingLayers() {
    const t2 = this.getDrawingLayers();
    for (let e2 of t2) this.deleteDrawingLayer(e2.getId());
  }
  showTip(t2, e2, i2, r3, n3 = 3e3, s3 = true) {
    this._assertOpen(), this._tipArgs.x = t2, this._tipArgs.y = e2, this._tipArgs.width = i2, this._tipArgs.autoShowSuggestedTip = !!s3, this._drawingLayerOfTip || (this._drawingLayerOfTip = this._createDrawingLayer(-1)), this._tipStyleId || (this._tipStyleId = this.createDrawingStyle({ fillStyle: "#FFFFFF", paintMode: "fill", fontFamily: "Open Sans", fontSize: 40 })), this._drawingLayerOfTip.clearDrawingItems();
    const o3 = new S(r3 || "", t2, e2, i2, this._tipStyleId);
    o3._fabricObject.paddingTop = 15, o3._fabricObject.calcTextHeight = function() {
      for (var t3 = 0, e3 = 0, i3 = this._textLines.length; e3 < i3; e3++) t3 += this.getHeightOfLine(e3);
      return t3 += 2 * this.paddingTop;
    }, o3._fabricObject._getTopOffset = function() {
      return -this.height / 2 + this.getHeightOfLine(0) * (1 - 1 / this.lineHeight) / 2 + this.paddingTop;
    }, o3.setAttribute("backgroundColor", "rgba(50, 50, 52, .8)"), o3.setAttribute("lineHeight", 1.3), o3.setAttribute("textAlign", "center"), this._drawingLayerOfTip.addDrawingItem(o3), this._hideTipTimeoutId && clearTimeout(this._hideTipTimeoutId), this._tipArgs.duration = void 0 === n3 ? 3e3 : n3, this._tipArgs.duration > 0 && (this._hideTipTimeoutId = setTimeout(() => {
      this.isDisposed && this.disposed || this._hideTip();
    }, this._tipArgs.duration));
  }
  _hideTip() {
    this._drawingLayerOfTip && (this.deleteDrawingLayer(this._drawingLayerOfTip.getId()), this._drawingLayerOfTip = null, this._hideTipTimeoutId && clearTimeout(this._hideTipTimeoutId));
  }
  hideTip() {
    this._hideTip(), this._tipArgs.x = null, this._tipArgs.y = null, this._tipArgs.width = null, this._tipArgs.autoShowSuggestedTip = null;
  }
  updateTipMessage(t2) {
    if (!this._drawingLayerOfTip) throw new Error("The Tip is not showing.");
    this._drawingLayerOfTip.getDrawingItems()[0].setAttribute("text", t2), this._drawingLayerOfTip.renderAll(), this._tipArgs.duration > 0 && (this._hideTipTimeoutId && clearTimeout(this._hideTipTimeoutId), this._hideTipTimeoutId = setTimeout(() => {
      this.isDisposed && this.disposed || this._hideTip();
    }, this._tipArgs.duration));
  }
  suggestTip(t2, e2) {
    this._tipArgs.autoShowSuggestedTip && (this._drawingLayerOfTip ? this.updateTipMessage(e2) : void 0 !== this._tipArgs.x && this.showTip(this._tipArgs.x, this._tipArgs.y, this._tipArgs.width, e2, this._tipArgs.duration)), this.onTipSuggested && setTimeout(() => {
      this.isDisposed && this.disposed || this.onTipSuggested.apply(this, [t2, e2]);
    }, 0);
  }
  _createControler() {
    if (this._controler || (this._controler = new O(this)), this._controler) return this._controler;
  }
  _destroyControler() {
    this._controler = null;
  }
  setOriginalImage(t2, e2, i2) {
    if (!t2 || !e2 || !i2) throw new Error("Invalid arguments");
    this._originalImageData = { imageData: t2, width: e2, height: i2 };
    let r3 = this._cvsOriginalImage;
    r3 || (r3 = document.createElement("canvas"), r3.style.position = "absolute", r3.style.width = "100%", r3.style.height = "100%", r3.style.left = "0", r3.style.top = "0", r3.style.backgroundColor = "white", r3.style.objectFit = "contain", this._cvsOriginalImage = r3), r3.width === e2 && r3.height === i2 || (r3.width = e2, r3.height = i2);
    const n3 = r3.getContext("2d");
    n3.clearRect(0, 0, r3.width, r3.height), t2 instanceof Uint8Array || t2 instanceof Uint8ClampedArray ? (t2 instanceof Uint8Array && (t2 = new Uint8ClampedArray(t2.buffer)), n3.putImageData(new ImageData(t2, e2, i2), 0, 0)) : t2 instanceof HTMLCanvasElement && n3.drawImage(t2, 0, 0), document.body.contains(r3) && "" === r3.style.display && this._updateDrawingLayersSize({ width: e2, height: i2, objectFit: "contain" });
  }
  getOriginalImage() {
    return this._originalImageData ? Object.assign({}, this._originalImageData) : null;
  }
  async deleteOriginalImage() {
    await this.hideOriginalImage(), this._cvsOriginalImage && (this._cvsOriginalImage.remove(), this._cvsOriginalImage = null), this._originalImageData = null;
  }
  _showOriginalImageCvs() {
    this._cvsOriginalImage && "none" == this._cvsOriginalImage.style.display && (this._cvsOriginalImage.style.display = "");
  }
  _hideOriginalImageCvs() {
    this._cvsOriginalImage && (this._cvsOriginalImage.style.display = "none");
  }
  showOriginalImage() {
    if (!this._originalImageData) throw new Error("No original image is set.");
    const t2 = this._cvsOriginalImage;
    if ("" === t2.style.display && document.body.contains(t2)) return;
    const { width: e2, height: i2 } = this._originalImageData;
    if (this._updateDrawingLayersSize({ width: e2, height: i2, objectFit: "contain" }), this._bOpen && (this._video && !this._video.paused && this._video.pause(), this._bFetchingLoopStarted && (this.stopFetchingLoop(), this._recordedStates.fetchingLoopStart = true), this.ifShowScanRegionMask && this._cvsScanRegion && (this._cvsScanRegion.style.display = "none"), this.ifShowScanRegionLaser && this._divScanLight && (this._divScanLight.style.display = "none"), this._cvsViewDecorator && (this._cvsViewDecorator.style.display = "none"), this._scanRegionOverlayContainer && (this._scanRegionOverlayContainer.style.display = "none"), this._selCam && (this._selCam.parentElement.style.display = "none")), !document.body.contains(t2)) if (this._cvsSingleFrameMode) this._cvsSingleFrameMode.after(t2);
    else {
      if (!this._videoContainer) throw new Error("Unable to find video element");
      this._videoContainer.after(t2);
    }
    this._showOriginalImageCvs();
  }
  async _hideOriginalImage(t2) {
    this._originalImageData && this._cvsOriginalImage && "none" !== this._cvsOriginalImage.style.display && (this._updateDrawingLayersSize(), this._bOpen && t2 && (this._video && this._recordedStates.videoPlaying && await this.play(null, null, null, { notTriggerSingleFrameClick: true }), this._recordedStates.fetchingLoopStart && !this._isSingleFrameModeEnabled() && this.startFetchingLoop(), this.ifShowScanRegionMask && this._cvsScanRegion && this._recordedStates.maskShow && this.showScanRegionMask(), this.ifShowScanRegionLaser && this._divScanLight && this._recordedStates.laserShow && this.showScanRegionLaser(), this._cvsViewDecorator && this._recordedStates.decoratorShow && this.showViewDecorator(), this._scanRegionOverlayContainer && this._recordedStates.overlayShow && this.showScanRegionOverlays()), this._selCam && (this._selCam.parentElement.style.display = ""), this._hideOriginalImageCvs());
  }
  async hideOriginalImage() {
    return this._hideOriginalImage(true);
  }
  transformCoord(t2) {
    if (!this.isOpen()) throw new Error("Unavailable when the camera is not open.");
    if (this._isSingleFrameModeEnabled() && !this._cvsSingleFrameMode) throw new Error("No image is selected. ");
    const e2 = this._elContainer.getBoundingClientRect();
    let i2, r3, n3, s3, o3, a3 = e2.left, h3 = e2.top, l3 = a3 + window.scrollX, c3 = h3 + window.scrollY;
    this._isSingleFrameModeEnabled() ? (i2 = this._cvsSingleFrameMode.width, r3 = this._cvsSingleFrameMode.height, n3 = parseFloat(window.getComputedStyle(this._cvsSingleFrameMode).width), s3 = parseFloat(window.getComputedStyle(this._cvsSingleFrameMode).height), o3 = "contain") : (i2 = this.video.videoWidth, r3 = this.video.videoHeight, n3 = parseFloat(window.getComputedStyle(this._elContainer).width), s3 = parseFloat(window.getComputedStyle(this._elContainer).height), o3 = this.videoFit);
    const u3 = n3 / s3, d3 = i2 / r3;
    let f3, g3, p3, m3, v3 = 1;
    if ("contain" === o3) u3 < d3 ? (v3 = n3 / i2, f3 = a3 + t2.x * v3, g3 = h3 + t2.y * v3 + (s3 - r3 * v3) / 2, p3 = l3 + t2.x * v3, m3 = c3 + t2.y * v3 + (s3 - r3 * v3) / 2) : (v3 = s3 / r3, f3 = a3 + t2.x * v3 + (n3 - i2 * v3) / 2, g3 = h3 + t2.y * v3, p3 = l3 + t2.x * v3 + (n3 - i2 * v3) / 2, m3 = c3 + t2.y * v3);
    else if ("cover" === o3) if (u3 < d3) {
      v3 = s3 / r3;
      let e3 = t2.x * v3 - (i2 * v3 - n3) / 2;
      e3 = Math.max(e3, 0), e3 = Math.min(e3, n3), f3 = a3 + e3, g3 = h3 + t2.y * v3, p3 = l3 + e3, m3 = c3 + t2.y * v3;
    } else {
      v3 = n3 / i2;
      let e3 = t2.y * v3 - (r3 * v3 - s3) / 2;
      e3 = Math.max(e3, 0), e3 = Math.min(e3, s3), f3 = a3 + t2.x * v3, g3 = h3 + e3, p3 = l3 + t2.x * v3, m3 = c3 + e3;
    }
    return { clientX: f3, clientY: g3, pageX: p3, pageY: m3 };
  }
  convertToPageCoordinates(t2) {
    const e2 = this.transformCoord(t2);
    return { x: e2.pageX, y: e2.pageY };
  }
  convertToClientCoordinates(t2) {
    const e2 = this.transformCoord(t2);
    return { x: e2.clientX, y: e2.clientY };
  }
  dispose(t2) {
    this.UIElement && (this._uiOriginalState && this._uiOriginalState.inDom ? this.UIElement.style.display = this._uiOriginalState.display : this.UIElement.style.display = "none"), this.clearDrawingLayers(), this.close(), this.forceLoseContext(), this.setViewDecorator(null, null), this._scanRegionOverlayContainer && this._scanRegionOverlayContainer.remove(), this._arrScanRegionOverlays.length = 0, t2 && this.UIElement && this.UIElement.remove(), this.__proto__ = null;
    for (let t3 in this) delete this[t3];
    Object.defineProperty(this, "isCameraEnhancer", { value: true }), Object.defineProperty(this, "isDisposed", { value: true }), Object.defineProperty(this, "disposed", { value: true });
  }
};
I._jsVersion = "3.3.10", I._jsEditVersion = "20240130", I._version = "JS " + I._jsVersion + "." + I._jsEditVersion, I.browserInfo = s, I._hasEngineResourceLoaded = false, I._engineResourcePath = c, I._defaultUIElementURL = "@engineResourcePath/dce.ui.html";
var L = { DT_Arc: class extends m {
  constructor(t2, e2, i2, r3, n3, s3) {
    super(new p.Circle({ left: t2, top: e2, radius: i2, startAngle: r3, endAngle: n3 }), s3), this._mediaType = "arc";
  }
}, DT_Polygon: w, DT_Rect: class extends m {
  constructor(t2, e2, i2, r3, n3) {
    super(new p.Rect({ left: t2, top: e2, width: i2, height: r3 }), n3);
  }
}, DT_Image: class extends m {
  constructor(t2, e2, i2, r3) {
    super(new p.Image(t2, { left: e2, top: i2 }), r3), this.image = t2;
  }
  _extendSet(t2, e2) {
    if ("image" === t2) {
      if (e2 instanceof HTMLImageElement) return this._fabricObject.setElement(e2), this.image = e2, true;
      if (e2 instanceof HTMLCanvasElement) {
        const t3 = new Image();
        return t3.src = e2.toDataURL(), this._fabricObject.setElement(t3), this.image = e2, true;
      }
      throw new Error("Unsupported value.");
    }
  }
  _extendGet(t2) {
    if ("image" === t2) return this.image;
  }
}, DT_Text: S, DT_Line: class extends w {
  constructor(t2, e2, i2) {
    super([t2, e2], i2), this._mediaType = "line";
  }
  _extendSet(t2, e2) {
    if ("startPoint" === t2 || "endPoint" === t2) {
      e2 = "startPoint" === t2 ? [e2, this.get("endPoint")] : [this.get("startPoint"), e2];
      const i2 = this._fabricObject;
      if (i2.group) {
        const t3 = i2.group;
        i2.points = e2.map((e3) => ({ x: e3.x - t3.left - t3.width / 2, y: e3.y - t3.top - t3.height / 2 })), t3.addWithUpdate();
      } else i2.points = e2;
      const r3 = i2.points.length - 1;
      return i2.controls = i2.points.reduce(function(t3, e3, i3) {
        return t3["p" + i3] = new p.Control({ positionHandler: v, actionHandler: b(i3 > 0 ? i3 - 1 : r3, y), actionName: "modifyPolygon", pointIndex: i3 }), t3;
      }, {}), i2._setPositionDimensions({}), true;
    }
  }
  _extendGet(t2) {
    if ("startPoint" === t2 || "endPoint" === t2) {
      const e2 = [], i2 = this._fabricObject;
      if (i2.selectable && !i2.group) for (let t3 in i2.oCoords) e2.push({ x: i2.oCoords[t3].x, y: i2.oCoords[t3].y });
      else for (let t3 of i2.points) {
        let r3 = t3.x - i2.pathOffset.x, n3 = t3.y - i2.pathOffset.y;
        const s3 = p.util.transformPoint({ x: r3, y: n3 }, i2.calcTransformMatrix());
        e2.push({ x: s3.x, y: s3.y });
      }
      return "startPoint" === t2 ? e2[0] : e2[1];
    }
  }
}, DT_Group: class extends m {
  constructor(t2) {
    super(new p.Group(t2.map((t3) => t3._getFabricObject()))), this._fabricObject.on("selected", () => {
      this.styleSelector = "selected";
      const t3 = this._fabricObject._objects;
      for (let e2 of t3) setTimeout(() => {
        e2 && e2.fire("selected");
      }, 0);
      setTimeout(() => {
        this._fabricObject && this._fabricObject.canvas && (this._fabricObject.dirty = true, this._fabricObject.canvas.renderAll());
      }, 0);
    }), this._fabricObject.on("deselected", () => {
      this.styleSelector = "default";
      const t3 = this._fabricObject._objects;
      for (let e2 of t3) setTimeout(() => {
        e2 && e2.fire("deselected");
      }, 0);
      setTimeout(() => {
        this._fabricObject && this._fabricObject.canvas && (this._fabricObject.dirty = true, this._fabricObject.canvas.renderAll());
      }, 0);
    });
  }
  getChildItems() {
    return this._fabricObject._objects.map((t2) => t2.getDrawingItem());
  }
  addChildItem(t2) {
    if (!t2 || !t2.isDrawingItem) throw TypeError("Illegal drawing item.");
    this._drawingLayer ? this._drawingLayer._updateGroupItem(this, t2, "add") : this._fabricObject.addWithUpdate(t2._getFabricObject());
  }
  removeChildItem(t2) {
    t2 && t2.isDrawingItem && (this._drawingLayer ? this._drawingLayer._updateGroupItem(this, t2, "remove") : this._fabricObject.removeWithUpdate(t2._getFabricObject()));
  }
} };

// node_modules/dynamsoft-javascript-barcode/dist/dbr.pure.esm.js
var s2 = "undefined" == typeof self;
var a2 = s2 ? {} : self;
var r2;
var o2;
var n2;
var c2;
var d2;
"undefined" != typeof navigator && (r2 = navigator, o2 = r2.userAgent, n2 = r2.platform, c2 = r2.mediaDevices), function() {
  if (!s2) {
    const e2 = { Edge: { search: "Edg", verSearch: "Edg" }, OPR: null, Chrome: null, Safari: { str: r2.vendor, search: "Apple", verSearch: ["Version", "iPhone OS", "CPU OS"] }, Firefox: null, Explorer: { search: "MSIE", verSearch: "MSIE" } }, t2 = { HarmonyOS: null, Android: null, iPhone: null, iPad: null, Windows: { str: n2, search: "Win" }, Mac: { str: n2 }, Linux: { str: n2 } };
    let i2 = "unknownBrowser", s3 = 0, a3 = "unknownOS";
    for (let t3 in e2) {
      const a4 = e2[t3] || {};
      let r3 = a4.str || o2, n3 = a4.search || t3, c3 = a4.verStr || o2, d3 = a4.verSearch || t3;
      if (d3 instanceof Array || (d3 = [d3]), -1 != r3.indexOf(n3)) {
        i2 = t3;
        for (let e3 of d3) {
          let t4 = c3.indexOf(e3);
          if (-1 != t4) {
            s3 = parseFloat(c3.substring(t4 + e3.length + 1));
            break;
          }
        }
        break;
      }
    }
    for (let e3 in t2) {
      const i3 = t2[e3] || {};
      let s4 = i3.str || o2, r3 = i3.search || e3;
      if (-1 != s4.indexOf(r3)) {
        a3 = e3;
        break;
      }
    }
    "Linux" == a3 && -1 != o2.indexOf("Windows NT") && (a3 = "HarmonyOS"), d2 = { browser: i2, version: s3, OS: a3 };
  }
  s2 && (d2 = { browser: "ssr", version: 0, OS: "ssr" });
}();
var l2 = "undefined" != typeof WebAssembly && o2 && !(/Safari/.test(o2) && !/Chrome/.test(o2) && /\(.+\s11_2_([2-6]).*\)/.test(o2));
var h2 = !("undefined" == typeof Worker);
var _2 = !(!c2 || !c2.getUserMedia);
var u2 = async () => {
  let e2 = false;
  if (_2) try {
    (await c2.getUserMedia({ video: true })).getTracks().forEach((e3) => {
      e3.stop();
    }), e2 = true;
  } catch (e3) {
  }
  return e2;
};
"Chrome" === d2.browser && d2.version > 66 || "Safari" === d2.browser && d2.version > 13 || "OPR" === d2.browser && d2.version > 43 || "Edge" === d2.browser && d2.version;
var g2 = (() => {
  if (!s2 && document.currentScript) {
    let e2 = document.currentScript.src, t2 = e2.indexOf("?");
    if (-1 != t2) e2 = e2.substring(0, t2);
    else {
      let t3 = e2.indexOf("#");
      -1 != t3 && (e2 = e2.substring(0, t3));
    }
    return e2.substring(0, e2.lastIndexOf("/") + 1);
  }
  return "./";
})();
var m2 = " is not allowed to change after `createInstance` or `loadWasm` is called.";
var R = !s2 && document.currentScript && (document.currentScript.getAttribute("data-license") || document.currentScript.getAttribute("data-productKeys") || document.currentScript.getAttribute("data-licenseKey") || document.currentScript.getAttribute("data-handshakeCode") || document.currentScript.getAttribute("data-organizationID")) || "";
var I2 = !s2 && document.currentScript && document.currentScript.getAttribute("data-sessionPassword") || "";
var S2 = (e2) => {
  if (null == e2) e2 = [];
  else {
    e2 = e2 instanceof Array ? [...e2] : [e2];
    for (let t2 = 0; t2 < e2.length; ++t2) {
      if (!s2) {
        let i2 = document.createElement("a");
        i2.href = e2[t2], e2[t2] = i2.href;
      }
      e2[t2].endsWith("/") || (e2[t2] += "/");
    }
  }
  return e2;
};
var E2;
var A;
var f2;
var T2;
var D2;
!function(e2) {
  e2[e2.IPF_Binary = 0] = "IPF_Binary", e2[e2.IPF_BinaryInverted = 1] = "IPF_BinaryInverted", e2[e2.IPF_GrayScaled = 2] = "IPF_GrayScaled", e2[e2.IPF_NV21 = 3] = "IPF_NV21", e2[e2.IPF_RGB_565 = 4] = "IPF_RGB_565", e2[e2.IPF_RGB_555 = 5] = "IPF_RGB_555", e2[e2.IPF_RGB_888 = 6] = "IPF_RGB_888", e2[e2.IPF_ARGB_8888 = 7] = "IPF_ARGB_8888", e2[e2.IPF_RGB_161616 = 8] = "IPF_RGB_161616", e2[e2.IPF_ARGB_16161616 = 9] = "IPF_ARGB_16161616", e2[e2.IPF_ABGR_8888 = 10] = "IPF_ABGR_8888", e2[e2.IPF_ABGR_16161616 = 11] = "IPF_ABGR_16161616", e2[e2.IPF_BGR_888 = 12] = "IPF_BGR_888";
}(E2 || (E2 = {})), function(e2) {
  e2[e2.DBR_SYSTEM_EXCEPTION = 1] = "DBR_SYSTEM_EXCEPTION", e2[e2.DBR_SUCCESS = 0] = "DBR_SUCCESS", e2[e2.DBR_UNKNOWN = -1e4] = "DBR_UNKNOWN", e2[e2.DBR_NO_MEMORY = -10001] = "DBR_NO_MEMORY", e2[e2.DBR_NULL_REFERENCE = -10002] = "DBR_NULL_REFERENCE", e2[e2.DBR_LICENSE_INVALID = -10003] = "DBR_LICENSE_INVALID", e2[e2.DBR_LICENSE_EXPIRED = -10004] = "DBR_LICENSE_EXPIRED", e2[e2.DBR_FILE_NOT_FOUND = -10005] = "DBR_FILE_NOT_FOUND", e2[e2.DBR_FILETYPE_NOT_SUPPORTED = -10006] = "DBR_FILETYPE_NOT_SUPPORTED", e2[e2.DBR_BPP_NOT_SUPPORTED = -10007] = "DBR_BPP_NOT_SUPPORTED", e2[e2.DBR_INDEX_INVALID = -10008] = "DBR_INDEX_INVALID", e2[e2.DBR_BARCODE_FORMAT_INVALID = -10009] = "DBR_BARCODE_FORMAT_INVALID", e2[e2.DBR_CUSTOM_REGION_INVALID = -10010] = "DBR_CUSTOM_REGION_INVALID", e2[e2.DBR_MAX_BARCODE_NUMBER_INVALID = -10011] = "DBR_MAX_BARCODE_NUMBER_INVALID", e2[e2.DBR_IMAGE_READ_FAILED = -10012] = "DBR_IMAGE_READ_FAILED", e2[e2.DBR_TIFF_READ_FAILED = -10013] = "DBR_TIFF_READ_FAILED", e2[e2.DBR_QR_LICENSE_INVALID = -10016] = "DBR_QR_LICENSE_INVALID", e2[e2.DBR_1D_LICENSE_INVALID = -10017] = "DBR_1D_LICENSE_INVALID", e2[e2.DBR_DIB_BUFFER_INVALID = -10018] = "DBR_DIB_BUFFER_INVALID", e2[e2.DBR_PDF417_LICENSE_INVALID = -10019] = "DBR_PDF417_LICENSE_INVALID", e2[e2.DBR_DATAMATRIX_LICENSE_INVALID = -10020] = "DBR_DATAMATRIX_LICENSE_INVALID", e2[e2.DBR_PDF_READ_FAILED = -10021] = "DBR_PDF_READ_FAILED", e2[e2.DBR_PDF_DLL_MISSING = -10022] = "DBR_PDF_DLL_MISSING", e2[e2.DBR_PAGE_NUMBER_INVALID = -10023] = "DBR_PAGE_NUMBER_INVALID", e2[e2.DBR_CUSTOM_SIZE_INVALID = -10024] = "DBR_CUSTOM_SIZE_INVALID", e2[e2.DBR_CUSTOM_MODULESIZE_INVALID = -10025] = "DBR_CUSTOM_MODULESIZE_INVALID", e2[e2.DBR_RECOGNITION_TIMEOUT = -10026] = "DBR_RECOGNITION_TIMEOUT", e2[e2.DBR_JSON_PARSE_FAILED = -10030] = "DBR_JSON_PARSE_FAILED", e2[e2.DBR_JSON_TYPE_INVALID = -10031] = "DBR_JSON_TYPE_INVALID", e2[e2.DBR_JSON_KEY_INVALID = -10032] = "DBR_JSON_KEY_INVALID", e2[e2.DBR_JSON_VALUE_INVALID = -10033] = "DBR_JSON_VALUE_INVALID", e2[e2.DBR_JSON_NAME_KEY_MISSING = -10034] = "DBR_JSON_NAME_KEY_MISSING", e2[e2.DBR_JSON_NAME_VALUE_DUPLICATED = -10035] = "DBR_JSON_NAME_VALUE_DUPLICATED", e2[e2.DBR_TEMPLATE_NAME_INVALID = -10036] = "DBR_TEMPLATE_NAME_INVALID", e2[e2.DBR_JSON_NAME_REFERENCE_INVALID = -10037] = "DBR_JSON_NAME_REFERENCE_INVALID", e2[e2.DBR_PARAMETER_VALUE_INVALID = -10038] = "DBR_PARAMETER_VALUE_INVALID", e2[e2.DBR_DOMAIN_NOT_MATCHED = -10039] = "DBR_DOMAIN_NOT_MATCHED", e2[e2.DBR_RESERVEDINFO_NOT_MATCHED = -10040] = "DBR_RESERVEDINFO_NOT_MATCHED", e2[e2.DBR_AZTEC_LICENSE_INVALID = -10041] = "DBR_AZTEC_LICENSE_INVALID", e2[e2.DBR_LICENSE_DLL_MISSING = -10042] = "DBR_LICENSE_DLL_MISSING", e2[e2.DBR_LICENSEKEY_NOT_MATCHED = -10043] = "DBR_LICENSEKEY_NOT_MATCHED", e2[e2.DBR_REQUESTED_FAILED = -10044] = "DBR_REQUESTED_FAILED", e2[e2.DBR_LICENSE_INIT_FAILED = -10045] = "DBR_LICENSE_INIT_FAILED", e2[e2.DBR_PATCHCODE_LICENSE_INVALID = -10046] = "DBR_PATCHCODE_LICENSE_INVALID", e2[e2.DBR_POSTALCODE_LICENSE_INVALID = -10047] = "DBR_POSTALCODE_LICENSE_INVALID", e2[e2.DBR_DPM_LICENSE_INVALID = -10048] = "DBR_DPM_LICENSE_INVALID", e2[e2.DBR_FRAME_DECODING_THREAD_EXISTS = -10049] = "DBR_FRAME_DECODING_THREAD_EXISTS", e2[e2.DBR_STOP_DECODING_THREAD_FAILED = -10050] = "DBR_STOP_DECODING_THREAD_FAILED", e2[e2.DBR_SET_MODE_ARGUMENT_ERROR = -10051] = "DBR_SET_MODE_ARGUMENT_ERROR", e2[e2.DBR_LICENSE_CONTENT_INVALID = -10052] = "DBR_LICENSE_CONTENT_INVALID", e2[e2.DBR_LICENSE_KEY_INVALID = -10053] = "DBR_LICENSE_KEY_INVALID", e2[e2.DBR_LICENSE_DEVICE_RUNS_OUT = -10054] = "DBR_LICENSE_DEVICE_RUNS_OUT", e2[e2.DBR_GET_MODE_ARGUMENT_ERROR = -10055] = "DBR_GET_MODE_ARGUMENT_ERROR", e2[e2.DBR_IRT_LICENSE_INVALID = -10056] = "DBR_IRT_LICENSE_INVALID", e2[e2.DBR_MAXICODE_LICENSE_INVALID = -10057] = "DBR_MAXICODE_LICENSE_INVALID", e2[e2.DBR_GS1_DATABAR_LICENSE_INVALID = -10058] = "DBR_GS1_DATABAR_LICENSE_INVALID", e2[e2.DBR_GS1_COMPOSITE_LICENSE_INVALID = -10059] = "DBR_GS1_COMPOSITE_LICENSE_INVALID", e2[e2.DBR_PANORAMA_LICENSE_INVALID = -10060] = "DBR_PANORAMA_LICENSE_INVALID", e2[e2.DBR_DOTCODE_LICENSE_INVALID = -10061] = "DBR_DOTCODE_LICENSE_INVALID", e2[e2.DBR_PHARMACODE_LICENSE_INVALID = -10062] = "DBR_PHARMACODE_LICENSE_INVALID", e2[e2.DBR_IMAGE_ORIENTATION_INVALID = -10063] = "DBR_IMAGE_ORIENTATION_INVALID", e2[e2.DMERR_NO_LICENSE = -2e4] = "DMERR_NO_LICENSE", e2[e2.DMERR_LICENSE_SYNC_FAILED = -20003] = "DMERR_LICENSE_SYNC_FAILED", e2[e2.DMERR_TRIAL_LICENSE = -20010] = "DMERR_TRIAL_LICENSE", e2[e2.DMERR_FAILED_TO_REACH_LTS = -20200] = "DMERR_FAILED_TO_REACH_LTS";
}(A || (A = {})), function(e2) {
  e2[e2.IMRDT_IMAGE = 1] = "IMRDT_IMAGE", e2[e2.IMRDT_CONTOUR = 2] = "IMRDT_CONTOUR", e2[e2.IMRDT_LINESEGMENT = 4] = "IMRDT_LINESEGMENT", e2[e2.IMRDT_LOCALIZATIONRESULT = 8] = "IMRDT_LOCALIZATIONRESULT", e2[e2.IMRDT_REGIONOFINTEREST = 16] = "IMRDT_REGIONOFINTEREST", e2[e2.IMRDT_QUADRILATERAL = 32] = "IMRDT_QUADRILATERAL";
}(f2 || (f2 = {})), function(e2) {
  e2[e2.BF_ALL = -29360129] = "BF_ALL", e2[e2.BF_ONED = 3147775] = "BF_ONED", e2[e2.BF_GS1_DATABAR = 260096] = "BF_GS1_DATABAR", e2[e2.BF_CODE_39 = 1] = "BF_CODE_39", e2[e2.BF_CODE_128 = 2] = "BF_CODE_128", e2[e2.BF_CODE_93 = 4] = "BF_CODE_93", e2[e2.BF_CODABAR = 8] = "BF_CODABAR", e2[e2.BF_ITF = 16] = "BF_ITF", e2[e2.BF_EAN_13 = 32] = "BF_EAN_13", e2[e2.BF_EAN_8 = 64] = "BF_EAN_8", e2[e2.BF_UPC_A = 128] = "BF_UPC_A", e2[e2.BF_UPC_E = 256] = "BF_UPC_E", e2[e2.BF_INDUSTRIAL_25 = 512] = "BF_INDUSTRIAL_25", e2[e2.BF_CODE_39_EXTENDED = 1024] = "BF_CODE_39_EXTENDED", e2[e2.BF_GS1_DATABAR_OMNIDIRECTIONAL = 2048] = "BF_GS1_DATABAR_OMNIDIRECTIONAL", e2[e2.BF_GS1_DATABAR_TRUNCATED = 4096] = "BF_GS1_DATABAR_TRUNCATED", e2[e2.BF_GS1_DATABAR_STACKED = 8192] = "BF_GS1_DATABAR_STACKED", e2[e2.BF_GS1_DATABAR_STACKED_OMNIDIRECTIONAL = 16384] = "BF_GS1_DATABAR_STACKED_OMNIDIRECTIONAL", e2[e2.BF_GS1_DATABAR_EXPANDED = 32768] = "BF_GS1_DATABAR_EXPANDED", e2[e2.BF_GS1_DATABAR_EXPANDED_STACKED = 65536] = "BF_GS1_DATABAR_EXPANDED_STACKED", e2[e2.BF_GS1_DATABAR_LIMITED = 131072] = "BF_GS1_DATABAR_LIMITED", e2[e2.BF_PATCHCODE = 262144] = "BF_PATCHCODE", e2[e2.BF_PDF417 = 33554432] = "BF_PDF417", e2[e2.BF_QR_CODE = 67108864] = "BF_QR_CODE", e2[e2.BF_DATAMATRIX = 134217728] = "BF_DATAMATRIX", e2[e2.BF_AZTEC = 268435456] = "BF_AZTEC", e2[e2.BF_MAXICODE = 536870912] = "BF_MAXICODE", e2[e2.BF_MICRO_QR = 1073741824] = "BF_MICRO_QR", e2[e2.BF_MICRO_PDF417 = 524288] = "BF_MICRO_PDF417", e2[e2.BF_GS1_COMPOSITE = -2147483648] = "BF_GS1_COMPOSITE", e2[e2.BF_MSI_CODE = 1048576] = "BF_MSI_CODE", e2[e2.BF_CODE_11 = 2097152] = "BF_CODE_11", e2[e2.BF_NULL = 0] = "BF_NULL";
}(T2 || (T2 = {})), function(e2) {
  e2[e2.IRT_NO_RESULT = 0] = "IRT_NO_RESULT", e2[e2.IRT_ORIGINAL_IMAGE = 1] = "IRT_ORIGINAL_IMAGE", e2[e2.IRT_COLOUR_CLUSTERED_IMAGE = 2] = "IRT_COLOUR_CLUSTERED_IMAGE", e2[e2.IRT_COLOUR_CONVERTED_GRAYSCALE_IMAGE = 4] = "IRT_COLOUR_CONVERTED_GRAYSCALE_IMAGE", e2[e2.IRT_TRANSFORMED_GRAYSCALE_IMAGE = 8] = "IRT_TRANSFORMED_GRAYSCALE_IMAGE", e2[e2.IRT_PREDETECTED_REGION = 16] = "IRT_PREDETECTED_REGION", e2[e2.IRT_PREPROCESSED_IMAGE = 32] = "IRT_PREPROCESSED_IMAGE", e2[e2.IRT_BINARIZED_IMAGE = 64] = "IRT_BINARIZED_IMAGE", e2[e2.IRT_TEXT_ZONE = 128] = "IRT_TEXT_ZONE", e2[e2.IRT_CONTOUR = 256] = "IRT_CONTOUR", e2[e2.IRT_LINE_SEGMENT = 512] = "IRT_LINE_SEGMENT", e2[e2.IRT_FORM = 1024] = "IRT_FORM", e2[e2.IRT_SEGMENTATION_BLOCK = 2048] = "IRT_SEGMENTATION_BLOCK", e2[e2.IRT_TYPED_BARCODE_ZONE = 4096] = "IRT_TYPED_BARCODE_ZONE", e2[e2.IRT_PREDETECTED_QUADRILATERAL = 8192] = "IRT_PREDETECTED_QUADRILATERAL";
}(D2 || (D2 = {}));
var C2 = (e2) => e2 && "object" == typeof e2 && "function" == typeof e2.then;
var y2 = class extends Promise {
  constructor(e2) {
    let t2, i2;
    super((e3, s3) => {
      t2 = e3, i2 = s3;
    }), this._s = "pending", this.resolve = (e3) => {
      this.isPending && (C2(e3) ? this.task = e3 : (this._s = "fulfilled", t2(e3)));
    }, this.reject = (e3) => {
      this.isPending && (this._s = "rejected", i2(e3));
    }, this.task = e2;
  }
  get status() {
    return this._s;
  }
  get isPending() {
    return "pending" === this._s;
  }
  get isFulfilled() {
    return "fulfilled" === this._s;
  }
  get isRejected() {
    return "rejected" === this._s;
  }
  get task() {
    return this._task;
  }
  set task(e2) {
    let t2;
    this._task = e2, C2(e2) ? t2 = e2 : "function" == typeof e2 && (t2 = new Promise(e2)), t2 && (async () => {
      try {
        const i2 = await t2;
        e2 === this._task && this.resolve(i2);
      } catch (t3) {
        e2 === this._task && this.reject(t3);
      }
    })();
  }
  get isEmpty() {
    return null == this._task;
  }
};
var p2 = ["iPhone", "iPad", "Android", "HarmonyOS"].includes(d2.OS) ? 2048 : 4096;
var L2 = class _L {
  static get version() {
    return this._version;
  }
  static get license() {
    return this._license;
  }
  static set license(e2) {
    ((e3, t2) => {
      const i2 = e3;
      if (!i2._pLoad.isEmpty) throw new Error("`license`" + m2);
      i2._license = t2;
    })(_L, e2);
  }
  static get productKeys() {
    return this._license;
  }
  static set productKeys(e2) {
    _L.license = e2;
  }
  static get handshakeCode() {
    return this._license;
  }
  static set handshakeCode(e2) {
    _L.license = e2;
  }
  static get organizationID() {
    return this._license;
  }
  static set organizationID(e2) {
    _L.license = e2;
  }
  static set sessionPassword(e2) {
    ((e3, t2) => {
      const i2 = e3;
      if (!i2._pLoad.isEmpty) throw new Error("`sessionPassword`" + m2);
      i2._sessionPassword = t2;
    })(_L, e2);
  }
  static get sessionPassword() {
    return this._sessionPassword;
  }
  static async detectEnvironment() {
    return await (async () => ({ wasm: l2, worker: h2, getUserMedia: _2, camera: await u2(), browser: d2.browser, version: d2.version, OS: d2.OS }))();
  }
  static get engineResourcePath() {
    return this._engineResourcePath;
  }
  static set engineResourcePath(e2) {
    if (!this._pLoad.isEmpty) throw new Error("`engineResourcePath` is not allowed to change after `createInstance` or `loadWasm` is called.");
    _L._engineResourcePath = ((e3) => {
      if (null == e3 && (e3 = "./"), s2) ;
      else {
        let t2 = document.createElement("a");
        t2.href = e3, e3 = t2.href;
      }
      return e3.endsWith("/") || (e3 += "/"), e3;
    })(e2);
  }
  static get licenseServer() {
    return this._licenseServer;
  }
  static set licenseServer(e2) {
    ((e3, t2) => {
      const i2 = e3;
      if (!i2._pLoad.isEmpty) throw new Error("`licenseServer`" + m2);
      i2._licenseServer = S2(t2);
    })(_L, e2);
  }
  static get deviceFriendlyName() {
    return this._deviceFriendlyName;
  }
  static set deviceFriendlyName(e2) {
    ((e3, t2) => {
      const i2 = e3;
      if (!i2._pLoad.isEmpty) throw new Error("`deviceFriendlyName`" + m2);
      i2._deviceFriendlyName = t2 || "";
    })(_L, e2);
  }
  static get _bUseFullFeature() {
    return this.__bUseFullFeature;
  }
  static set _bUseFullFeature(e2) {
    if (!this._pLoad.isEmpty) throw new Error("`_bUseFullFeature` is not allowed to change after `createInstance` or `loadWasm` is called.");
    _L.__bUseFullFeature = e2;
  }
  static isImageSource(e2) {
    return !(!e2 || "object" != typeof e2 || Array.isArray(e2)) && "getImage" in e2;
  }
  static isDSImage(e2) {
    return !(!e2 || "object" != typeof e2 || Array.isArray(e2)) && ("data" in e2 && ("width" in e2 && ("height" in e2 && "pixelFormat" in e2)));
  }
  static isDCEFrame(e2) {
    return !(!e2 || "object" != typeof e2 || Array.isArray(e2)) && ("data" in e2 && ("region" in e2 && ("sx" in e2 && ("sy" in e2 && ("width" in e2 && ("height" in e2 && (("colorMode" in e2 || "pixelFormat" in e2) && ("timeSpent" in e2 && ("timeStamp" in e2 && ("isCropped" in e2 && ("toCanvas" in e2 && ("_sWidth" in e2 && ("_sHeight" in e2 && "_bUseWebGL" in e2)))))))))))));
  }
  get ifSaveOriginalImageInACanvas() {
    return this._ifSaveOriginalImageInACanvas;
  }
  set ifSaveOriginalImageInACanvas(e2) {
    this._ifSaveOriginalImageInACanvas = e2;
  }
  getOriginalImageInACanvas() {
    return !this.oriCanvas && this.oriCanvasData ? this.oriCanvasData.toCanvas() : this.oriCanvas;
  }
  set region(e2) {
    this._region = e2, this.array_decodeFrameTimeCost.length = 0, this.array_getFrameTimeCost.length = 0, this._intervalGetVideoFrame = 0;
  }
  get region() {
    return this._region;
  }
  static isWasmLoaded() {
    return this._pLoad.isFulfilled;
  }
  isContextDestroyed() {
    return this.bDestroyed;
  }
  static get lastErrorCode() {
    return this._lastErrorCode;
  }
  static get lastErrorString() {
    return this._lastErrorString;
  }
  get lastErrorCode() {
    return this._lastErrorCode;
  }
  get lastErrorString() {
    return this._lastErrorString;
  }
  static get defaultUIElementURL() {
    var e2;
    return null === (e2 = _L._defaultUIElementURL) || void 0 === e2 ? void 0 : e2.replace("@engineResourcePath/", _L.engineResourcePath);
  }
  static set defaultUIElementURL(e2) {
    _L._defaultUIElementURL = e2;
  }
  static _fireHTTPSWarnning() {
    _L.onWarning && location && "https:" !== location.protocol && setTimeout(() => {
      _L.onWarning && _L.onWarning({ id: 2, message: "Not connected via SSL (HTTPS), the SDK may not work correctly." });
    }, 0);
  }
  get soundSource() {
    return this._soundSource;
  }
  set soundSource(t2) {
    this._soundSource = t2, this.beepSound = new Howl({ src: [this._soundSource], onplayerror: (e2, t3) => {
      console.warn(`Sound '${e2}' playback failure: ${t3}`);
    } });
  }
  get whenToPlaySoundforSuccessfulRead() {
    return true === this.bPlaySoundOnSuccessfulRead ? "frame" : this.bPlaySoundOnSuccessfulRead ? this.bPlaySoundOnSuccessfulRead : "never";
  }
  set whenToPlaySoundforSuccessfulRead(e2) {
    this.bPlaySoundOnSuccessfulRead = "never" !== e2 && e2;
  }
  get whenToVibrateforSuccessfulRead() {
    return true === this.bVibrateOnSuccessfulRead ? "frame" : this.bVibrateOnSuccessfulRead ? this.bVibrateOnSuccessfulRead : "never";
  }
  set whenToVibrateforSuccessfulRead(e2) {
    this.bVibrateOnSuccessfulRead = "never" !== e2 && e2;
  }
  set dce(e2) {
    this._dce = e2;
  }
  get dce() {
    return !this._dce || this._dce.isDisposed || this._dce.disposed ? null : this._dce;
  }
  set maxCvsSideLength(e2) {
    this._maxCvsSideLength = e2, this._dceControler && this._dceControler.setDisiredValue(this, "maxCvsSideLength", e2);
  }
  get maxCvsSideLength() {
    return this._maxCvsSideLength;
  }
  async _registerDCEControler() {
    if (!this.dce) return;
    _L._onLog && _L._onLog("_registerDCEControler()");
    const e2 = this.dce;
    this._dceControler = e2._createControler();
    const t2 = this._dceControler;
    t2.register(this), t2.setDisiredValue(this, "refreshInterval", 200), t2.setDisiredValue(this, "maxCvsSideLength", this._maxCvsSideLength), this._styleIdBeforeVerification = this.dce.createDrawingStyle({ fillStyle: "rgba(248,252,0,0.2)", strokeStyle: "transparent", paintMode: "strokeAndFill" });
    try {
      ResizeObserver;
    } catch (e3) {
      "ReferenceError" === e3.name && window && (window.ResizeObserver = void 0);
    }
    const i2 = e2.getUIElement(), s3 = this.dce.constructor;
    if ("@engineResourcePath/dce.ui.html" === s3._defaultUIElementURL) try {
      i2 ? i2 === t2._innerSetUI && (await e2.setUIElement(`${s3.engineResourcePath}dce.ui.html`), t2._innerSetUI = e2.getUIElement()) : (await e2.setUIElement(`${s3.engineResourcePath}dbr.ui.html`), t2._innerSetUI = e2.getUIElement());
    } catch (t3) {
      await e2.setUIElement(s3.defaultUIElementURL);
    }
    else i2 || await e2.setUIElement(s3.defaultUIElementURL);
    this.callbackCameraChange = () => {
      this._clearResultsCanvasTimeoutId && clearTimeout(this._clearResultsCanvasTimeoutId), this._drawResults(null), this.array_decodeFrameTimeCost.length = 0, this.array_getFrameTimeCost.length = 0, this._intervalGetVideoFrame = 0;
    }, this.callbackResolutionChange = () => {
      this._clearResultsCanvasTimeoutId && clearTimeout(this._clearResultsCanvasTimeoutId), this._drawResults(null), this.array_decodeFrameTimeCost.length = 0, this.array_getFrameTimeCost.length = 0, this._intervalGetVideoFrame = 0;
    }, this.callbackCameraClose = () => {
      this.stopScanning(true), this.array_decodeFrameTimeCost.length = 0, this.array_getFrameTimeCost.length = 0, this._intervalGetVideoFrame = 0, this._bPauseScan = false;
    }, this.callbackSingleFrameAcquired = async (e3) => {
      this._clearResultsCanvasTimeoutId && clearTimeout(this._clearResultsCanvasTimeoutId), this._drawResults(null);
      let t3 = await this._decode_DCEFrame(e3, { bCopyData: false }), i3 = null;
      if (t3 && t3.length) {
        const { sx: s4, sy: a3, width: r3, height: o3, _sWidth: n3, _sHeight: c3 } = e3;
        i3 = t3.map((e4) => ({ localizationResult: JSON.parse(JSON.stringify(e4.localizationResult)) })), _L.recalculateResultLocation(i3, s4, a3, n3, c3, r3, o3);
      }
      if (this._drawResults(i3, t3), await this.clearMapDecodeRecord(), this.onImageRead && this.dce.isOpen() && !this._bPauseScan) {
        let e4 = this._cloneDecodeResults(t3);
        this.onImageRead(e4);
      }
      if (this.onUniqueRead && this.dce.isOpen() && !this._bPauseScan) for (let e4 of t3) this.onUniqueRead(e4.barcodeText, this._cloneDecodeResults(e4));
    }, e2.on("cameraChange", this.callbackCameraChange), e2.on("resolutionChange", this.callbackResolutionChange), e2.on("cameraClose", this.callbackCameraClose), e2.on("singleFrameAcquired", this.callbackSingleFrameAcquired);
  }
  _logoutDCEControler() {
    this.dce && this._dceControler && (_L._onLog && _L._onLog("_logoutDCEControler()"), this._dceControler.logout(this), this.dce.off("cameraChange", this.callbackCameraChange), this.dce.off("resolutionChange", this.callbackResolutionChange), this.dce.off("cameraClose", this.callbackCameraClose), this.dce.off("singleFrameAcquired", this.callbackSingleFrameAcquired), this._dceControler = null, this.dce = null);
  }
  async setImageSource(e2, t2) {
    if (null == e2) return this._imgSource = null, this._logoutDCEControler(), void (this._drawingItemNamespace = null);
    if (e2 && e2.isCameraEnhancer) this.dce = e2, await this._registerDCEControler(), this._imgSource = null;
    else {
      if (!_L.isImageSource(e2)) throw new Error("Invalid value.");
      this._logoutDCEControler(), this._imgSource = e2;
    }
    t2 && t2.resultsHighlightBaseShapes && (this._drawingItemNamespace = t2.resultsHighlightBaseShapes);
  }
  static async loadWasm() {
    if (this._pLoad.isEmpty) {
      let { lt: e2, l: t2, ls: i2, sp: s3, rmk: r3 } = ((e3, t3 = false) => {
        const i3 = e3;
        if (i3._pLoad.isEmpty) {
          let e4, s4, r4, o3 = i3._license || "", n3 = JSON.parse(JSON.stringify(i3._licenseServer)), c3 = i3._sessionPassword, d3 = 0;
          if (o3.startsWith("t") || o3.startsWith("f")) d3 = 0;
          else if (0 === o3.length || o3.startsWith("P") || o3.startsWith("L") || o3.startsWith("Y") || o3.startsWith("A")) d3 = 1;
          else {
            d3 = 2;
            const t4 = o3.indexOf(":");
            -1 != t4 && (o3 = o3.substring(t4 + 1));
            const i4 = o3.indexOf("?");
            if (-1 != i4 && (s4 = o3.substring(i4 + 1), o3 = o3.substring(0, i4)), o3.startsWith("DLC2")) d3 = 0;
            else {
              if (o3.startsWith("DLS2")) {
                let t5;
                try {
                  let e5 = o3.substring(4);
                  e5 = atob(e5), t5 = JSON.parse(e5);
                } catch (e5) {
                  throw new Error("Format Error: The license string you specified is invalid, please check to make sure it is correct.");
                }
                if (o3 = t5.handshakeCode ? t5.handshakeCode : t5.organizationID ? t5.organizationID : "", "number" == typeof o3 && (o3 = JSON.stringify(o3)), 0 === n3.length) {
                  let e5 = [];
                  t5.mainServerURL && (e5[0] = t5.mainServerURL), t5.standbyServerURL && (e5[1] = t5.standbyServerURL), n3 = S2(e5);
                }
                !c3 && t5.sessionPassword && (c3 = t5.sessionPassword), e4 = t5.remark;
              }
              o3 && "200001" !== o3 && !o3.startsWith("200001-") || (d3 = 1);
            }
          }
          if (d3 && (t3 || (a2.crypto || (r4 = "Please upgrade your browser to support online key."), a2.crypto.subtle || (r4 = "Require https to use online key in this browser."))), r4) {
            if (1 !== d3) throw new Error(r4);
            d3 = 0, console.warn(r4), i3._lastErrorCode = -1, i3._lastErrorString = r4;
          }
          return 1 === d3 && (o3 = "", console.warn("Applying for a public trial license ...")), { lt: d3, l: o3, ls: n3, sp: c3, rmk: e4, cv: s4 };
        }
        throw new Error("Can't preprocess license again" + m2);
      })(_L);
      this._pLoad.task = async (a3, o3) => {
        let n3 = _L.engineResourcePath + _L._workerName;
        _L.engineResourcePath.startsWith(location.origin) || (n3 = await fetch(n3).then((e3) => e3.blob()).then((e3) => URL.createObjectURL(e3))), _L._dbrWorker = new Worker(n3), URL.revokeObjectURL(n3), _L._dbrWorker.onerror = (e3) => {
          let t3 = new Error(e3.message);
          o3(t3);
        }, _L._dbrWorker.onmessage = async (t3) => {
          let i3 = t3.data ? t3.data : t3;
          switch (i3.type) {
            case "log":
              _L._onLog && _L._onLog(i3.message);
              break;
            case "load": {
              i3.message && (i3.message = i3.message.replace("(https://www.dynamsoft.com/purchase-center/)", "(https://www.dynamsoft.com/store/dynamsoft-barcode-reader/#javascript)"));
              let t4, s4 = false;
              1 === e2 && (s4 = true, i3.message || (i3.message = "Using a temporary license. [Register for a 30-day trial license >>>](https://www.dynamsoft.com/customer/license/trialLicense?product=dbr&deploymenttype=browser)")), i3.success ? (_L._dbrWorker.onerror = null, _L._version = i3.version + "(JS " + _L._jsVersion + "." + _L._jsEditVersion + ")", _L._onLog && _L._onLog("load dbr worker success"), i3.message && console.warn(i3.message)) : (t4 = new Error(i3.message), t4.stack = i3.stack + "\n" + t4.stack, t4.ltsErrorCode = i3.ltsErrorCode, s4 || 111 == i3.ltsErrorCode && -1 != i3.message.toLowerCase().indexOf("trial license") && (s4 = true)), s4 && _L.showDialog(i3.success ? "warn" : "error", i3.message), i3.success ? a3() : o3(t4);
              break;
            }
            case "task": {
              let e3 = i3.id, t4 = i3.body;
              try {
                _L._taskCallbackMap.get(e3)(t4), _L._taskCallbackMap.delete(e3);
              } catch (t5) {
                throw _L._taskCallbackMap.delete(e3), t5;
              }
              break;
            }
            default:
              _L._onLog && _L._onLog(t3);
          }
        }, _L._dbrWorker.postMessage({ type: "loadWasm", engineResourcePath: _L.engineResourcePath, bUseFullFeature: _L._bUseFullFeature, bd: _L._bWasmDebug, v: _L._jsVersion, brtk: !!e2, bptk: 1 === e2, l: t2, dm: location.origin.startsWith("http") ? location.origin : "https://localhost", os: d2, cv: _L.authCacheVersion, fn: _L.deviceFriendlyName, ls: i2, sp: s3, rmk: r3 });
      };
    }
    await this._pLoad;
  }
  static async showDialog(e2, t2) {
    await (async (e3, t3, i2) => {
      if (!e3._bNeverShowDialog) try {
        let s3 = await fetch(e3.engineResourcePath + "dls.license.dialog.html");
        if (!s3.ok) throw Error("Get license dialog fail. Network Error: " + s3.statusText);
        let a3 = await s3.text();
        if (!a3.trim().startsWith("<")) throw Error("Get license dialog fail. Can't get valid HTMLElement.");
        let r3 = document.createElement("div");
        r3.innerHTML = a3;
        let o3 = [];
        for (let e4 = 0; e4 < r3.childElementCount; ++e4) {
          let t4 = r3.children[e4];
          t4 instanceof HTMLStyleElement && (o3.push(t4), document.head.append(t4));
        }
        let n3 = 1 == r3.childElementCount ? r3.children[0] : r3;
        n3.remove();
        let c3, d3, l3, h3, _3, u3 = [n3], g3 = n3.children;
        for (let e4 of g3) u3.push(e4);
        for (let e4 = 0; e4 < u3.length; ++e4) for (let t4 of u3[e4].children) u3.push(t4);
        for (let e4 of u3) if (!c3 && e4.classList.contains("dls-license-mask")) c3 = e4, e4.addEventListener("click", (t4) => {
          if (e4 == t4.target) {
            n3.remove();
            for (let e5 of o3) e5.remove();
          }
        });
        else if (!d3 && e4.classList.contains("dls-license-icon-close")) d3 = e4, e4.addEventListener("click", () => {
          n3.remove();
          for (let e5 of o3) e5.remove();
        });
        else if (!l3 && e4.classList.contains("dls-license-icon-error")) l3 = e4, "error" != t3 && e4.remove();
        else if (!h3 && e4.classList.contains("dls-license-icon-warn")) h3 = e4, "warn" != t3 && e4.remove();
        else if (!_3 && e4.classList.contains("dls-license-msg-content")) {
          _3 = e4;
          let t4 = i2;
          for (; t4; ) {
            let i3 = t4.indexOf("["), s4 = t4.indexOf("]", i3), a4 = t4.indexOf("(", s4), r4 = t4.indexOf(")", a4);
            if (-1 == i3 || -1 == s4 || -1 == a4 || -1 == r4) {
              e4.appendChild(new Text(t4));
              break;
            }
            i3 > 0 && e4.appendChild(new Text(t4.substring(0, i3)));
            let o4 = document.createElement("a"), n4 = t4.substring(i3 + 1, s4);
            o4.innerText = n4;
            let c4 = t4.substring(a4 + 1, r4);
            o4.setAttribute("href", c4), o4.setAttribute("target", "_blank"), e4.appendChild(o4), t4 = t4.substring(r4 + 1);
          }
        }
        document.body.appendChild(n3);
      } catch (t4) {
        e3._onLog && e3._onLog(t4.message || t4);
      }
    })(this, e2, t2);
  }
  static async createInstanceInWorker(e2 = false) {
    return await _L.loadWasm(), await new Promise((t2, i2) => {
      let s3 = _L._nextTaskID++;
      _L._taskCallbackMap.set(s3, (e3) => {
        if (e3.success) return t2(e3.instanceID);
        {
          let t3 = new Error(e3.message);
          return t3.stack = e3.stack + "\n" + t3.stack, i2(t3);
        }
      }), _L._dbrWorker.postMessage({ type: "createInstance", id: s3, bScanner: e2 });
    });
  }
  constructor() {
    this._instanceID = void 0, this._ifSaveOriginalImageInACanvas = false, this.oriCanvas = null, this.oriCanvasData = null, this.canvas = null, this.bFilterRegionInJs = false, this._region = null, this._timeStartDecode = null, this._timeEnterInnerDBR = null, this._timeGetMessage = null, this.decodeRecords = {}, this.bDestroyed = false, this._lastErrorCode = 0, this._lastErrorString = "", this._lastInnerDecodeDuration = 0, this.intervalTime = 0, this._intervalGetVideoFrame = 0, this.array_getFrameTimeCost = [], this.array_decodeFrameTimeCost = [], this._indexCurrentDecodingFrame = 0, this._arrPolygons = [], this._bPauseScan = false, this._intervalDetectVideoPause = 1e3, this._soundSource = "data:audio/mpeg;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4LjI5LjEwMAAAAAAAAAAAAAAA/+M4wAAAAAAAAAAAAEluZm8AAAAPAAAABQAAAkAAgICAgICAgICAgICAgICAgICAgKCgoKCgoKCgoKCgoKCgoKCgoKCgwMDAwMDAwMDAwMDAwMDAwMDAwMDg4ODg4ODg4ODg4ODg4ODg4ODg4P//////////////////////////AAAAAExhdmM1OC41NAAAAAAAAAAAAAAAACQEUQAAAAAAAAJAk0uXRQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+MYxAANQAbGeUEQAAHZYZ3fASqD4P5TKBgocg+Bw/8+CAYBA4XB9/4EBAEP4nB9+UOf/6gfUCAIKyjgQ/Kf//wfswAAAwQA/+MYxAYOqrbdkZGQAMA7DJLCsQxNOij///////////+tv///3RWiZGBEhsf/FO/+LoCSFs1dFVS/g8f/4Mhv0nhqAieHleLy/+MYxAYOOrbMAY2gABf/////////////////usPJ66R0wI4boY9/8jQYg//g2SPx1M0N3Z0kVJLIs///Uw4aMyvHJJYmPBYG/+MYxAgPMALBucAQAoGgaBoFQVBUFQWDv6gZBUFQVBUGgaBr5YSgqCoKhIGg7+IQVBUFQVBoGga//SsFSoKnf/iVTEFNRTMu/+MYxAYAAANIAAAAADEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV", this.bPlaySoundOnSuccessfulRead = false, this.bVibrateOnSuccessfulRead = false, this.vibrateDuration = 300, this.captureAndDecodeInParallel = true, this.autoSuggestTip = false, this.suggestTipFrameArray = [], this.suggestTipFrameLimit = [5, 3], this.noIntermediateResultsCount = 0, this.noIntermediateResultsTipLimit = 100, this.tinyBarcodeTipModuleSizeLimit = 3, this.hugeBarcodeTipLimit = 0.9, this.autoZoomInFrameArray = [], this.autoZoomInFrameLimit = [5, 3], this.autoZoomInStepRate = 1 / 3, this.autoZoomInMaxStep = 1.5, this.autoZoomInMaxTimes = 5, this.autoZoomInMinStep = Math.pow(10, 1 / this.autoZoomInMaxTimes), this.autoZoomInIdealModuleSize = 6, this.autoZoomOutFrameCount = 0, this.autoZoomOutFrameLimit = 3, this.autoZoomOutStepRate = 1 / 3, this.autoZoomOutMinValue = 1, this.autoZoomOutMinStep = 2, this.autoZoomOutStepRate_2 = 0.05, this.autoZoomOutMinValue_2 = 2, this.frameArrayInIdealZoom = [], this.frameLimitInIdealZoom = [5, 3], this.enableZoomOutInIdealZoom = false, this.nextActionInIdealZoom = "focus", this.autoFocusFrameArray = [], this.autoFocusFrameLimit = [5, 3], this.autoZoomIdealArea = [0, 0.05], this.autoZoomTargetBorder = 0.9, this.autoZoomDetectionArea = 0.5, this.autoZoom = false, this.autoFocus = false, this._resultHighlightingDuration = -1, this._dce = null, this._imgSource = null, this._maxCvsSideLength = p2, this._promiseStartScan = null, this.beepSound = new Howl({ src: [this._soundSource], onplayerror: (e2, t2) => {
      console.warn(`Sound '${e2}' playback failure: ${t2}`);
    } });
  }
  static async createInstance() {
    const e2 = new _L();
    return e2._instanceID = await _L.createInstanceInWorker(), _L._fireHTTPSWarnning(), e2;
  }
  async clearMapDecodeRecord() {
    return await new Promise((e2, t2) => {
      let i2 = _L._nextTaskID++;
      _L._taskCallbackMap.set(i2, (i3) => {
        if (i3.success) return e2();
        {
          let e3 = new Error(i3.message);
          return e3.stack = i3.stack + "\n" + e3.stack, t2(e3);
        }
      }), _L._dbrWorker.postMessage({ type: "clearMapDecodeRecord", id: i2, instanceID: this._instanceID });
    });
  }
  async decode(e2) {
    _L._onLog && _L._onLog("decode(source: any)"), _L._onLog && (this._timeStartDecode = Date.now());
    let t2 = {};
    return !this.region || this.region instanceof Array || (t2.region = JSON.parse(JSON.stringify(this.region))), e2 instanceof Blob ? await this._decode_Blob(e2, t2) : e2 instanceof ArrayBuffer ? await this._decode_ArrayBuffer(e2, t2) : e2 instanceof Uint8Array || e2 instanceof Uint8ClampedArray ? await this._decode_Uint8Array(e2, t2) : e2 instanceof HTMLImageElement || "undefined" != typeof ImageBitmap && e2 instanceof ImageBitmap ? await this._decode_Image(e2, t2) : e2 instanceof HTMLCanvasElement ? await this._decode_Canvas(e2, t2) : e2 instanceof HTMLVideoElement ? await this._decode_Video(e2, t2) : "string" == typeof e2 ? "data:image/" == e2.substring(0, 11) ? await this._decode_Base64(e2, t2) : await this._decode_Url(e2, t2) : _L.isDCEFrame(e2) ? (t2.bCopyData = true, await this._decode_DCEFrame(e2, t2)) : _L.isDSImage(e2) ? (t2.bCopyData = true, await this._decode_DSImage(e2, t2)) : await Promise.reject(TypeError("'_decode(source, config)': Type of 'source' should be 'Blob', 'ArrayBuffer', 'Uint8Array', 'HTMLImageElement', 'HTMLCanvasElement', 'HTMLVideoElement', 'String(base64 with image mime)' or 'String(url)'."));
  }
  async decodeBase64String(e2) {
    let t2 = {};
    return !this.region || this.region instanceof Array || (t2.region = JSON.parse(JSON.stringify(this.region))), this._decode_Base64(e2, t2);
  }
  async decodeUrl(e2) {
    let t2 = {};
    return !this.region || this.region instanceof Array || (t2.region = JSON.parse(JSON.stringify(this.region))), this._decode_Url(e2, t2);
  }
  async _decodeBuffer_Uint8Array(e2, t2, i2, s3, a3, r3, o3) {
    return await new Promise((n3, c3) => {
      let d3 = _L._nextTaskID++;
      _L._taskCallbackMap.set(d3, (e3) => {
        if (e3.success) {
          let t3, i3 = _L._onLog ? Date.now() : 0;
          _L._onLog && _L._onLog("worker return result: " + i3), this._lastInnerDecodeDuration = e3.duration;
          try {
            t3 = this._handleRetJsonString(e3.decodeReturn);
          } catch (e4) {
            return c3(e4);
          }
          if (_L._onLog) {
            let e4 = Date.now();
            _L._onLog("DBR getting message from worker timestamp: " + i3), _L._onLog("From DBR staring decoding to entering worker costs: " + (this._timeEnterInnerDBR - this._timeStartDecode)), _L._onLog("From DBR entering worker to returning message from worker costs: " + (i3 - this._timeEnterInnerDBR)), _L._onLog("Handling results from DBR worker costs: " + (e4 - i3)), _L._onLog("Total decoding image costs: " + (e4 - this._timeStartDecode));
          }
          return n3(t3);
        }
        {
          let t3 = new Error(e3.message);
          return t3.stack = e3.stack + "\n" + t3.stack, c3(t3);
        }
      }), this._timeEnterInnerDBR = Date.now(), _L._onLog && _L._onLog("Sending buffer to worker timestamp:" + this._timeEnterInnerDBR), _L._dbrWorker.postMessage({ type: "decodeBuffer", id: d3, instanceID: this._instanceID, body: { buffer: e2, width: t2, height: i2, stride: s3, format: a3, orientation: r3, config: o3 } }, [e2.buffer]), _L._onLog && o3 && o3.timeStamp && _L._onLog("Delay of decoding image: " + (this._timeEnterInnerDBR - o3.timeStamp));
    });
  }
  async _decodeBuffer_Blob(e2, t2, i2, s3, a3, r3, o3) {
    _L._onLog && _L._onLog("_decodeBuffer_Blob(buffer,width,height,stride,format)");
    const n3 = e2.arrayBuffer ? await e2.arrayBuffer() : await new Promise((t3, i3) => {
      let s4 = new FileReader();
      s4.readAsArrayBuffer(e2), s4.onload = () => {
        t3(s4.result);
      }, s4.onerror = () => {
        i3(s4.error);
      };
    });
    return await this._decodeBuffer_Uint8Array(new Uint8Array(n3), t2, i2, s3, a3, r3, o3);
  }
  async decodeBuffer(e2, t2, i2, s3, a3, r3, o3) {
    let n3;
    return _L._onLog && _L._onLog("decodeBuffer(buffer,width,height,stride,format)"), _L._onLog && (this._timeStartDecode = Date.now()), e2 instanceof Uint8Array || e2 instanceof Uint8ClampedArray ? n3 = await this._decodeBuffer_Uint8Array(e2, t2, i2, s3, a3, r3, o3) : e2 instanceof ArrayBuffer ? n3 = await this._decodeBuffer_Uint8Array(new Uint8Array(e2), t2, i2, s3, a3, r3, o3) : e2 instanceof Blob && (n3 = await this._decodeBuffer_Blob(e2, t2, i2, s3, a3, r3, o3)), n3;
  }
  async _decodeFileInMemory_Uint8Array(e2) {
    return await new Promise((t2, i2) => {
      let s3 = _L._nextTaskID++;
      _L._taskCallbackMap.set(s3, (e3) => {
        if (e3.success) {
          let s4;
          this._lastInnerDecodeDuration = e3.duration;
          try {
            s4 = this._handleRetJsonString(e3.decodeReturn);
          } catch (e4) {
            return i2(e4);
          }
          return t2(s4);
        }
        {
          let t3 = new Error(e3.message);
          return t3.stack = e3.stack + "\n" + t3.stack, i2(t3);
        }
      }), _L._dbrWorker.postMessage({ type: "decodeFileInMemory", id: s3, instanceID: this._instanceID, body: { bytes: e2 } });
    });
  }
  async getRuntimeSettings() {
    return await new Promise((e2, t2) => {
      let i2 = _L._nextTaskID++;
      _L._taskCallbackMap.set(i2, (i3) => {
        if (i3.success) {
          let t3 = JSON.parse(i3.results);
          return null != this.userDefinedRegion && (t3.region = JSON.parse(JSON.stringify(this.userDefinedRegion))), e2(t3);
        }
        {
          let e3 = new Error(i3.message);
          return e3.stack = i3.stack + "\n" + e3.stack, t2(e3);
        }
      }), _L._dbrWorker.postMessage({ type: "getRuntimeSettings", id: i2, instanceID: this._instanceID });
    });
  }
  async updateRuntimeSettings(e2) {
    let t2;
    if ("string" == typeof e2) if ("speed" == e2) {
      let e3 = await this.getRuntimeSettings();
      await this.resetRuntimeSettings(), t2 = await this.getRuntimeSettings(), t2.barcodeFormatIds = e3.barcodeFormatIds, t2.barcodeFormatIds_2 = e3.barcodeFormatIds_2, t2.region = e3.region, t2.deblurLevel = 3, t2.expectedBarcodesCount = 0, t2.localizationModes = [2, 0, 0, 0, 0, 0, 0, 0];
    } else if ("balance" == e2) {
      let e3 = await this.getRuntimeSettings();
      await this.resetRuntimeSettings(), t2 = await this.getRuntimeSettings(), t2.barcodeFormatIds = e3.barcodeFormatIds, t2.barcodeFormatIds_2 = e3.barcodeFormatIds_2, t2.region = e3.region, t2.deblurLevel = 5, t2.expectedBarcodesCount = 512, t2.localizationModes = [2, 16, 0, 0, 0, 0, 0, 0];
    } else if ("coverage" == e2) {
      let e3 = await this.getRuntimeSettings();
      await this.resetRuntimeSettings(), t2 = await this.getRuntimeSettings(), t2.barcodeFormatIds = e3.barcodeFormatIds, t2.barcodeFormatIds_2 = e3.barcodeFormatIds_2, t2.region = e3.region;
    } else if ("dense" == e2) {
      let e3 = await this.getRuntimeSettings();
      await this.resetRuntimeSettings(), this.maxCvsSideLength = 4096, t2 = await this.getRuntimeSettings(), t2.barcodeFormatIds = e3.barcodeFormatIds, t2.barcodeFormatIds_2 = e3.barcodeFormatIds_2, t2.region = e3.region, t2.deblurLevel = 9, t2.expectedBarcodesCount = 0, t2.localizationModes = [2, 8, 0, 0, 0, 0, 0, 0];
    } else if ("distance" == e2) {
      let e3 = await this.getRuntimeSettings();
      await this.resetRuntimeSettings(), this.maxCvsSideLength = 4096, t2 = await this.getRuntimeSettings(), t2.barcodeFormatIds = e3.barcodeFormatIds, t2.barcodeFormatIds_2 = e3.barcodeFormatIds_2, t2.region = e3.region, t2.deblurLevel = 3, t2.expectedBarcodesCount = 0, t2.localizationModes = [2, 8, 0, 0, 0, 0, 0, 0];
    } else t2 = JSON.parse(e2);
    else {
      if ("object" != typeof e2) throw TypeError("'UpdateRuntimeSettings(settings)': Type of 'settings' should be 'string' or 'PlainObject'.");
      if (t2 = JSON.parse(JSON.stringify(e2)), t2.region instanceof Array) {
        let e3 = t2.region;
        [e3.regionLeft, e3.regionTop, e3.regionLeft, e3.regionBottom, e3.regionMeasuredByPercentage].some((e4) => void 0 !== e4) && (t2.region = { regionLeft: e3.regionLeft || 0, regionTop: e3.regionTop || 0, regionRight: e3.regionRight || 0, regionBottom: e3.regionBottom || 0, regionMeasuredByPercentage: e3.regionMeasuredByPercentage || 0 });
      }
    }
    if (!_L._bUseFullFeature) {
      if (t2.barcodeFormatIds & ~(T2.BF_ONED | T2.BF_QR_CODE | T2.BF_PDF417 | T2.BF_DATAMATRIX) || 0 != t2.barcodeFormatIds_2) throw Error("Some of the specified barcode formats are not supported in the compact version. Please try the full-featured version.");
      if (0 != t2.intermediateResultTypes) throw Error("Intermediate results is not supported in the compact version. Please try the full-featured version.");
    }
    if (this.bFilterRegionInJs) {
      let e3 = t2.region;
      if (e3 instanceof Array) throw Error("The `region` of type `Array` is only allowed in `BarcodeScanner`.");
      this.userDefinedRegion = JSON.parse(JSON.stringify(e3)), (e3.regionLeft || e3.regionTop || e3.regionRight || e3.regionBottom || e3.regionMeasuredByPercentage) && (e3.regionLeft || e3.regionTop || 100 != e3.regionRight || 100 != e3.regionBottom || !e3.regionMeasuredByPercentage) ? this.region = e3 : this.region = null, t2.region = { regionLeft: 0, regionTop: 0, regionRight: 0, regionBottom: 0, regionMeasuredByPercentage: 0 };
    } else this.userDefinedRegion = null, this.region = null;
    return (this.autoZoom || this.autoFocus) && (t2.intermediateResultTypes |= D2.IRT_TYPED_BARCODE_ZONE), await new Promise((e3, i2) => {
      let s3 = _L._nextTaskID++;
      _L._taskCallbackMap.set(s3, (t3) => {
        if (t3.success) {
          try {
            this._handleRetJsonString(t3.updateReturn);
          } catch (e4) {
            i2(e4);
          }
          return e3();
        }
        {
          let e4 = new Error(t3.message);
          return e4.stack = t3.stack + "\n" + e4.stack, i2(e4);
        }
      }), _L._dbrWorker.postMessage({ type: "updateRuntimeSettings", id: s3, instanceID: this._instanceID, body: { settings: JSON.stringify(t2) } });
    });
  }
  async resetRuntimeSettings() {
    return this.userDefinedRegion = null, this.region = null, this.maxCvsSideLength = p2, await new Promise((e2, t2) => {
      let i2 = _L._nextTaskID++;
      _L._taskCallbackMap.set(i2, (i3) => {
        if (i3.success) return e2();
        {
          let e3 = new Error(i3.message);
          return e3.stack = i3.stack + "\n" + e3.stack, t2(e3);
        }
      }), _L._dbrWorker.postMessage({ type: "resetRuntimeSettings", id: i2, instanceID: this._instanceID });
    });
  }
  async _resetRuntimeSettingsToCppDefault() {
    return this.userDefinedRegion = null, this.region = null, this.maxCvsSideLength = p2, await new Promise((e2, t2) => {
      let i2 = _L._nextTaskID++;
      _L._taskCallbackMap.set(i2, (i3) => {
        if (i3.success) return e2();
        {
          let e3 = new Error(i3.message);
          return e3.stack = i3.stack + "\n" + e3.stack, t2(e3);
        }
      }), _L._dbrWorker.postMessage({ type: "resetRuntimeSettingsToCppDefault", id: i2, instanceID: this._instanceID });
    });
  }
  async outputRuntimeSettingsToString() {
    if (!_L._bUseFullFeature) throw Error("outputRuntimeSettingsToString() is not supported in the compact version. Please try the full-featured version.");
    return await new Promise((e2, t2) => {
      let i2 = _L._nextTaskID++;
      _L._taskCallbackMap.set(i2, (i3) => {
        if (i3.success) return e2(i3.results);
        {
          let e3 = new Error(i3.message);
          return e3.stack = i3.stack + "\n" + e3.stack, t2(e3);
        }
      }), _L._dbrWorker.postMessage({ type: "outputRuntimeSettingsToString", id: i2, instanceID: this._instanceID });
    });
  }
  async initRuntimeSettingsWithString(e2) {
    if (!_L._bUseFullFeature) throw Error("initRuntimeSettingsWithString() is not supported in the compact version. Please try the full-featured version.");
    if ("string" == typeof e2) ;
    else {
      if ("object" != typeof e2) throw TypeError("'initRuntimeSettingstWithString(settings)': Type of 'settings' should be 'string' or 'PlainObject'.");
      e2 = JSON.stringify(e2);
    }
    return await new Promise((t2, i2) => {
      let s3 = _L._nextTaskID++;
      _L._taskCallbackMap.set(s3, (e3) => {
        if (e3.success) {
          try {
            this._handleRetJsonString(e3.initReturn);
          } catch (e4) {
            i2(e4);
          }
          return t2();
        }
        {
          let t3 = new Error(e3.message);
          return t3.stack = e3.stack + "\n" + t3.stack, i2(t3);
        }
      }), _L._dbrWorker.postMessage({ type: "initRuntimeSettingsWithString", id: s3, instanceID: this._instanceID, body: { settings: e2 } });
    });
  }
  async _decode_Blob(e2, t2) {
    _L._onLog && _L._onLog("_decode_Blob(blob: Blob)");
    let i2 = null, s3 = null;
    if ("undefined" != typeof createImageBitmap) try {
      i2 = await createImageBitmap(e2);
    } catch (e3) {
    }
    i2 || (s3 = await function(e3) {
      return new Promise((t3, i3) => {
        let s4 = URL.createObjectURL(e3), a4 = new Image();
        a4.src = s4, a4.onload = () => {
          URL.revokeObjectURL(a4.src), t3(a4);
        }, a4.onerror = (e4) => {
          i3(new Error("Can't convert blob to image : " + (e4 instanceof Event ? e4.type : e4)));
        };
      });
    }(e2));
    let a3 = await this._decode_Image(i2 || s3, t2);
    return i2 && i2.close(), a3;
  }
  async _decode_ArrayBuffer(e2, t2) {
    return await this._decode_Blob(new Blob([e2]), t2);
  }
  async _decode_Uint8Array(e2, t2) {
    return await this._decode_Blob(new Blob([e2]), t2);
  }
  async _decode_Image(e2, t2) {
    _L._onLog && _L._onLog("_decode_Image(image: HTMLImageElement|ImageBitmap)"), t2 = t2 || {};
    let i2, s3, a3 = e2 instanceof HTMLImageElement ? e2.naturalWidth : e2.width, r3 = e2 instanceof HTMLImageElement ? e2.naturalHeight : e2.height, o3 = Math.max(a3, r3);
    if (o3 > this._maxCvsSideLength) {
      let e3 = this._maxCvsSideLength / o3;
      i2 = Math.round(a3 * e3), s3 = Math.round(r3 * e3);
    } else i2 = a3, s3 = r3;
    this.canvas || (this.canvas = document.createElement("canvas"));
    const n3 = this.canvas;
    n3.width === i2 && n3.height === s3 || (n3.width = i2, n3.height = s3), n3.ctx2d || (n3.ctx2d = n3.getContext("2d", { willReadFrequently: true }));
    n3.ctx2d.drawImage(e2, 0, 0, a3, r3, 0, 0, i2, s3);
    let c3 = await this._decode_Canvas(n3, t2);
    if (this.ifSaveOriginalImageInACanvas) {
      const t3 = document.createElement("canvas");
      t3.width = e2.width, t3.height = e2.height;
      t3.getContext("2d").drawImage(e2, 0, 0), this.oriCanvas = t3, this.oriCanvasData = null;
    }
    return _L.recalculateResultLocation(c3, 0, 0, a3, r3, i2, s3), c3;
  }
  async _decode_Canvas(e2, t2) {
    if (_L._onLog && _L._onLog("_decode_Canvas(canvas:HTMLCanvasElement)"), e2.crossOrigin && "anonymous" != e2.crossOrigin) throw "cors";
    if (0 === e2.width || 0 === e2.height) throw Error("The width or height of the 'canvas' is 0.");
    this.ifSaveOriginalImageInACanvas && (this.oriCanvas = e2, this.oriCanvasData = null);
    let i2 = (e2.ctx2d || e2.getContext("2d", { willReadFrequently: true })).getImageData(0, 0, e2.width, e2.height).data;
    return await this._decodeBuffer_Uint8Array(i2, e2.width, e2.height, 4 * e2.width, E2.IPF_ABGR_8888, 0, t2);
  }
  async _decode_Video(e2, t2) {
    if (_L._onLog && _L._onLog("_decode_Video(video)"), !(e2 instanceof HTMLVideoElement)) throw TypeError("'_decode_Video(video [, config] )': Type of 'video' should be 'HTMLVideoElement'.");
    if (e2.crossOrigin && "anonymous" != e2.crossOrigin) throw "cors";
    t2 = t2 || {};
    let i2, s3, a3 = e2.videoWidth, r3 = e2.videoHeight, o3 = Math.max(a3, r3);
    if (o3 > this._maxCvsSideLength) {
      let e3 = this._maxCvsSideLength / o3;
      i2 = Math.round(a3 * e3), s3 = Math.round(r3 * e3);
    } else i2 = a3, s3 = r3;
    this.canvas || (this.canvas = document.createElement("canvas"));
    const n3 = this.canvas;
    n3.width === i2 && n3.height === s3 || (n3.width = i2, n3.height = s3), n3.ctx2d || (n3.ctx2d = n3.getContext("2d", { willReadFrequently: true }));
    n3.ctx2d.drawImage(e2, 0, 0, a3, r3, 0, 0, i2, s3);
    let c3 = await this._decode_Canvas(n3, t2);
    if (this.ifSaveOriginalImageInACanvas) {
      const t3 = document.createElement("canvas");
      t3.width = e2.videoWidth, t3.height = e2.videoHeight;
      t3.getContext("2d").drawImage(e2, 0, 0), this.oriCanvas = t3, this.oriCanvasData = null;
    }
    return _L.recalculateResultLocation(c3, 0, 0, a3, r3, i2, s3), c3;
  }
  async _decode_DCEFrame(e2, t2) {
    if (_L._onLog && _L._onLog("_decode_DCEFrame(dceFrame)"), !_L.isDCEFrame(e2)) return [];
    let i2 = [];
    this.ifSaveOriginalImageInACanvas && (this.oriCanvas = null, this.oriCanvasData = { width: e2.width, height: e2.height, colorMode: e2.colorMode, pixelFormat: e2.pixelFormat, data: new Uint8Array(e2.data), toCanvas: e2.toCanvas });
    const { width: s3, height: a3, colorMode: r3, pixelFormat: o3, stride: n3, timeStamp: c3 } = e2;
    let d3;
    d3 = t2 && t2.bCopyData ? new Uint8Array(e2.data) : e2.data;
    let l3 = null;
    if (t2 ? (l3 = JSON.parse(JSON.stringify(t2)), l3.timeStamp = c3) : l3 = { timeStamp: c3 }, o3 && n3) if ("grey" === o3) i2 = await this._decodeBuffer_Uint8Array(d3, s3, a3, n3, E2.IPF_GrayScaled, 0, l3);
    else if ("rgba" === o3) i2 = await this._decodeBuffer_Uint8Array(d3, s3, a3, n3, E2.IPF_ABGR_8888, 0, l3);
    else {
      if ("bgra" !== o3) throw new Error(`Pixel format '${o3}' is not supported to decode.`);
      i2 = await this._decodeBuffer_Uint8Array(d3, s3, a3, n3, E2.IPF_ARGB_8888, 0, l3);
    }
    else if ("grey" === r3) i2 = await this._decodeBuffer_Uint8Array(d3, s3, a3, s3, E2.IPF_GrayScaled, 0, l3);
    else if ("rgba" === r3) i2 = await this._decodeBuffer_Uint8Array(d3, s3, a3, 4 * s3, E2.IPF_ABGR_8888, 0, l3);
    else {
      if ("bgra" !== r3) throw new Error(`Color mode '${r3}' is not supported to decode.`);
      i2 = await this._decodeBuffer_Uint8Array(d3, s3, a3, 4 * s3, E2.IPF_ARGB_8888, 0, l3);
    }
    return i2;
  }
  async _decode_DSImage(e2, t2) {
    if (_L._onLog && _L._onLog("_decode_DSImage(dsImage)"), !_L.isDSImage(e2)) return null;
    this.ifSaveOriginalImageInACanvas && (this.oriCanvas = null, this.oriCanvasData = { width: e2.width, height: e2.height, pixelFormat: e2.pixelFormat.toLowerCase(), data: new Uint8Array(e2.data), toCanvas: function() {
      const e3 = document.createElement("canvas");
      let t3;
      switch (e3.width = this.width, e3.height = this.height, this.pixelFormat) {
        case "grey":
          t3 = new Uint8ClampedArray(this.width * this.height * 4);
          for (let e4 = 0; e4 < t3.length; e4 += 4) t3[e4] = this.data[e4 / 4], t3[e4 + 1] = this.data[e4 / 4], t3[e4 + 2] = this.data[e4 / 4], t3[e4 + 3] = 255;
          break;
        case "rgb":
          t3 = new Uint8ClampedArray(this.width * this.height * 4);
          for (let e4 = 0; e4 < t3.length; e4 += 4) t3[e4] = this.data[e4], t3[e4 + 1] = this.data[e4 + 1], t3[e4 + 2] = this.data[e4 + 2], t3[e4 + 3] = 255;
          break;
        case "bgr":
          t3 = new Uint8ClampedArray(this.width * this.height * 4);
          for (let e4 = 0; e4 < t3.length; e4 += 4) t3[e4] = this.data[e4], t3[e4 + 1] = this.data[e4 + 1], t3[e4 + 2] = this.data[e4 + 2], t3[e4 + 3] = 255;
          break;
        case "rgba":
        case "bgra":
          t3 = new Uint8ClampedArray(this.data);
          break;
        default:
          throw new Error("The content of 2D Canvas is currently limited to the sRGB color space.");
      }
      const i3 = new ImageData(t3, this.width, this.height);
      return e3.getContext("2d").putImageData(i3, 0, 0), e3;
    } });
    const { width: i2, height: s3 } = e2;
    let a3, r3, o3, n3 = e2.pixelFormat.toLowerCase();
    switch (a3 = t2 && t2.bCopyData ? new Uint8Array(e2.data) : e2.data, n3) {
      case "grey":
        o3 = E2.IPF_GrayScaled, r3 = i2;
        break;
      case "rgb":
        o3 = E2.IPF_BGR_888, r3 = 3 * i2;
        break;
      case "bgr":
        o3 = E2.IPF_RGB_888, r3 = 3 * i2;
        break;
      case "rgba":
        o3 = E2.IPF_ABGR_8888, r3 = 4 * i2;
        break;
      case "bgra":
        o3 = E2.IPF_ARGB_8888, r3 = 4 * i2;
        break;
      default:
        throw new Error("The pixel format is not supported to decode.");
    }
    return await this._decodeBuffer_Uint8Array(a3, i2, s3, r3, o3, 0, t2);
  }
  async _decode_Base64(e2, t2) {
    if (_L._onLog && _L._onLog("_decode_Base64(base64Str)"), "string" != typeof e2) return Promise.reject("'_decode_Base64(base64Str, config)': Type of 'base64Str' should be 'string'.");
    "data:image/" == e2.substring(0, 11) && (e2 = e2.substring(e2.indexOf(",") + 1));
    let i2 = atob(e2), s3 = i2.length, a3 = new Uint8Array(s3);
    for (; s3--; ) a3[s3] = i2.charCodeAt(s3);
    return await this._decode_Blob(new Blob([a3]), t2);
  }
  async _decode_Url(e2, t2) {
    if (_L._onLog && _L._onLog("_decode_Url(url)"), "string" != typeof e2) throw TypeError("'_decode_Url(url, config)': Type of 'url' should be 'string'.");
    let i2 = await new Promise((t3, i3) => {
      let s3 = new XMLHttpRequest();
      s3.open("GET", e2, true), s3.responseType = "blob", s3.send(), s3.onloadend = async () => {
        t3(s3.response);
      }, s3.onerror = () => {
        i3(new Error("Network Error: " + s3.statusText));
      };
    });
    return await this._decode_Blob(i2, t2);
  }
  static recalculateResultLocation(e2, t2, i2, s3, a3, r3, o3) {
    if (e2.length > 0) for (let n3 of e2) {
      let e3 = n3.localizationResult;
      2 == e3.resultCoordinateType && (e3.x1 *= 0.01 * r3, e3.x2 *= 0.01 * r3, e3.x3 *= 0.01 * r3, e3.x4 *= 0.01 * r3, e3.y1 *= 0.01 * o3, e3.y2 *= 0.01 * o3, e3.y3 *= 0.01 * o3, e3.y4 *= 0.01 * o3);
      let c3 = r3 / s3, d3 = o3 / a3;
      e3.x1 = e3.x1 / c3 + t2, e3.x2 = e3.x2 / c3 + t2, e3.x3 = e3.x3 / c3 + t2, e3.x4 = e3.x4 / c3 + t2, e3.y1 = e3.y1 / d3 + i2, e3.y2 = e3.y2 / d3 + i2, e3.y3 = e3.y3 / d3 + i2, e3.y4 = e3.y4 / d3 + i2, 2 == e3.resultCoordinateType && (e3.x1 *= 100 / s3, e3.x2 *= 100 / s3, e3.x3 *= 100 / s3, e3.x4 *= 100 / s3, e3.y1 *= 100 / a3, e3.y2 *= 100 / a3, e3.y3 *= 100 / a3, e3.y4 *= 100 / a3), e3.x1 = Math.round(e3.x1), e3.x2 = Math.round(e3.x2), e3.x3 = Math.round(e3.x3), e3.x4 = Math.round(e3.x4), e3.y1 = Math.round(e3.y1), e3.y2 = Math.round(e3.y2), e3.y3 = Math.round(e3.y3), e3.y4 = Math.round(e3.y4);
    }
  }
  static BarcodeReaderException(e2, t2) {
    let i2, s3 = A.DBR_UNKNOWN;
    return "number" == typeof e2 ? (s3 = e2, i2 = new Error(t2)) : i2 = new Error(e2), i2.code = s3, i2;
  }
  _handleRetJsonString(e2) {
    let t2 = A;
    if (e2.textResults) {
      for (let t3 = 0; t3 < e2.textResults.length; t3++) {
        let i2 = e2.textResults[t3];
        try {
          let e3 = i2.barcodeText, t4 = "";
          for (let i3 = 0; i3 < e3.length; i3++) t4 += String.fromCharCode(e3[i3]);
          try {
            i2.barcodeText = decodeURIComponent(escape(t4));
          } catch (e4) {
            i2.barcodeText = t4;
          }
        } catch (e3) {
          i2.barcodeText = "";
        }
        if (null != i2.exception) {
          _L._setWarnnedEx.has(i2.exception) || (_L._setWarnnedEx.add(i2.exception), console.warn(i2.exception));
          let e3 = {};
          i2.exception.split(";").forEach((t4) => {
            let i3 = t4.indexOf(":");
            e3[t4.substring(0, i3)] = t4.substring(i3 + 1);
          }), i2.exception = e3;
        }
      }
      return e2.decodeRecords ? this.decodeRecords = e2.decodeRecords : this.decodeRecords = {}, this._lastErrorCode = e2.exception, this._lastErrorString = e2.description, e2.exception && !_L._setWarnnedEx.has(e2.description) && (_L._setWarnnedEx.add(e2.description), console.warn(e2.description)), e2.textResults;
    }
    if (e2.exception == t2.DBR_SUCCESS) return e2.data;
    throw _L.BarcodeReaderException(e2.exception, e2.description);
  }
  async setModeArgument(e2, t2, i2, s3) {
    return await new Promise((a3, r3) => {
      let o3 = _L._nextTaskID++;
      _L._taskCallbackMap.set(o3, (e3) => {
        if (e3.success) {
          try {
            this._handleRetJsonString(e3.setReturn);
          } catch (e4) {
            return r3(e4);
          }
          return a3();
        }
        {
          let t3 = new Error(e3.message);
          return t3.stack = e3.stack + "\n" + t3.stack, r3(t3);
        }
      }), _L._dbrWorker.postMessage({ type: "setModeArgument", id: o3, instanceID: this._instanceID, body: { modeName: e2, index: t2, argumentName: i2, argumentValue: s3 } });
    });
  }
  async getModeArgument(e2, t2, i2) {
    return await new Promise((s3, a3) => {
      let r3 = _L._nextTaskID++;
      _L._taskCallbackMap.set(r3, (e3) => {
        if (e3.success) {
          let t3;
          try {
            t3 = this._handleRetJsonString(e3.getReturn);
          } catch (e4) {
            return a3(e4);
          }
          return s3(t3);
        }
        {
          let t3 = new Error(e3.message);
          return t3.stack = e3.stack + "\n" + t3.stack, a3(t3);
        }
      }), _L._dbrWorker.postMessage({ type: "getModeArgument", id: r3, instanceID: this._instanceID, body: { modeName: e2, index: t2, argumentName: i2 } });
    });
  }
  async getIntermediateResults() {
    return await new Promise((e2, t2) => {
      let i2 = _L._nextTaskID++;
      _L._taskCallbackMap.set(i2, (i3) => {
        if (i3.success) return e2(i3.results);
        {
          let e3 = new Error(i3.message);
          return e3.stack = i3.stack + "\n" + e3.stack, t2(e3);
        }
      }), _L._dbrWorker.postMessage({ type: "getIntermediateResults", id: i2, instanceID: this._instanceID, body: { isCharge: true } });
    });
  }
  async getIntermediateCanvas() {
    let e2 = await this.getIntermediateResults(), t2 = [];
    for (let i2 of e2) if (i2.dataType == f2.IMRDT_IMAGE) for (let e3 of i2.results) {
      const i3 = e3.bytes;
      let s3;
      switch (_L._onLog && _L._onLog(" " + i3.length + " " + i3.byteLength + " " + e3.width + " " + e3.height + " " + e3.stride + " " + e3.format), e3.format) {
        case E2.IPF_ABGR_8888:
          s3 = new Uint8ClampedArray(i3);
          break;
        case E2.IPF_RGB_888: {
          const e4 = i3.length / 3;
          s3 = new Uint8ClampedArray(4 * e4);
          for (let t3 = 0; t3 < e4; ++t3) s3[4 * t3] = i3[3 * t3 + 2], s3[4 * t3 + 1] = i3[3 * t3 + 1], s3[4 * t3 + 2] = i3[3 * t3], s3[4 * t3 + 3] = 255;
          break;
        }
        case E2.IPF_GrayScaled: {
          const e4 = i3.length;
          s3 = new Uint8ClampedArray(4 * e4);
          for (let t3 = 0; t3 < e4; t3++) s3[4 * t3] = s3[4 * t3 + 1] = s3[4 * t3 + 2] = i3[t3], s3[4 * t3 + 3] = 255;
          break;
        }
        case E2.IPF_Binary:
        case E2.IPF_BinaryInverted: {
          const t3 = i3.length, a4 = e3.width, r4 = e3.height, o3 = e3.stride;
          s3 = new Uint8ClampedArray(a4 * r4 * 4);
          for (let e4 = 0; e4 < t3; e4++) {
            let t4 = i3[e4], r5 = e4 % o3 * 8, n3 = Math.floor(e4 / o3);
            for (let e5 = 0; e5 < 8; e5++) {
              let i4 = r5 + e5, o4 = 4 * (n3 * a4 + i4);
              if (i4 >= a4) break;
              s3[o4] = s3[o4 + 1] = s3[o4 + 2] = (128 & t4) / 128 * 255, s3[o4 + 3] = 255, t4 <<= 1;
            }
          }
          break;
        }
        default:
          console.warn("unknow intermediate image", e3);
      }
      if (!s3) continue;
      let a3 = new ImageData(s3, e3.width, e3.height), r3 = document.createElement("canvas");
      r3.width = e3.width, r3.height = e3.height, r3.getContext("2d").putImageData(a3, 0, 0), t2.push(r3);
    }
    return t2;
  }
  async getScanSettings() {
    return await new Promise((e2, t2) => {
      let i2 = _L._nextTaskID++;
      _L._taskCallbackMap.set(i2, (i3) => {
        if (i3.success) {
          let t3 = i3.results;
          return t3.intervalTime = this.intervalTime, t3.whenToPlaySoundforSuccessfulRead = this.whenToPlaySoundforSuccessfulRead, t3.soundOnSuccessfullRead = this.soundSource, t3.whenToVibrateforSuccessfulRead = this.whenToVibrateforSuccessfulRead, t3.vibrateDuration = this.vibrateDuration, t3.captureAndDecodeInParallel = this.captureAndDecodeInParallel, t3.autoZoom = this.autoZoom, t3.autoFocus = this.autoFocus, t3.autoSuggestTip = this.autoSuggestTip, e2(t3);
        }
        {
          let e3 = new Error(i3.message);
          return e3.stack += "\n" + i3.stack, t2(e3);
        }
      }), _L._dbrWorker.postMessage({ type: "getScanSettings", id: i2, instanceID: this._instanceID });
    });
  }
  async updateScanSettings(e2) {
    if (!e2) return;
    const t2 = JSON.parse(JSON.stringify(e2));
    if (t2.autoZoom || t2.autoFocus || t2.autoSuggestTip) {
      if (!_L._bUseFullFeature) throw new Error("'autoZoom', 'autoFocus' and 'autoSuggestTip' are not supported in the compact version. Please try the full-featured version.");
      const e3 = await this.getRuntimeSettings();
      e3.intermediateResultTypes |= D2.IRT_TYPED_BARCODE_ZONE, await this.updateRuntimeSettings(e3);
    }
    return t2.hasOwnProperty("intervalTime") && (this.intervalTime = Math.max(t2.intervalTime, 0), delete t2.intervalTime), t2.hasOwnProperty("whenToPlaySoundforSuccessfulRead") && (this.whenToPlaySoundforSuccessfulRead = t2.whenToPlaySoundforSuccessfulRead, delete t2.whenToPlaySoundforSuccessfulRead), t2.hasOwnProperty("soundOnSuccessfullRead") && (this.soundSource = t2.soundOnSuccessfullRead, delete t2.soundOnSuccessfullRead), t2.hasOwnProperty("whenToVibrateforSuccessfulRead") && (this.whenToVibrateforSuccessfulRead = t2.whenToVibrateforSuccessfulRead, delete t2.whenToVibrateforSuccessfulRead), t2.hasOwnProperty("vibrateDuration") && (this.vibrateDuration = t2.vibrateDuration, delete t2.vibrateDuration), t2.hasOwnProperty("captureAndDecodeInParallel") && (this.captureAndDecodeInParallel = t2.captureAndDecodeInParallel, delete t2.captureAndDecodeInParallel), t2.hasOwnProperty("autoZoom") && (this.autoZoom && this.autoZoom != t2.autoZoom && this.dce && this.dce.setZoom({ factor: 1 }).catch(() => {
    }), this.autoZoom = t2.autoZoom, delete t2.autoZoom), t2.hasOwnProperty("autoFocus") && (this.autoFocus = t2.autoFocus, this.dce && this.dce.setFocus({ mode: "continuous" }).catch(() => {
    }), delete t2.autoFocus), t2.hasOwnProperty("autoSuggestTip") && (this.autoSuggestTip = t2.autoSuggestTip, delete t2.autoFocus), await new Promise((e3, i2) => {
      let s3 = _L._nextTaskID++;
      _L._taskCallbackMap.set(s3, (t3) => {
        if (t3.success) return e3();
        {
          let e4 = new Error(t3.message);
          return e4.stack += "\n" + t3.stack, i2(e4);
        }
      }), _L._dbrWorker.postMessage({ type: "updateScanSettings", id: s3, instanceID: this._instanceID, body: { settings: t2 } });
    });
  }
  _cloneDecodeResults(e2) {
    if (e2 instanceof Array) {
      let t2 = [];
      for (let i2 of e2) t2.push(this._cloneDecodeResults(i2));
      return t2;
    }
    {
      let t2 = e2;
      return JSON.parse(JSON.stringify(t2, (e3, t3) => "oriVideoCanvas" == e3 || "searchRegionCanvas" == e3 ? void 0 : t3));
    }
  }
  async _loopReadVideo() {
    if (this.bDestroyed) return this.dce && this._dceControler && this._dceControler.setDisiredAction(this, "stopFetchingLoop"), this._clearResultsCanvasTimeoutId && clearTimeout(this._clearResultsCanvasTimeoutId), void this._drawResults(null);
    if (this.dce && !this.dce.isOpen()) return this._clearResultsCanvasTimeoutId && clearTimeout(this._clearResultsCanvasTimeoutId), this._drawResults(null), void await this.clearMapDecodeRecord();
    if (!this.dce && !this._imgSource || this._bPauseScan) return _L._onLog && _L._onLog("Scan is paused, or imageSource is not set. Ask in 1s."), await this.clearMapDecodeRecord(), this._loopReadVideoTimeoutId && clearTimeout(this._loopReadVideoTimeoutId), void (this._loopReadVideoTimeoutId = setTimeout(() => {
      this._loopReadVideo();
    }, this._intervalDetectVideoPause));
    _L._onLog && _L._onLog("======= once read ======="), _L._onLog && (this._timeStartDecode = Date.now());
    let e2 = null, t2 = null;
    if (this.dce) e2 = this._getVideoFrame();
    else if (this._imgSource && (t2 = await this._imgSource.getImage(), !_L.isDSImage(t2))) throw new Error("Invalid DSImage.");
    if (!e2 && !t2) return _L._onLog && _L._onLog("Get invalid frame."), this._loopReadVideoTimeoutId && clearTimeout(this._loopReadVideoTimeoutId), void (this._loopReadVideoTimeoutId = setTimeout(() => {
      this._loopReadVideo();
    }, 0));
    (async () => {
      let i2 = [];
      if (e2) {
        i2 = await this._decode_DCEFrame(e2, { bScanner: true, bCopyData: false });
        let t3 = null;
        if (i2 && i2.length) {
          const { sx: s3, sy: a3, width: r3, height: o3, _sWidth: n3, _sHeight: c3 } = e2;
          t3 = i2.map((e3) => ({ resultState: e3.resultState, localizationResult: JSON.parse(JSON.stringify(e3.localizationResult)) })), _L.recalculateResultLocation(t3, s3, a3, n3, c3, r3, o3);
        }
        0 == this._resultHighlightingDuration ? this._drawResults(null) : this._drawResults(t3, i2), this._clearResultsCanvasTimeoutId && clearTimeout(this._clearResultsCanvasTimeoutId), this._resultHighlightingDuration > 0 && (this._clearResultsCanvasTimeoutId = setTimeout(() => {
          this.bDestroyed || this._drawResults(null);
        }, this._resultHighlightingDuration));
      } else t2 && (i2 = await this._decode_DSImage(t2, { bScanner: true, bCopyData: false }));
      return i2;
    })().then((e3) => {
      if (_L._onLog && _L._onLog(e3), this.dce && this.captureAndDecodeInParallel) {
        let e4 = this.array_decodeFrameTimeCost, t3 = this.array_getFrameTimeCost;
        const i2 = () => {
          let i3 = 0;
          if (t3 && t3.length) {
            let s3 = Math.min(...e4), a3 = Math.max(...t3);
            s3 && a3 && (i3 = s3 - a3);
          } else i3 = 0;
          return i3 > 0 ? i3 : 0;
        };
        (() => {
          for (; e4.length >= 5; ) e4.shift();
          e4.push(this._lastInnerDecodeDuration);
        })(), this._intervalGetVideoFrame = i2() + this.intervalTime;
      }
      if ((this.dce && this.dce.isOpen() || this._imgSource) && !this._bPauseScan) {
        if (this.bPlaySoundOnSuccessfulRead && e3.length) {
          let t3 = false;
          true === this.bPlaySoundOnSuccessfulRead || "frame" === this.bPlaySoundOnSuccessfulRead ? t3 = e3.some((e4) => e4.resultState >= 0) : "unique" === this.bPlaySoundOnSuccessfulRead && (t3 = e3.some((e4) => 0 == e4.resultState)), t3 && this.beepSound && (this.beepSound.stop(), this.beepSound.play());
        }
        if (navigator.vibrate && this.bVibrateOnSuccessfulRead && e3.length) {
          let t3 = false;
          if (true === this.bVibrateOnSuccessfulRead || "frame" === this.bVibrateOnSuccessfulRead ? t3 = e3.some((e4) => e4.resultState >= 0) : "unique" === this.bVibrateOnSuccessfulRead && (t3 = e3.some((e4) => 0 == e4.resultState)), t3) try {
            navigator.vibrate(this.vibrateDuration);
          } catch (e4) {
            console.warn("Vibration not allowed. User interaction required: " + (e4.message || e4));
          }
        }
        if (this.onImageRead) {
          e3 = e3.filter((e4) => e4.resultState >= 0);
          const t3 = this._cloneDecodeResults(e3);
          this.onImageRead(t3);
        }
        if (this.onUniqueRead) {
          e3 = e3.filter((e4) => 0 == e4.resultState);
          const t3 = this._cloneDecodeResults(e3);
          for (let e4 of t3) this.onUniqueRead(e4.barcodeText, e4);
        }
      }
      this._loopReadVideoTimeoutId && clearTimeout(this._loopReadVideoTimeoutId), this.intervalTime ? this._loopReadVideoTimeoutId = setTimeout(() => {
        this._loopReadVideo();
      }, this.intervalTime) : this._loopReadVideo();
    }).catch((e3) => {
      this.dce && this._dceControler && this._dceControler.setDisiredAction(this, "stopFetchingLoop"), _L._onLog && _L._onLog(e3.message || e3), this._loopReadVideoTimeoutId && clearTimeout(this._loopReadVideoTimeoutId), this._loopReadVideoTimeoutId = setTimeout(() => {
        this.dce && (this.dce.startFetchingLoop(), this._dceControler && this._dceControler.clearUserDisiredAction({ user: this, actionName: "stopFetchingLoop" })), this._loopReadVideo();
      }, Math.max(this.intervalTime, 1e3)), "platform error" == e3.message || console.warn(e3.message);
    });
  }
  _getVideoFrame() {
    if (!this.dce) return null;
    let e2;
    if (this.captureAndDecodeInParallel) {
      if (_L._onLog && _L._onLog("Get frame in parallel."), this._dceControler && this._dceControler.setDisiredValue(this, "loopInterval", this._intervalGetVideoFrame), !this.dce.numberOfFramesInBuffer) return this._dceControler && this._dceControler.setDisiredValue(this, "loopInterval", 0), null;
      e2 = this.dce.getFrameFromBuffer();
      const t2 = (e3) => {
        if (!e3) return;
        let t3 = e3.timeSpent, i2 = this.array_getFrameTimeCost;
        for (; i2.length >= 5; ) i2.shift();
        i2.push(t3);
      };
      t2(e2);
    } else _L._onLog && _L._onLog("Get frame in serial."), this._dceControler && this._dceControler.setDisiredAction(this, "stopFetchingLoop"), e2 = this.dce.getFrame();
    return e2;
  }
  _drawResults(e2, t2) {
    if (!this.dce || this.dce.disposed || this._bPauseScan || !this._drawingItemNamespace || !this._drawingItemNamespace.DT_Polygon) return;
    if (!this._dbrDrawingLayer) {
      if (!this.dce.isOpen()) return;
      if (!(this.dce.singleFrameMode || this.dce.video && this.dce._videoTrack)) return;
      const t3 = (e3) => this.dce.getDrawingLayers().some((t4) => t4.getId() === e3);
      if (!t3(3) && !(null == e2 ? void 0 : e2.length)) return;
      this._dbrDrawingLayer = this.dce.getDrawingLayer(3);
    }
    const i2 = this._dbrDrawingLayer;
    e2 || (e2 = []);
    let s3 = this._arrPolygons;
    for (let a3 = 0; a3 < e2.length; a3++) {
      let r3, o3 = e2[a3].localizationResult;
      s3[a3] ? (r3 = s3[a3], i2.hasDrawingItem(r3) || i2.addDrawingItem(r3), r3.set("vertices", [{ x: o3.x1, y: o3.y1 }, { x: o3.x2, y: o3.y2 }, { x: o3.x3, y: o3.y3 }, { x: o3.x4, y: o3.y4 }]), (r3.set || r3.setAttribute).call(r3, "vertices", [{ x: o3.x1, y: o3.y1 }, { x: o3.x2, y: o3.y2 }, { x: o3.x3, y: o3.y3 }, { x: o3.x4, y: o3.y4 }])) : (r3 = new this._drawingItemNamespace.DT_Polygon([{ x: o3.x1, y: o3.y1 }, { x: o3.x2, y: o3.y2 }, { x: o3.x3, y: o3.y3 }, { x: o3.x4, y: o3.y4 }]), i2.addDrawingItem(r3), s3[a3] = r3), -1 === e2[a3].resultState ? (r3.styleId = this._styleIdBeforeVerification, r3._mapStyle.set("default", this.dce.getDrawingStyle(this._styleIdBeforeVerification)), r3._mapStyle.set("selected", this.dce.getDrawingStyle(this._styleIdBeforeVerification))) : (r3.styleId = null, r3._mapStyle.set("default", this.dce.getDrawingStyle(3)), r3._mapStyle.set("selected", this.dce.getDrawingStyle(7))), t2 && t2[a3] ? r3.addNote({ name: "Barcode_Result", content: t2[a3] }, true) : r3.addNote({ name: "Barcode_Result", content: e2[a3] }, true);
    }
    for (let t3 = e2.length; t3 < s3.length; t3++) s3[t3].deleteNote("Barcode_Result"), i2.removeDrawingItem(s3[t3]);
    i2.renderAll();
  }
  async startScanning(e2) {
    if (!this.dce && !this._imgSource) throw new Error("'imageSource' is not set. call 'setImageSource()' before 'startScanning()'.");
    if (this._promiseStartScan && this._promiseStartScan.isPending) return this._promiseStartScan;
    this._promiseStartScan = new y2();
    let t2 = null;
    if (this.dce) {
      if (this.dce.isOpen()) if (e2 && this.dce.appendAndShowUI(), this.dce.playCallbackInfo) t2 = JSON.parse(JSON.stringify(this.dce.playCallbackInfo));
      else {
        const e3 = this.dce.getSelectedCamera();
        t2 = { width: this.dce.video.videoWidth, height: this.dce.video.videoHeight, deviceId: e3 && e3.deviceId };
      }
      else if (t2 = await this.dce.open(e2), !this._promiseStartScan) return null;
      this._dceControler && (this._dceControler.clearUserDisiredAction({ user: this, actionName: "close" }), this._dceControler.setDisiredValue(this, "ifShowScanRegionLaser", true), this.dce.ifShowScanRegionLaser && this.dce.showScanRegionLaser());
    }
    return this._bPauseScan = false, this.dce && this.dce.singleFrameMode || (this._loopReadVideoTimeoutId && clearTimeout(this._loopReadVideoTimeoutId), this._loopReadVideoTimeoutId = setTimeout(() => {
      this.dce && (this.dce.startFetchingLoop(), this._dceControler && this._dceControler.clearUserDisiredAction({ user: this, actionName: "stopFetchingLoop" })), this._loopReadVideo();
    }, 0)), this._promiseStartScan.resolve(t2), t2;
  }
  stopScanning(e2) {
    this.dce && (this._clearResultsCanvasTimeoutId && clearTimeout(this._clearResultsCanvasTimeoutId), this._drawResults(null), this._dceControler && (this._dceControler.setDisiredValue(this, "ifShowScanRegionLaser", false), this.dce.ifShowScanRegionLaser || this.dce.hideScanRegionLaser(), this._dceControler.setDisiredAction(this, "close", [e2]))), this._bPauseScan = true, this._loopReadVideoTimeoutId && clearTimeout(this._loopReadVideoTimeoutId), this.array_decodeFrameTimeCost.length = 0, this.array_getFrameTimeCost.length = 0, this._intervalGetVideoFrame = 0, this._promiseStartScan = null;
  }
  pauseScanning(e2) {
    if (this._clearResultsCanvasTimeoutId && clearTimeout(this._clearResultsCanvasTimeoutId), e2 && e2.keepResultsHighlighted || this._drawResults(null), this._bPauseScan = true, this.dce) {
      if (this.dce.singleFrameMode) throw new Error("'pauseScanning()' is unavailable when property 'singleFrameMode' of the 'CameraEnhancer' instance is true.");
      this._dceControler && (this._dceControler.setDisiredValue(this, "ifShowScanRegionLaser", false), this.dce.ifShowScanRegionLaser || this.dce.hideScanRegionLaser(), this._dceControler.setDisiredAction(this, "stopFetchingLoop"));
    }
  }
  resumeScanning() {
    if (this._bPauseScan = false, this.dce) {
      if (this.dce.singleFrameMode) throw new Error("'resumeScanning()' is unavailable when property 'singleFrameMode' of the 'CameraEnhancer' instance is true.");
      this.dce.startFetchingLoop(), this._dceControler && (this._dceControler.clearUserDisiredAction({ user: this, actionName: "stopFetchingLoop" }), this._dceControler.setDisiredValue(this, "ifShowScanRegionLaser", true), this.dce.ifShowScanRegionLaser && this.dce.showScanRegionLaser());
    }
  }
  destroyContext() {
    if (_L._onLog && _L._onLog("destroyContext()"), this.bDestroyed) return;
    this.bDestroyed = true, (this.dce || this._promiseStartScan) && this.stopScanning(), this.setImageSource(null);
    let e2 = _L._nextTaskID++;
    _L._taskCallbackMap.set(e2, (e3) => {
      if (!e3.success) {
        let t2 = new Error(e3.message);
        throw t2.stack = e3.stack + "\n" + t2.stack, t2;
      }
    }), _L._dbrWorker.postMessage({ type: "destroyContext", id: e2, instanceID: this._instanceID });
  }
};
function M2(e2, t2, i2) {
  return (i2.x - e2.x) * (t2.y - e2.y) == (t2.x - e2.x) * (i2.y - e2.y) && Math.min(e2.x, t2.x) <= i2.x && i2.x <= Math.max(e2.x, t2.x) && Math.min(e2.y, t2.y) <= i2.y && i2.y <= Math.max(e2.y, t2.y);
}
function O2(e2) {
  return Math.abs(e2) < 1e-6 ? 0 : e2 < 0 ? -1 : 1;
}
function w2(e2, t2, i2, s3) {
  let a3 = e2[0] * (i2[1] - t2[1]) + t2[0] * (e2[1] - i2[1]) + i2[0] * (t2[1] - e2[1]), r3 = e2[0] * (s3[1] - t2[1]) + t2[0] * (e2[1] - s3[1]) + s3[0] * (t2[1] - e2[1]);
  return !((a3 ^ r3) >= 0 && 0 !== a3 && 0 !== r3) && (a3 = i2[0] * (e2[1] - s3[1]) + s3[0] * (i2[1] - e2[1]) + e2[0] * (s3[1] - i2[1]), r3 = i2[0] * (t2[1] - s3[1]) + s3[0] * (i2[1] - t2[1]) + t2[0] * (s3[1] - i2[1]), !((a3 ^ r3) >= 0 && 0 !== a3 && 0 !== r3));
}
var F;
var B;
var N;
var b2;
var P;
var v2;
var V;
var x2;
var U;
var k;
var G;
var Z;
var W;
var H;
var K;
var J;
var Y;
var Q;
var X;
var z;
var j;
var q;
var $;
var ee;
var te;
var ie;
var se;
L2._jsVersion = "9.6.42", L2._jsEditVersion = "20240426", L2._version = `loading...(JS ${L2._jsVersion}.${L2._jsEditVersion})`, L2._license = R, L2._sessionPassword = I2, L2.browserInfo = d2, L2._workerName = `dbr-${L2._jsVersion}.browser.worker.js`, L2._engineResourcePath = g2, L2._licenseServer = [], L2._deviceFriendlyName = "", L2._isShowRelDecodeTimeInResults = false, L2._bWasmDebug = false, L2._bNeverShowDialog = false, L2.__bUseFullFeature = true, L2._nextTaskID = 0, L2._taskCallbackMap = /* @__PURE__ */ new Map(), L2._pLoad = new y2(), L2._lastErrorCode = 0, L2._lastErrorString = "", L2._setWarnnedEx = /* @__PURE__ */ new Set(), L2._defaultUIElementURL = "@engineResourcePath/dbr.ui.html", "function" == typeof SuppressedError && SuppressedError;
var ae = class _ae extends L2 {
  static set _onLog(e2) {
    !function(e3, t2, i2, s3, a3) {
      if ("m" === s3) throw new TypeError("Private method is not writable");
      if ("a" === s3 && !a3) throw new TypeError("Private accessor was defined without a setter");
      if ("function" == typeof t2 ? e3 !== t2 || !a3 : !t2.has(e3)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      "a" === s3 ? a3.call(e3, i2) : a3 ? a3.value = i2 : t2.set(e3, i2);
    }(_ae, F, e2, "f", B), I._onLog = e2;
  }
  static get _onLog() {
    return function(e2, t2, i2, s3) {
      if ("a" === i2 && !s3) throw new TypeError("Private accessor was defined without a getter");
      if ("function" == typeof t2 ? e2 !== t2 || !s3 : !t2.has(e2)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return "m" === i2 ? s3 : "a" === i2 ? s3.call(e2) : s3 ? s3.value : t2.get(e2);
    }(_ae, F, "f", B);
  }
  static get version() {
    return this._version + `(DCE ${I.getVersion()})`;
  }
  static _fireHTTPSWarnning() {
    _ae.onWarning && location && "https:" !== location.protocol && setTimeout(() => {
      _ae.onWarning && _ae.onWarning({ id: 2, message: "Not connected via SSL (HTTPS), the SDK may not work correctly." });
    }, 0);
  }
  static async testCameraAccess() {
    return I.testCameraAccess();
  }
  _fireResolutionWarning() {
    if (!this.singleFrameMode && this.onWarning && this.dce.isOpen()) {
      const e2 = this.dce.getConstraints();
      e2 && e2.width < 1280 && e2.height < 720 && setTimeout(() => {
        this.onWarning && this.onWarning({ id: 3, message: "Camera resolution too low, please use a higher resolution (720P or better)." });
      }, 0);
    }
  }
  getUIElement() {
    return this.dce.getUIElement();
  }
  async setUIElement(e2) {
    await this.dce.setUIElement(e2);
  }
  get singleFrameMode() {
    return this.dce.singleFrameMode;
  }
  set singleFrameMode(e2) {
    if ("boolean" != typeof e2 && !["image", "camera"].includes(e2)) throw new Error("Invalid value.");
    this.dce.singleFrameMode = e2, e2 && (this.dce.ifShowScanRegionLaser = false, (async () => {
      let e3 = await this.getScanSettings();
      e3.oneDTrustFrameCount = 1, await this.updateScanSettings(e3);
    })());
  }
  get onUnduplicatedRead() {
    return this.onUniqueRead;
  }
  set onUnduplicatedRead(e2) {
    this.onUniqueRead = e2;
  }
  get video() {
    return this.dce && this.dce.video;
  }
  set videoSrc(e2) {
    this.dce && (this.dce.videoSrc = e2);
  }
  get videoSrc() {
    return this.dce && this.dce.videoSrc;
  }
  set cameraOpenTimeout(e2) {
    this.dce && (this.dce.cameraOpenTimeout = e2);
  }
  get cameraOpenTimeout() {
    return this.dce && this.dce.cameraOpenTimeout;
  }
  set onTipSuggested(e2) {
    this.dce && (this.dce.onTipSuggested = e2);
  }
  get onTipSuggested() {
    return this.dce && this.dce.onTipSuggested;
  }
  _assertOpen() {
    if (!this.dce.isOpen()) throw Error("The scanner is not open.");
  }
  set barcodeFillStyle(e2) {
    this._barcodeFillStyle = e2, this.dce && this.dce.updateDrawingStyle(3, { fillStyle: e2 });
  }
  get barcodeFillStyle() {
    return this._barcodeFillStyle;
  }
  set barcodeStrokeStyle(e2) {
    this._barcodeStrokeStyle = e2, this.dce && this.dce.updateDrawingStyle(3, { strokeStyle: e2 });
  }
  get barcodeStrokeStyle() {
    return this._barcodeStrokeStyle;
  }
  set barcodeLineWidth(e2) {
    this._barcodeLineWidth = e2, this.dce && this.dce.updateDrawingStyle(3, { lineWidth: e2 });
  }
  get barcodeLineWidth() {
    return this._barcodeLineWidth;
  }
  set barcodeFillStyleBeforeVerification(e2) {
    this._barcodeFillStyleBeforeVerification = e2, this._styleIdBeforeVerification && this.dce.updateDrawingStyle(this._styleIdBeforeVerification, { fillStyle: e2 });
  }
  get barcodeFillStyleBeforeVerification() {
    return this._barcodeFillStyleBeforeVerification;
  }
  set barcodeStrokeStyleBeforeVerification(e2) {
    this._barcodeStrokeStyleBeforeVerification = e2, this._styleIdBeforeVerification && this.dce.updateDrawingStyle(this._styleIdBeforeVerification, { strokeStyle: e2 });
  }
  get barcodeStrokeStyleBeforeVerification() {
    return this._barcodeStrokeStyleBeforeVerification;
  }
  set barcodeLineWidthBeforeVerification(e2) {
    this._barcodeLineWidthBeforeVerification = e2, this._styleIdBeforeVerification && this.dce.updateDrawingStyle(this._styleIdBeforeVerification, { lineWidth: e2 });
  }
  get barcodeLineWidthBeforeVerification() {
    return this._barcodeLineWidthBeforeVerification;
  }
  set regionMaskFillStyle(e2) {
    this.dce.setScanRegionMaskStyle({ fillStyle: e2 });
  }
  get regionMaskFillStyle() {
    return this.dce.regionMaskFillStyle;
  }
  set regionMaskStrokeStyle(e2) {
    this.dce.setScanRegionMaskStyle({ strokeStyle: e2 });
  }
  get regionMaskStrokeStyle() {
    return this.dce.regionMaskStrokeStyle;
  }
  set regionMaskLineWidth(e2) {
    this.dce.setScanRegionMaskStyle({ lineWidth: e2 });
  }
  get regionMaskLineWidth() {
    return this.dce.regionMaskLineWidth;
  }
  set region(e2) {
    this._region = e2, this.dce && (e2 ? e2 instanceof Array || this.dce.setScanRegion(e2) : this.dce.setScanRegion(null)), this.array_decodeFrameTimeCost.length = 0, this.array_getFrameTimeCost.length = 0, this._intervalGetVideoFrame = 0;
  }
  get region() {
    return this._region;
  }
  set ifSaveOriginalImageInACanvas(e2) {
    this._ifSaveOriginalImageInACanvas = e2, this.dce.framePixelFormat = e2 ? "rgba" : "grey";
  }
  get ifSaveOriginalImageInACanvas() {
    return this._ifSaveOriginalImageInACanvas;
  }
  async createDCEInstance() {
    this.dce || (L2._onLog && L2._onLog("createDCEInstance()"), I.defaultUIElementURL = null, this.dce = await I.createInstance(), this.dce.cameraOpenTimeout < 15e3 && (this.dce.cameraOpenTimeout = 15e3), this.dce.refreshInterval = 200, this.dce.framePixelFormat = "grey", this.dce.maxCvsSideLength = this.maxCvsSideLength, this._drawingItemNamespace = L, ["iPhone", "iPad", "Android", "HarmonyOS"].includes(L2.browserInfo.OS) || this.dce.setResolution(1920, 1080), this._styleIdBeforeVerification = this.dce.createDrawingStyle({ fillStyle: "rgba(248,252,0,0.2)", strokeStyle: "transparent", paintMode: "strokeAndFill" }), this.barcodeLineWidth = this._barcodeLineWidth, this.dce.on("cameraChange", () => {
      this._clearResultsCanvasTimeoutId && clearTimeout(this._clearResultsCanvasTimeoutId), this._drawResults(null), this.array_decodeFrameTimeCost.length = 0, this.array_getFrameTimeCost.length = 0, this._intervalGetVideoFrame = 0;
    }), this.dce.on("resolutionChange", () => {
      this._clearResultsCanvasTimeoutId && clearTimeout(this._clearResultsCanvasTimeoutId), this._drawResults(null), this.array_decodeFrameTimeCost.length = 0, this.array_getFrameTimeCost.length = 0, this._intervalGetVideoFrame = 0;
    }), this.dce.on("cameraClose", () => {
      this._clearResultsCanvasTimeoutId && clearTimeout(this._clearResultsCanvasTimeoutId), this._drawResults(null), this.array_decodeFrameTimeCost.length = 0, this.array_getFrameTimeCost.length = 0, this._intervalGetVideoFrame = 0, this._bPauseScan = false;
    }), this.dce.on("singleFrameAcquired", async (e2) => {
      if (!e2) return;
      if (!e2.data) return;
      let t2;
      this._clearResultsCanvasTimeoutId && clearTimeout(this._clearResultsCanvasTimeoutId), this._drawResults(null), this.ifSaveOriginalImageInACanvas && (this.oriCanvas = null, this.oriCanvasData = { width: e2.width, height: e2.height, pixelFormat: e2.pixelFormat, data: new Uint8Array(e2.data), toCanvas: e2.toCanvas });
      const { data: i2, sx: s3, sy: a3, width: r3, height: o3, stride: n3, pixelFormat: c3, timeStamp: d3, _sWidth: l3, _sHeight: h3 } = e2, _3 = { timeStamp: d3 };
      if ("grey" === c3) t2 = await this._decodeBuffer_Uint8Array(i2, r3, o3, n3, E2.IPF_GrayScaled, 0, _3);
      else if ("rgba" === c3) t2 = await this._decodeBuffer_Uint8Array(i2, r3, o3, n3, E2.IPF_ABGR_8888, 0, _3);
      else {
        if ("bgra" !== c3) throw new Error(`Pixel format '${c3}' is not supported.`);
        t2 = await this._decodeBuffer_Uint8Array(i2, r3, o3, n3, E2.IPF_ARGB_8888, 0, _3);
      }
      if (await this.clearMapDecodeRecord(), L2.recalculateResultLocation(t2, s3, a3, l3, h3, r3, o3), this._drawResults(t2), this.onFrameRead && this.isOpen() && !this._bPauseScan) {
        let e3 = this._cloneDecodeResults(t2);
        this.onFrameRead(e3);
      }
      if (this.onUniqueRead && this.isOpen() && !this._bPauseScan) for (let e3 of t2) this.onUniqueRead(e3.barcodeText, this._cloneDecodeResults(e3));
    }));
  }
  set maxCvsSideLength(e2) {
    this._maxCvsSideLength = e2, this.dce.maxCvsSideLength = e2;
  }
  get maxCvsSideLength() {
    return this._maxCvsSideLength;
  }
  constructor() {
    super(), this._barcodeFillStyle = "rgba(254,180,32,0.3)", this._barcodeStrokeStyle = "rgba(254,180,32,0.9)", this._barcodeLineWidth = 1, this._barcodeFillStyleBeforeVerification = "rgba(248,252,0,0.2)", this._barcodeStrokeStyleBeforeVerification = "transparent", this._barcodeLineWidthBeforeVerification = 2, this.bFilterRegionInJs = true, this._onPlayed = null;
  }
  static async createInstance(e2) {
    const t2 = new _ae();
    t2._instanceID = await _ae.createInstanceInWorker(true), await t2.createDCEInstance(), "string" == typeof e2 && (e2 = JSON.parse(e2));
    for (let i2 in e2) t2[i2] = e2[i2];
    return await t2.dce.setUIElement(_ae.defaultUIElementURL), t2.singleFrameMode && console.warn("The `navigator.mediaDevices.getUserMedia` is unavailable. automatically change to `singleFrameMode`."), _ae._fireHTTPSWarnning(), t2.singleFrameMode || await t2.updateRuntimeSettings("single"), t2;
  }
  async decodeCurrentFrame(e2) {
    this._assertOpen();
    let t2 = null;
    e2 && e2.region && (t2 = e2.region);
    const i2 = this.dce._getVideoData(null, { region: t2 });
    return this._decode_DCEFrame(i2);
  }
  async updateRuntimeSettings(e2) {
    let t2;
    if ("string" == typeof e2) if ("speed" == e2) {
      let e3 = await this.getRuntimeSettings();
      await this.resetRuntimeSettings(), t2 = await this.getRuntimeSettings(), t2.barcodeFormatIds = e3.barcodeFormatIds, t2.barcodeFormatIds_2 = e3.barcodeFormatIds_2, e3.region && (t2.region = e3.region), t2.expectedBarcodesCount = 0, t2.localizationModes = [2, 0, 0, 0, 0, 0, 0, 0], t2.barcodeZoneMinDistanceToImageBorders = 9;
    } else if ("balance" == e2) {
      let e3 = await this.getRuntimeSettings();
      await this.resetRuntimeSettings(), t2 = await this.getRuntimeSettings(), t2.barcodeFormatIds = e3.barcodeFormatIds, t2.barcodeFormatIds_2 = e3.barcodeFormatIds_2, e3.region && (t2.region = e3.region), t2.expectedBarcodesCount = 512, t2.deblurLevel = 3, t2.localizationModes = [2, 16, 0, 0, 0, 0, 0, 0], t2.barcodeZoneMinDistanceToImageBorders = 9, t2.timeout = 1e5;
    } else if ("coverage" == e2) {
      let e3 = await this.getRuntimeSettings();
      await this.resetRuntimeSettings(), t2 = await this.getRuntimeSettings(), t2.barcodeFormatIds = e3.barcodeFormatIds, t2.barcodeFormatIds_2 = e3.barcodeFormatIds_2, e3.region && (t2.region = e3.region), t2.expectedBarcodesCount = 512, t2.deblurLevel = 5, t2.scaleDownThreshold = 1e5, t2.localizationModes = [2, 16, 4, 8, 0, 0, 0, 0], t2.barcodeZoneMinDistanceToImageBorders = 9, t2.timeout = 1e5;
    } else if ("single" == e2) {
      let e3 = await this.getRuntimeSettings();
      await this.resetRuntimeSettings(), t2 = await this.getRuntimeSettings(), t2.barcodeFormatIds = e3.barcodeFormatIds, t2.barcodeFormatIds_2 = e3.barcodeFormatIds_2, e3.region && (t2.region = e3.region);
    } else if ("dense" == e2) {
      let e3 = await this.getRuntimeSettings();
      await this.resetRuntimeSettings(), this.maxCvsSideLength = 4096, t2 = await this.getRuntimeSettings(), t2.barcodeFormatIds = e3.barcodeFormatIds, t2.barcodeFormatIds_2 = e3.barcodeFormatIds_2, e3.region && (t2.region = e3.region), t2.expectedBarcodesCount = 0, t2.deblurLevel = 7, t2.scaleDownThreshold = 1e5, t2.localizationModes = [2, 8, 0, 0, 0, 0, 0, 0], t2.minResultConfidence = 0, t2.barcodeZoneMinDistanceToImageBorders = 9, t2.timeout = 1e5;
    } else if ("distance" == e2) {
      let e3 = await this.getRuntimeSettings();
      await this.resetRuntimeSettings(), this.maxCvsSideLength = 4096, t2 = await this.getRuntimeSettings(), t2.barcodeFormatIds = e3.barcodeFormatIds, t2.barcodeFormatIds_2 = e3.barcodeFormatIds_2, e3.region && (t2.region = e3.region), t2.expectedBarcodesCount = 0, t2.scaleDownThreshold = 1e5, t2.localizationModes = [2, 8, 0, 0, 0, 0, 0, 0], t2.barcodeZoneMinDistanceToImageBorders = 9, t2.timeout = 1e5;
    } else t2 = JSON.parse(e2);
    else {
      if ("object" != typeof e2) throw TypeError("'UpdateRuntimeSettings(settings)': Type of 'settings' should be 'string' or 'PlainObject'.");
      if (t2 = JSON.parse(JSON.stringify(e2)), t2.region instanceof Array) {
        let i2 = e2.region;
        [i2.regionLeft, i2.regionTop, i2.regionLeft, i2.regionBottom, i2.regionMeasuredByPercentage].some((e3) => void 0 !== e3) && (t2.region = { regionLeft: i2.regionLeft || 0, regionTop: i2.regionTop || 0, regionRight: i2.regionRight || 0, regionBottom: i2.regionBottom || 0, regionMeasuredByPercentage: i2.regionMeasuredByPercentage || 0 });
      }
    }
    if (!L2._bUseFullFeature) {
      if (t2.barcodeFormatIds & ~(T2.BF_ONED | T2.BF_QR_CODE | T2.BF_PDF417 | T2.BF_DATAMATRIX) || 0 != t2.barcodeFormatIds_2) throw Error("Some of the specified barcode formats are not supported in the compact version. Please try the full-featured version.");
      if (0 != t2.intermediateResultTypes) throw Error("Intermediate results is not supported in the compact version. Please try the full-featured version.");
    }
    {
      let e3 = t2.region;
      if (this.bFilterRegionInJs ? this.userDefinedRegion = JSON.parse(JSON.stringify(e3)) : this.userDefinedRegion = null, e3 instanceof Array) if (e3.length) {
        for (let t3 = 0; t3 < e3.length; ++t3) {
          let i2 = e3[t3];
          i2 && ((i2.regionLeft || i2.regionTop || i2.regionRight || i2.regionBottom || i2.regionMeasuredByPercentage) && (i2.regionLeft || i2.regionTop || 100 != i2.regionRight || 100 != i2.regionBottom || !i2.regionMeasuredByPercentage) || (e3[t3] = null));
        }
        this.region = e3;
      } else this.region = null;
      else e3 && (e3.regionLeft || e3.regionTop || e3.regionRight || e3.regionBottom || e3.regionMeasuredByPercentage) && (e3.regionLeft || e3.regionTop || 100 != e3.regionRight || 100 != e3.regionBottom || !e3.regionMeasuredByPercentage) ? this.region = e3 : this.region = null;
      this.bFilterRegionInJs && (t2.region = { regionLeft: 0, regionTop: 0, regionRight: 0, regionBottom: 0, regionMeasuredByPercentage: 0 });
    }
    (this.autoZoom || this.autoFocus) && (t2.intermediateResultTypes |= D2.IRT_TYPED_BARCODE_ZONE), await new Promise((e3, i2) => {
      let s3 = L2._nextTaskID++;
      L2._taskCallbackMap.set(s3, (t3) => {
        if (t3.success) {
          try {
            this._handleRetJsonString(t3.updateReturn);
          } catch (e4) {
            i2(e4);
          }
          return e3();
        }
        {
          let e4 = new Error(t3.message);
          return e4.stack = t3.stack + "\n" + e4.stack, i2(e4);
        }
      }), L2._dbrWorker.postMessage({ type: "updateRuntimeSettings", id: s3, instanceID: this._instanceID, body: { settings: JSON.stringify(t2) } });
    }), "string" == typeof e2 && ["speed", "balance", "coverage", "dense", "distance"].includes(e2) && (await this.setModeArgument("BinarizationModes", 0, "EnableFillBinaryVacancy", "1"), await this.setModeArgument("BinarizationModes", 0, "BlockSizeX", "0"), await this.setModeArgument("BinarizationModes", 0, "BlockSizeY", "0"));
  }
  _bindUI() {
    if (!this.getUIElement()) throw new Error("Need to define `UIElement` before opening.");
    if (this.dce._bindUI(), !this.dce.video) throw this._unbindUI(), Error("Can not find the video container element with class 'dce-video-container'");
  }
  _unbindUI() {
    this.dce._unbindUI();
  }
  set onPlayed(e2) {
    this.dce.off("played", this._onPlayed), this._onPlayed = e2, this.dce.on("played", this._onPlayed);
  }
  get onPlayed() {
    return this._onPlayed;
  }
  async getAllCameras() {
    return this.dce.getAllCameras();
  }
  async getCurrentCamera() {
    return this.dce.getSelectedCamera();
  }
  async setCurrentCamera(e2) {
    const t2 = await this.dce.selectCamera(e2);
    return this._fireResolutionWarning(), t2;
  }
  getResolution() {
    return this.dce.getResolution();
  }
  async setResolution(e2, t2) {
    const i2 = await this.dce.setResolution(e2, t2);
    return this._fireResolutionWarning(), i2;
  }
  getVideoSettings() {
    return this.dce.getVideoSettings();
  }
  updateVideoSettings(e2) {
    return this.dce.updateVideoSettings(e2);
  }
  isOpen() {
    return this.dce && this.dce.isOpen();
  }
  setVideoFit(e2) {
    return this.dce && this.dce.setVideoFit(e2);
  }
  getVideoFit() {
    return this.dce && this.dce.getVideoFit();
  }
  set ifShowScanRegionMask(e2) {
    this.dce && (this.dce.ifShowScanRegionMask = e2);
  }
  get ifShowScanRegionMask() {
    return this.dce && this.dce.ifShowScanRegionMask;
  }
  set ifSaveLastUsedCamera(e2) {
    this.dce && (this.dce.ifSaveLastUsedCamera = e2);
  }
  get ifSaveLastUsedCamera() {
    return this.dce && this.dce.ifSaveLastUsedCamera;
  }
  set ifSkipCameraInspection(e2) {
    this.dce && (this.dce.ifSkipCameraInspection = e2);
  }
  get ifSkipCameraInspection() {
    return this.dce && this.dce.ifSkipCameraInspection;
  }
  stop() {
    this._clearResultsCanvasTimeoutId && clearTimeout(this._clearResultsCanvasTimeoutId), this._drawResults(null), this.dce.stop(), this.dce.ifShowScanRegionLaser = false, this.dce.hideViewDecorator(), this.array_decodeFrameTimeCost.length = 0, this.array_getFrameTimeCost.length = 0, this._intervalGetVideoFrame = 0;
  }
  pause() {
    this.dce.pause();
  }
  async play(e2, t2, i2) {
    this.dce.ifShowScanRegionLaser = true;
    const s3 = await this.dce.play(e2, t2, i2);
    return this._fireResolutionWarning(), s3;
  }
  pauseScan(e2) {
    this._assertOpen(), this._clearResultsCanvasTimeoutId && clearTimeout(this._clearResultsCanvasTimeoutId), e2 && e2.keepResultsHighlighted || this._drawResults(null), this._bPauseScan = true, this.dce.ifShowScanRegionLaser = false, this.dce.stopFetchingLoop();
  }
  resumeScan() {
    this._assertOpen(), this._bPauseScan = false, this.dce.ifShowScanRegionLaser = true;
  }
  getCapabilities() {
    return this.dce.getCapabilities();
  }
  getCameraSettings() {
    return this.dce.getCameraSettings();
  }
  getConstraints() {
    return this.dce.getConstraints();
  }
  async applyConstraints(e2) {
    return this.dce.applyConstraints(e2);
  }
  async turnOnTorch() {
    return this.dce.turnOnTorch();
  }
  async turnOffTorch() {
    return this.dce.turnOffTorch();
  }
  async setColorTemperature(e2) {
    return this.dce.setColorTemperature(e2);
  }
  getColorTemperature() {
    return this.dce.getColorTemperature();
  }
  async setExposureCompensation(e2) {
    return this.dce.setExposureCompensation(e2);
  }
  getExposureCompensation() {
    return this.dce.getExposureCompensation();
  }
  async setZoom(e2) {
    return this.dce.setZoom(e2);
  }
  getZoomSettings() {
    return this.dce.getZoomSettings();
  }
  resetZoom() {
    return this.dce.resetZoom();
  }
  async setFrameRate(e2) {
    return this.dce.setFrameRate(e2);
  }
  getFrameRate() {
    return this.dce.getFrameRate();
  }
  async setFocus(e2, t2) {
    return this.dce.setFocus(e2, t2);
  }
  getFocus() {
    return this.dce.getFocus();
  }
  getFocusSettings() {
    return this.dce.getFocusSettings();
  }
  async _loopReadVideo() {
    if (this.bDestroyed) return this.dce && this.dce.stopFetchingLoop(), this._clearResultsCanvasTimeoutId && clearTimeout(this._clearResultsCanvasTimeoutId), void this._drawResults(null);
    if (!this.isOpen()) return this._clearResultsCanvasTimeoutId && clearTimeout(this._clearResultsCanvasTimeoutId), this._drawResults(null), void await this.clearMapDecodeRecord();
    if (!this.dce.video || this.dce.video.paused || this._bPauseScan) return L2._onLog && L2._onLog("Video or scan is paused. Ask in 1s."), await this.clearMapDecodeRecord(), this._loopReadVideoTimeoutId && clearTimeout(this._loopReadVideoTimeoutId), void (this._loopReadVideoTimeoutId = setTimeout(() => {
      this._loopReadVideo();
    }, this._intervalDetectVideoPause));
    L2._onLog && L2._onLog("======= once read ======="), L2._onLog && (this._timeStartDecode = Date.now());
    const e2 = this._getVideoFrame();
    if (!e2) return L2._onLog && L2._onLog("Get invalid frame."), this._clearResultsCanvasTimeoutId && clearTimeout(this._clearResultsCanvasTimeoutId), this._drawResults(null), this._loopReadVideoTimeoutId && clearTimeout(this._loopReadVideoTimeoutId), void (this._loopReadVideoTimeoutId = setTimeout(() => {
      this._loopReadVideo();
    }, 0));
    (async () => {
      e2._bUseWebGL || "grey" !== e2.pixelFormat || (this.dce.framePixelFormat = "rgba");
      let t2 = [];
      this.ifSaveOriginalImageInACanvas && (this.oriCanvas = null, this.oriCanvasData = { width: e2.width, height: e2.height, pixelFormat: e2.pixelFormat, data: new Uint8Array(e2.data), toCanvas: e2.toCanvas });
      const { data: i2, sx: s3, sy: a3, width: r3, height: o3, stride: n3, pixelFormat: c3, timeStamp: d3, _sWidth: l3, _sHeight: h3 } = e2, _3 = { timeStamp: d3 };
      if ("grey" === c3) t2 = await this._decodeBuffer_Uint8Array(i2, r3, o3, n3, E2.IPF_GrayScaled, 0, _3);
      else if ("rgba" === c3) t2 = await this._decodeBuffer_Uint8Array(i2, r3, o3, n3, E2.IPF_ABGR_8888, 0, _3);
      else {
        if ("bgra" !== c3) throw new Error(`Pixel format '${c3}' is not supported.`);
        t2 = await this._decodeBuffer_Uint8Array(i2, r3, o3, n3, E2.IPF_ARGB_8888, 0, _3);
      }
      if (L2.recalculateResultLocation(t2, s3, a3, l3, h3, r3, o3), 0 == this._resultHighlightingDuration ? this._drawResults(null) : this._drawResults(t2), this._clearResultsCanvasTimeoutId && clearTimeout(this._clearResultsCanvasTimeoutId), this._resultHighlightingDuration > 0 && (this._clearResultsCanvasTimeoutId = setTimeout(() => {
        this.bDestroyed || this._drawResults(null);
      }, this._resultHighlightingDuration)), this.isOpen() && this.dce.video && !this.dce.video.paused && !this._bPauseScan && (this.autoZoom || this.autoFocus || this.autoSuggestTip)) if (t2.length) this.autoZoomInFrameArray.length = 0, this.autoZoomOutFrameCount = 0, this.frameArrayInIdealZoom.length = 0, this.suggestTipFrameArray.length = 0, this.autoZoom && this.autoFocus && (this.nextActionInIdealZoom = "focus"), this.autoFocusFrameArray.length = 0, this.noIntermediateResultsCount = 0;
      else {
        const e3 = async () => new Promise((e4, t4) => {
          let i4 = L2._nextTaskID++;
          L2._taskCallbackMap.set(i4, (i5) => {
            if (i5.success) return e4(i5.results);
            {
              let e5 = new Error(i5.message);
              return e5.stack = i5.stack + "\n" + e5.stack, t4(e5);
            }
          }), L2._dbrWorker.postMessage({ type: "getIntermediateResults", id: i4, instanceID: this._instanceID, body: { isCharge: false } });
        }), t3 = await e3(), i3 = (e4, t4, i4, s4, a4, r4, o4) => {
          let n5 = r4 / s4, c5 = o4 / a4;
          e4.x1 = e4.x1 / n5 + t4, e4.x2 = e4.x2 / n5 + t4, e4.x3 = e4.x3 / n5 + t4, e4.x4 = e4.x4 / n5 + t4, e4.y1 = e4.y1 / c5 + i4, e4.y2 = e4.y2 / c5 + i4, e4.y3 = e4.y3 / c5 + i4, e4.y4 = e4.y4 / c5 + i4;
        }, n4 = (e4) => {
          if (!e4) return null;
          const t4 = {};
          let n5, c5, d4, _4, u3;
          {
            const e5 = this.video.videoWidth * (1 - this.autoZoomDetectionArea) / 2, t5 = this.video.videoWidth * (1 + this.autoZoomDetectionArea) / 2, i4 = t5, s4 = e5, a4 = this.video.videoHeight * (1 - this.autoZoomDetectionArea) / 2, r4 = a4, o4 = this.video.videoHeight * (1 + this.autoZoomDetectionArea) / 2;
            u3 = { x1: e5, x2: t5, x3: i4, x4: s4, y1: a4, y2: r4, y3: o4, y4: o4 };
          }
          const g3 = (e5, t5) => {
            const i4 = (e6, t6) => {
              if (!e6 && !t6) throw new Error("Invalid arguments.");
              return function(e7, t7, i5) {
                let s5 = false;
                const a4 = e7.length;
                if (a4 <= 2) return false;
                for (let r4 = 0; r4 < a4; r4++) {
                  const o4 = e7[r4], n6 = e7[(r4 + 1) % a4];
                  if (M2(o4, n6, { x: t7, y: i5 })) return true;
                  O2(o4.y - i5) > 0 != O2(n6.y - i5) > 0 && O2(t7 - (i5 - o4.y) * (o4.x - n6.x) / (o4.y - n6.y) - o4.x) < 0 && (s5 = !s5);
                }
                return s5;
              }([{ x: t6.x1, y: t6.y1 }, { x: t6.x2, y: t6.y2 }, { x: t6.x3, y: t6.y3 }, { x: t6.x4, y: t6.y4 }], e6.x, e6.y);
            }, s4 = (e6, t6) => !!(w2([e6[0], e6[1]], [e6[2], e6[3]], [t6.x1, t6.y1], [t6.x2, t6.y2]) || w2([e6[0], e6[1]], [e6[2], e6[3]], [t6.x2, t6.y2], [t6.x3, t6.y3]) || w2([e6[0], e6[1]], [e6[2], e6[3]], [t6.x3, t6.y3], [t6.x4, t6.y4]) || w2([e6[0], e6[1]], [e6[2], e6[3]], [t6.x4, t6.y4], [t6.x1, t6.y1]));
            return !!(i4({ x: e5.x1, y: e5.y1 }, t5) || i4({ x: e5.x2, y: e5.y2 }, t5) || i4({ x: e5.x3, y: e5.y3 }, t5) || i4({ x: e5.x4, y: e5.y4 }, t5)) || (!!(i4({ x: t5.x1, y: t5.y1 }, e5) || i4({ x: t5.x2, y: t5.y2 }, e5) || i4({ x: t5.x3, y: t5.y3 }, e5) || i4({ x: t5.x4, y: t5.y4 }, e5)) || !!(s4([t5.x1, t5.y1, t5.x2, t5.y2], e5) || s4([t5.x2, t5.y2, t5.x3, t5.y3], e5) || s4([t5.x3, t5.y3, t5.x4, t5.y4], e5) || s4([t5.x4, t5.y4, t5.x1, t5.y1], e5)));
          }, m3 = [];
          for (let t5 of e4) {
            if (t5.resultType !== D2.IRT_TYPED_BARCODE_ZONE) continue;
            const e5 = t5.scaleDownRatio;
            for (let n6 of t5.results) {
              if (!n6) continue;
              const t6 = { x1: n6.x1 = n6.x1 * e5, x2: n6.x2 = n6.x2 * e5, x3: n6.x3 = n6.x3 * e5, x4: n6.x4 = n6.x4 * e5, y1: n6.y1 = n6.y1 * e5, y2: n6.y2 = n6.y2 * e5, y3: n6.y4 = n6.y3 * e5, y4: n6.y4 = n6.y4 * e5 };
              i3(t6, s3, a3, l3, h3, r3, o3), g3(u3, t6) && m3.push(n6);
            }
          }
          const R2 = ((e5) => {
            if (!e5 || !e5.length) return null;
            const t5 = (e6) => {
              const t6 = (e6.x1 + e6.x2 + e6.x3 + e6.x4) / 4, i5 = (e6.y1 + e6.y2 + e6.y3 + e6.y4) / 4;
              return (t6 - r3 / 2) * (t6 - r3 / 2) + (i5 - o3 / 2) * (i5 - o3 / 2);
            };
            let i4, s4 = e5.filter((e6) => e6.barcodeFormat == T2.BF_QR_CODE || e6.barcodeFormat == T2.BF_DATAMATRIX);
            if (s4.length || (s4 = e5.filter((e6) => e6.barcodeFormat == T2.BF_ONED), s4.length || (s4 = e5)), !s4.length) return null;
            i4 = s4[0];
            let a4 = t5(i4);
            if (1 != s4.length) for (let e6 = 1; e6 < s4.length; e6++) {
              const r4 = t5(s4[e6]);
              s4[e6].confidence > 1.1 * i4.confidence ? (i4 = s4[e6], a4 = r4) : s4[e6].confidence > 0.9 * i4.confidence && r4 < a4 && (i4 = s4[e6], a4 = r4);
            }
            return i4;
          })(m3);
          if (!R2) return null;
          const I3 = R2.x1, S3 = R2.x2, E3 = R2.x3, A2 = R2.x4, f3 = R2.y1, C3 = R2.y2, y3 = R2.y3, p3 = R2.y4;
          return n5 = Math.min(I3, S3, E3, A2), c5 = Math.max(I3, S3, E3, A2), d4 = Math.min(f3, C3, y3, p3), _4 = Math.max(f3, C3, y3, p3), t4.x1 = t4.x4 = n5, t4.x2 = t4.x3 = c5, t4.y1 = t4.y2 = d4, t4.y3 = t4.y4 = _4, t4.result = R2, t4;
        }, c4 = n4(t3);
        if (c4 && c4.x1) {
          if (this.autoZoomOutFrameCount = 0, this.noIntermediateResultsCount = 0, this.suggestTipFrameArray.push(true), this.suggestTipFrameArray.splice(0, this.suggestTipFrameArray.length - this.suggestTipFrameLimit[0]), this.autoSuggestTip && this.suggestTipFrameArray.filter((e4) => true === e4).length >= this.suggestTipFrameLimit[1]) {
            this.suggestTipFrameArray.length = 0;
            const e4 = c4.x3 - c4.x1, t4 = c4.y3 - c4.y1;
            c4.result.moduleSize < this.tinyBarcodeTipModuleSizeLimit ? this.dce && this.dce.suggestTip("tiny-barcode", "Please zoom in or move closer.") : e4 > t4 ? e4 > r3 * this.hugeBarcodeTipLimit ? this.dce && this.dce.suggestTip("huge-barcode", "Please zoom out or move farther.") : e4 > 0.6 * r3 && Math.max(this.video.videoWidth, this.video.videoHeight) <= 1280 && Math.min(this.video.videoWidth, this.video.videoHeight) <= 720 && this.dce && this.dce.suggestTip("low-resolution", "Please use a higher resolution.") : e4 <= t4 && (t4 > o3 * this.hugeBarcodeTipLimit ? this.dce && this.dce.suggestTip("huge-barcode", "Please zoom out or move farther.") : t4 > 0.6 * o3 && Math.max(this.video.videoWidth, this.video.videoHeight) <= 1280 && Math.min(this.video.videoWidth, this.video.videoHeight) <= 720 && this.dce && this.dce.suggestTip("low-resolution", "Please use a higher resolution."));
          }
          if (this.autoZoom) {
            const e4 = this.autoZoomIdealArea[1];
            let t4 = (1 - this.autoZoomTargetBorder) / 2;
            const n5 = c4.x1 / l3, d4 = (l3 - c4.x3) / l3, _4 = c4.y1 / h3, u3 = (h3 - c4.y3) / h3;
            if (n5 > e4 && d4 > e4 && _4 > e4 && u3 > e4 && c4.result.moduleSize < this.autoZoomInIdealModuleSize) {
              if (this.autoZoomInFrameArray.push(true), this.autoZoomInFrameArray.splice(0, this.autoZoomInFrameArray.length - this.autoZoomInFrameLimit[0]), this.frameArrayInIdealZoom.length = 0, this.autoFocus && (this.nextActionInIdealZoom = "focus", this.setFocus({ mode: "continuous" }).catch(() => {
              })), this.autoZoomInFrameArray.filter((e5) => true === e5).length >= this.autoZoomInFrameLimit[1]) {
                this.autoZoomInFrameArray.length = 0;
                const e5 = [(0.5 - t4) / (0.5 - n5), (0.5 - t4) / (0.5 - d4), (0.5 - t4) / (0.5 - _4), (0.5 - t4) / (0.5 - u3)].filter((e6) => e6 > 0), i4 = Math.min(...e5, this.autoZoomInIdealModuleSize / c4.result.moduleSize), s4 = this.dce.getZoomSettings().factor;
                let a4 = Math.max(Math.pow(s4 * i4, 1 / this.autoZoomInMaxTimes), this.autoZoomInMinStep);
                a4 = Math.min(a4, i4);
                const r4 = s4 * a4;
                try {
                  await this.setZoom({ factor: r4 });
                } catch (e6) {
                  const t5 = e6.message || e6;
                  console.warn(t5);
                }
                this.dce.clearFrameBuffer();
              }
            } else if (this.autoZoomInFrameArray.length = 0, this.frameArrayInIdealZoom.push(true), this.frameArrayInIdealZoom.splice(0, this.frameArrayInIdealZoom.length - this.frameLimitInIdealZoom[0]), this.frameArrayInIdealZoom.filter((e5) => true === e5).length >= this.frameLimitInIdealZoom[1]) if (this.frameArrayInIdealZoom.length = 0, "focus" === this.nextActionInIdealZoom && this.autoFocus) {
              i3(c4, s3, a3, l3, h3, r3, o3);
              try {
                await this.setFocus({ mode: "manual", area: { centerPoint: { x: (c4.x1 + c4.x3) / 2 + "px", y: (c4.y1 + c4.y3) / 2 + "px" }, width: c4.x3 - c4.x1 + "px", height: c4.y3 - c4.y1 + "px" } });
              } catch (e5) {
                const t5 = e5.message || e5;
                console.warn(t5);
              }
              this.dce.clearFrameBuffer(), this.nextActionInIdealZoom = "zoomOut";
            } else {
              if ("zoomOut" !== this.nextActionInIdealZoom && this.autoFocus) throw new Error("Invalid action.");
              if (this.enableZoomOutInIdealZoom) {
                t4 = this.autoZoomIdealArea[1] + this.autoZoomOutStepRate_2;
                const e5 = [(0.5 - t4) / (0.5 - n5), (0.5 - t4) / (0.5 - d4), (0.5 - t4) / (0.5 - _4), (0.5 - t4) / (0.5 - u3)].filter((e6) => e6 > 0);
                let i4 = Math.min(...e5) * this.dce.getZoomSettings().factor;
                try {
                  await this.setZoom({ factor: i4 });
                } catch (e6) {
                  const t5 = e6.message || e6;
                  console.warn(t5);
                }
                this.dce.clearFrameBuffer(), this.autoFocus && (this.nextActionInIdealZoom = "focus", this.setFocus({ mode: "continuous" }).catch(() => {
                }));
              }
            }
          } else if (this.autoFocus && (this.autoFocusFrameArray.push(true), this.autoFocusFrameArray.splice(0, this.autoFocusFrameArray.length - this.autoFocusFrameLimit[0]), this.autoFocusFrameArray.filter((e4) => true === e4).length >= this.autoFocusFrameLimit[1])) {
            this.autoFocusFrameArray.length = 0;
            try {
              i3(c4, s3, a3, l3, h3, r3, o3), await this.setFocus({ mode: "manual", area: { centerPoint: { x: (c4.x1 + c4.x3) / 2 + "px", y: (c4.y1 + c4.y3) / 2 + "px" }, width: c4.x3 - c4.x1 + "px", height: c4.y3 - c4.y1 + "px" } });
            } catch (e4) {
              const t4 = e4.message || e4;
              console.warn(t4);
            }
            this.dce.clearFrameBuffer();
          }
        } else if (this.noIntermediateResultsCount++, this.suggestTipFrameArray.push(false), this.autoZoom) {
          if (this.autoZoomInFrameArray.push(false), this.autoZoomInFrameArray.splice(0, this.autoZoomInFrameArray.length - this.autoZoomInFrameLimit[0]), this.autoZoomOutFrameCount++, this.frameArrayInIdealZoom.push(false), this.frameArrayInIdealZoom.splice(0, this.frameArrayInIdealZoom.length - this.frameLimitInIdealZoom[0]), this.autoZoomOutFrameCount >= this.autoZoomOutFrameLimit) {
            this.autoZoomOutFrameCount = 0;
            const e4 = this.getZoomSettings().factor;
            if (e4 > this.autoZoomOutMinValue) {
              const t4 = Math.max((e4 - 1) * this.autoZoomOutStepRate, this.autoZoomOutMinStep), i4 = Math.max(e4 - t4, this.autoZoomOutMinValue);
              try {
                await this.setZoom({ factor: i4 });
              } catch (e5) {
                const t5 = e5.message || e5;
                console.warn(t5);
              }
              this.dce.clearFrameBuffer();
            }
          }
          this.autoFocus && (this.nextActionInIdealZoom = "focus", this.setFocus({ mode: "continuous" }).catch(() => {
          }));
        } else this.autoFocus && (this.autoFocusFrameArray.length = 0, this.setFocus({ mode: "continuous" }).catch(() => {
        }));
      }
      return t2;
    })().then((e3) => {
      if (L2._onLog && L2._onLog(e3), this.captureAndDecodeInParallel) {
        let e4 = this.array_decodeFrameTimeCost, t2 = this.array_getFrameTimeCost, i2 = this._indexCurrentDecodingFrame;
        const s3 = () => {
          let s4 = 0;
          if (this.region instanceof Array) {
            let a3 = 0, r3 = 0;
            a3 = i2 + 1 >= this.region.length ? 0 : i2 + 1, r3 = a3 + 1 >= this.region.length ? 0 : a3 + 1, s4 = e4[a3] && e4[a3].length && t2[r3] && t2[r3].length ? Math.min(...e4[a3]) - Math.max(...t2[r3]) : 0;
          } else if (t2 && t2.length) {
            let i3 = Math.min(...e4), a3 = Math.max(...t2);
            i3 && a3 && (s4 = i3 - a3);
          } else s4 = 0;
          return s4 > 0 ? s4 : 0;
        };
        (() => {
          if (this.region instanceof Array) {
            for (e4[i2] && e4[i2] instanceof Array || (e4[i2] = []); e4[i2].length >= 5; ) e4[i2].shift();
            e4[i2].push(this._lastInnerDecodeDuration);
          } else {
            for (; e4.length >= 5; ) e4.shift();
            e4.push(this._lastInnerDecodeDuration);
          }
        })(), this._intervalGetVideoFrame = s3() + this.intervalTime, L2._onLog && L2._onLog("Next fetching frame loop interval: " + this._intervalGetVideoFrame);
      }
      if (this.isOpen() && this.dce.video && !this.dce.video.paused && !this._bPauseScan) {
        if (this.bPlaySoundOnSuccessfulRead && e3.length) {
          let t2 = false;
          true === this.bPlaySoundOnSuccessfulRead || "frame" === this.bPlaySoundOnSuccessfulRead ? t2 = e3.some((e4) => e4.resultState >= 0) : "unique" === this.bPlaySoundOnSuccessfulRead && (t2 = e3.some((e4) => 0 == e4.resultState)), t2 && this.beepSound && (this.beepSound.stop(), this.beepSound.play());
        }
        if (navigator.vibrate && this.bVibrateOnSuccessfulRead && e3.length) {
          let t2 = false;
          if (true === this.bVibrateOnSuccessfulRead || "frame" === this.bVibrateOnSuccessfulRead ? t2 = e3.some((e4) => e4.resultState >= 0) : "unique" === this.bVibrateOnSuccessfulRead && (t2 = e3.some((e4) => 0 == e4.resultState)), t2) try {
            navigator.vibrate(this.vibrateDuration);
          } catch (e4) {
            console.warn("Vibration not allowed. User interaction required: " + (e4.message || e4));
          }
        }
        if (this.onFrameRead) {
          e3 = e3.filter((e4) => e4.resultState >= 0);
          const t2 = this._cloneDecodeResults(e3);
          this.onFrameRead(t2);
        }
        if (this.onUniqueRead) {
          e3 = e3.filter((e4) => 0 == e4.resultState);
          const t2 = this._cloneDecodeResults(e3);
          for (let e4 of t2) this.onUniqueRead(e4.barcodeText, e4);
        }
      }
      this._loopReadVideoTimeoutId && clearTimeout(this._loopReadVideoTimeoutId), this.intervalTime ? this._loopReadVideoTimeoutId = setTimeout(() => {
        this._loopReadVideo();
      }, this.intervalTime) : this._loopReadVideo();
    });
  }
  _getVideoFrame() {
    if (!this.dce) return null;
    let e2;
    if (this.captureAndDecodeInParallel) {
      L2._onLog && L2._onLog("Get frame in parallel.");
      let t2 = this.dce.isFetchingLoopStarted();
      if (this.dce.loopInterval = this._intervalGetVideoFrame, t2 || this.dce.startFetchingLoop(), !this.dce.numberOfFramesInBuffer) return this.dce.loopInterval = 0, null;
      e2 = this.dce.getFrameFromBuffer();
      const i2 = (e3) => {
        if (!e3) return;
        let t3 = e3.timeSpent, i3 = this.array_getFrameTimeCost;
        for (; i3.length >= 5; ) i3.shift();
        i3.push(t3);
      };
      i2(e2);
    } else L2._onLog && L2._onLog("Get frame in serial."), this.dce.stopFetchingLoop(), e2 = this.dce.getFrame();
    return e2;
  }
  async open() {
    this._bindUI();
    const e2 = await this.dce.open();
    return this._bPauseScan = false, this.singleFrameMode || (this.dce && (this.dce.ifShowScanRegionLaser = true), this._loopReadVideoTimeoutId && clearTimeout(this._loopReadVideoTimeoutId), this._loopReadVideoTimeoutId = setTimeout(() => {
      this._loopReadVideo();
    }, 0)), this._fireResolutionWarning(), e2;
  }
  async openVideo() {
    this._bindUI(), this.dce.ifShowScanRegionLaser = false;
    const e2 = await this.dce.open();
    return this._bPauseScan = true, this.singleFrameMode || (this._loopReadVideoTimeoutId && clearTimeout(this._loopReadVideoTimeoutId), this._loopReadVideoTimeoutId = setTimeout(() => {
      this._loopReadVideo();
    }, 0)), this._fireResolutionWarning(), e2;
  }
  close() {
    this._drawResults(null), this.dce.close(), this._bPauseScan = true, this._loopReadVideoTimeoutId && clearTimeout(this._loopReadVideoTimeoutId);
  }
  async show() {
    this._bindUI();
    const e2 = await this.dce.open(true);
    return this._bPauseScan = false, this.singleFrameMode || (this.dce && (this.dce.ifShowScanRegionLaser = true), this._loopReadVideoTimeoutId && clearTimeout(this._loopReadVideoTimeoutId), this._loopReadVideoTimeoutId = setTimeout(() => {
      this._loopReadVideo();
    }, 0)), this._fireResolutionWarning(), e2;
  }
  async showVideo() {
    this._bindUI(), this.dce.ifShowScanRegionLaser = false;
    const e2 = await this.dce.open(true);
    return this._bPauseScan = true, this.singleFrameMode || (this._loopReadVideoTimeoutId && clearTimeout(this._loopReadVideoTimeoutId), this._loopReadVideoTimeoutId = setTimeout(() => {
      this._loopReadVideo();
    }, 0)), this._fireResolutionWarning(), e2;
  }
  hide() {
    this.dce.close(true), this._bPauseScan = true, this._loopReadVideoTimeoutId && clearTimeout(this._loopReadVideoTimeoutId);
  }
  showTip(e2, t2, i2, s3, a3 = 3e3, r3 = true) {
    this.dce && this.dce.showTip(e2, t2, i2, s3, a3, r3);
  }
  hideTip() {
    this.dce && this.dce.hideTip();
  }
  updateTipMessage(e2) {
    this.dce && this.dce.updateTipMessage(e2);
  }
  async enableTapToFocus() {
    this.dce && this.dce.enableTapToFocus();
  }
  disableTapToFocus() {
    this.dce && this.dce.disableTapToFocus();
  }
  isTapToFocusEnabled() {
    return this.dce.isTapToFocusEnabled();
  }
  convertToPageCoordinates(e2) {
    return this.dce.convertToPageCoordinates(e2);
  }
  convertToClientCoordinates(e2) {
    return this.dce.convertToClientCoordinates(e2);
  }
  destroyContext() {
    this.close(), this.dce && this.dce.dispose(false), this.bDestroyed || super.destroyContext();
  }
};
F = ae, B = { value: void 0 }, function(e2) {
  e2[e2.BICM_DARK_ON_LIGHT = 1] = "BICM_DARK_ON_LIGHT", e2[e2.BICM_LIGHT_ON_DARK = 2] = "BICM_LIGHT_ON_DARK", e2[e2.BICM_DARK_ON_DARK = 4] = "BICM_DARK_ON_DARK", e2[e2.BICM_LIGHT_ON_LIGHT = 8] = "BICM_LIGHT_ON_LIGHT", e2[e2.BICM_DARK_LIGHT_MIXED = 16] = "BICM_DARK_LIGHT_MIXED", e2[e2.BICM_DARK_ON_LIGHT_DARK_SURROUNDING = 32] = "BICM_DARK_ON_LIGHT_DARK_SURROUNDING", e2[e2.BICM_SKIP = 0] = "BICM_SKIP", e2[e2.BICM_REV = 2147483648] = "BICM_REV";
}(N || (N = {})), function(e2) {
  e2[e2.BCM_AUTO = 1] = "BCM_AUTO", e2[e2.BCM_GENERAL = 2] = "BCM_GENERAL", e2[e2.BCM_SKIP = 0] = "BCM_SKIP", e2[e2.BCM_REV = 2147483648] = "BCM_REV";
}(b2 || (b2 = {})), function(e2) {
  e2[e2.BF2_NULL = 0] = "BF2_NULL", e2[e2.BF2_POSTALCODE = 32505856] = "BF2_POSTALCODE", e2[e2.BF2_NONSTANDARD_BARCODE = 1] = "BF2_NONSTANDARD_BARCODE", e2[e2.BF2_USPSINTELLIGENTMAIL = 1048576] = "BF2_USPSINTELLIGENTMAIL", e2[e2.BF2_POSTNET = 2097152] = "BF2_POSTNET", e2[e2.BF2_PLANET = 4194304] = "BF2_PLANET", e2[e2.BF2_AUSTRALIANPOST = 8388608] = "BF2_AUSTRALIANPOST", e2[e2.BF2_RM4SCC = 16777216] = "BF2_RM4SCC", e2[e2.BF2_DOTCODE = 2] = "BF2_DOTCODE", e2[e2.BF2_PHARMACODE_ONE_TRACK = 4] = "BF2_PHARMACODE_ONE_TRACK", e2[e2.BF2_PHARMACODE_TWO_TRACK = 8] = "BF2_PHARMACODE_TWO_TRACK", e2[e2.BF2_PHARMACODE = 12] = "BF2_PHARMACODE", e2[e2.BF2_ALL = -1] = "BF2_ALL";
}(P || (P = {})), function(e2) {
  e2[e2.BM_AUTO = 1] = "BM_AUTO", e2[e2.BM_LOCAL_BLOCK = 2] = "BM_LOCAL_BLOCK", e2[e2.BM_SKIP = 0] = "BM_SKIP", e2[e2.BM_THRESHOLD = 4] = "BM_THRESHOLD", e2[e2.BM_REV = 2147483648] = "BM_REV";
}(v2 || (v2 = {})), function(e2) {
  e2[e2.ECCM_CONTRAST = 1] = "ECCM_CONTRAST";
}(V || (V = {})), function(e2) {
  e2[e2.CFM_GENERAL = 1] = "CFM_GENERAL";
}(x2 || (x2 = {})), function(e2) {
  e2[e2.CCM_AUTO = 1] = "CCM_AUTO", e2[e2.CCM_GENERAL_HSV = 2] = "CCM_GENERAL_HSV", e2[e2.CCM_SKIP = 0] = "CCM_SKIP", e2[e2.CCM_REV = 2147483648] = "CCM_REV";
}(U || (U = {})), function(e2) {
  e2[e2.CICM_GENERAL = 1] = "CICM_GENERAL", e2[e2.CICM_SKIP = 0] = "CICM_SKIP", e2[e2.CICM_REV = 2147483648] = "CICM_REV";
}(k || (k = {})), function(e2) {
  e2[e2.CM_IGNORE = 1] = "CM_IGNORE", e2[e2.CM_OVERWRITE = 2] = "CM_OVERWRITE";
}(G || (G = {})), function(e2) {
  e2[e2.DM_SKIP = 0] = "DM_SKIP", e2[e2.DM_DIRECT_BINARIZATION = 1] = "DM_DIRECT_BINARIZATION", e2[e2.DM_THRESHOLD_BINARIZATION = 2] = "DM_THRESHOLD_BINARIZATION", e2[e2.DM_GRAY_EQUALIZATION = 4] = "DM_GRAY_EQUALIZATION", e2[e2.DM_SMOOTHING = 8] = "DM_SMOOTHING", e2[e2.DM_MORPHING = 16] = "DM_MORPHING", e2[e2.DM_DEEP_ANALYSIS = 32] = "DM_DEEP_ANALYSIS", e2[e2.DM_SHARPENING = 64] = "DM_SHARPENING", e2[e2.DM_BASED_ON_LOC_BIN = 128] = "DM_BASED_ON_LOC_BIN", e2[e2.DM_SHARPENING_SMOOTHING = 256] = "DM_SHARPENING_SMOOTHING";
}(Z || (Z = {})), function(e2) {
  e2[e2.DRM_AUTO = 1] = "DRM_AUTO", e2[e2.DRM_GENERAL = 2] = "DRM_GENERAL", e2[e2.DRM_BROAD_WARP = 4] = "DRM_BROAD_WARP", e2[e2.DRM_LOCAL_REFERENCE = 8] = "DRM_LOCAL_REFERENCE", e2[e2.DRM_DEWRINKLE = 16] = "DRM_DEWRINKLE", e2[e2.DRM_SKIP = 0] = "DRM_SKIP", e2[e2.DRM_REV = 2147483648] = "DRM_REV";
}(W || (W = {})), function(e2) {
  e2[e2.DPMCRM_AUTO = 1] = "DPMCRM_AUTO", e2[e2.DPMCRM_GENERAL = 2] = "DPMCRM_GENERAL", e2[e2.DPMCRM_SKIP = 0] = "DPMCRM_SKIP", e2[e2.DPMCRM_REV = 2147483648] = "DPMCRM_REV";
}(H || (H = {})), function(e2) {
  e2[e2.GTM_INVERTED = 1] = "GTM_INVERTED", e2[e2.GTM_ORIGINAL = 2] = "GTM_ORIGINAL", e2[e2.GTM_SKIP = 0] = "GTM_SKIP", e2[e2.GTM_REV = 2147483648] = "GTM_REV";
}(K || (K = {})), function(e2) {
  e2[e2.IPM_AUTO = 1] = "IPM_AUTO", e2[e2.IPM_GENERAL = 2] = "IPM_GENERAL", e2[e2.IPM_GRAY_EQUALIZE = 4] = "IPM_GRAY_EQUALIZE", e2[e2.IPM_GRAY_SMOOTH = 8] = "IPM_GRAY_SMOOTH", e2[e2.IPM_SHARPEN_SMOOTH = 16] = "IPM_SHARPEN_SMOOTH", e2[e2.IPM_MORPHOLOGY = 32] = "IPM_MORPHOLOGY", e2[e2.IPM_SKIP = 0] = "IPM_SKIP", e2[e2.IPM_REV = 2147483648] = "IPM_REV";
}(J || (J = {})), function(e2) {
  e2[e2.IRSM_MEMORY = 1] = "IRSM_MEMORY", e2[e2.IRSM_FILESYSTEM = 2] = "IRSM_FILESYSTEM", e2[e2.IRSM_BOTH = 4] = "IRSM_BOTH";
}(Y || (Y = {})), function(e2) {
  e2[e2.LM_SKIP = 0] = "LM_SKIP", e2[e2.LM_AUTO = 1] = "LM_AUTO", e2[e2.LM_CONNECTED_BLOCKS = 2] = "LM_CONNECTED_BLOCKS", e2[e2.LM_LINES = 8] = "LM_LINES", e2[e2.LM_STATISTICS = 4] = "LM_STATISTICS", e2[e2.LM_SCAN_DIRECTLY = 16] = "LM_SCAN_DIRECTLY", e2[e2.LM_STATISTICS_MARKS = 32] = "LM_STATISTICS_MARKS", e2[e2.LM_STATISTICS_POSTAL_CODE = 64] = "LM_STATISTICS_POSTAL_CODE", e2[e2.LM_CENTRE = 128] = "LM_CENTRE", e2[e2.LM_ONED_FAST_SCAN = 256] = "LM_ONED_FAST_SCAN", e2[e2.LM_REV = 2147483648] = "LM_REV";
}(Q || (Q = {})), function(e2) {
  e2[e2.QRECL_ERROR_CORRECTION_H = 0] = "QRECL_ERROR_CORRECTION_H", e2[e2.QRECL_ERROR_CORRECTION_L = 1] = "QRECL_ERROR_CORRECTION_L", e2[e2.QRECL_ERROR_CORRECTION_M = 2] = "QRECL_ERROR_CORRECTION_M", e2[e2.QRECL_ERROR_CORRECTION_Q = 3] = "QRECL_ERROR_CORRECTION_Q";
}(X || (X = {})), function(e2) {
  e2[e2.RPM_AUTO = 1] = "RPM_AUTO", e2[e2.RPM_GENERAL = 2] = "RPM_GENERAL", e2[e2.RPM_GENERAL_RGB_CONTRAST = 4] = "RPM_GENERAL_RGB_CONTRAST", e2[e2.RPM_GENERAL_GRAY_CONTRAST = 8] = "RPM_GENERAL_GRAY_CONTRAST", e2[e2.RPM_GENERAL_HSV_CONTRAST = 16] = "RPM_GENERAL_HSV_CONTRAST", e2[e2.RPM_SKIP = 0] = "RPM_SKIP", e2[e2.RPM_REV = 2147483648] = "RPM_REV";
}(z || (z = {})), function(e2) {
  e2[e2.RCT_PIXEL = 1] = "RCT_PIXEL", e2[e2.RCT_PERCENTAGE = 2] = "RCT_PERCENTAGE";
}(j || (j = {})), function(e2) {
  e2[e2.RT_STANDARD_TEXT = 0] = "RT_STANDARD_TEXT", e2[e2.RT_RAW_TEXT = 1] = "RT_RAW_TEXT", e2[e2.RT_CANDIDATE_TEXT = 2] = "RT_CANDIDATE_TEXT", e2[e2.RT_PARTIAL_TEXT = 3] = "RT_PARTIAL_TEXT";
}(q || (q = {})), function(e2) {
  e2[e2.SUM_AUTO = 1] = "SUM_AUTO", e2[e2.SUM_LINEAR_INTERPOLATION = 2] = "SUM_LINEAR_INTERPOLATION", e2[e2.SUM_NEAREST_NEIGHBOUR_INTERPOLATION = 4] = "SUM_NEAREST_NEIGHBOUR_INTERPOLATION", e2[e2.SUM_SKIP = 0] = "SUM_SKIP", e2[e2.SUM_REV = 2147483648] = "SUM_REV";
}($ || ($ = {})), function(e2) {
  e2[e2.TP_REGION_PREDETECTED = 1] = "TP_REGION_PREDETECTED", e2[e2.TP_IMAGE_PREPROCESSED = 2] = "TP_IMAGE_PREPROCESSED", e2[e2.TP_IMAGE_BINARIZED = 4] = "TP_IMAGE_BINARIZED", e2[e2.TP_BARCODE_LOCALIZED = 8] = "TP_BARCODE_LOCALIZED", e2[e2.TP_BARCODE_TYPE_DETERMINED = 16] = "TP_BARCODE_TYPE_DETERMINED", e2[e2.TP_BARCODE_RECOGNIZED = 32] = "TP_BARCODE_RECOGNIZED";
}(ee || (ee = {})), function(e2) {
  e2[e2.TFM_AUTO = 1] = "TFM_AUTO", e2[e2.TFM_GENERAL_CONTOUR = 2] = "TFM_GENERAL_CONTOUR", e2[e2.TFM_SKIP = 0] = "TFM_SKIP", e2[e2.TFM_REV = 2147483648] = "TFM_REV";
}(te || (te = {})), function(e2) {
  e2[e2.TROM_CONFIDENCE = 1] = "TROM_CONFIDENCE", e2[e2.TROM_POSITION = 2] = "TROM_POSITION", e2[e2.TROM_FORMAT = 4] = "TROM_FORMAT", e2[e2.TROM_SKIP = 0] = "TROM_SKIP", e2[e2.TROM_REV = 2147483648] = "TROM_REV";
}(ie || (ie = {})), function(e2) {
  e2[e2.TDM_AUTO = 1] = "TDM_AUTO", e2[e2.TDM_GENERAL_WIDTH_CONCENTRATION = 2] = "TDM_GENERAL_WIDTH_CONCENTRATION", e2[e2.TDM_SKIP = 0] = "TDM_SKIP", e2[e2.TDM_REV = 2147483648] = "TDM_REV";
}(se || (se = {}));
export {
  L2 as BarcodeReader,
  ae as BarcodeScanner,
  N as EnumBarcodeColourMode,
  b2 as EnumBarcodeComplementMode,
  T2 as EnumBarcodeFormat,
  P as EnumBarcodeFormat_2,
  v2 as EnumBinarizationMode,
  V as EnumClarityCalculationMethod,
  x2 as EnumClarityFilterMode,
  U as EnumColourClusteringMode,
  k as EnumColourConversionMode,
  G as EnumConflictMode,
  H as EnumDPMCodeReadingMode,
  Z as EnumDeblurMode,
  W as EnumDeformationResistingMode,
  A as EnumErrorCode,
  K as EnumGrayscaleTransformationMode,
  f2 as EnumIMResultDataType,
  E2 as EnumImagePixelFormat,
  J as EnumImagePreprocessingMode,
  Y as EnumIntermediateResultSavingMode,
  D2 as EnumIntermediateResultType,
  Q as EnumLocalizationMode,
  X as EnumQRCodeErrorCorrectionLevel,
  z as EnumRegionPredetectionMode,
  j as EnumResultCoordinateType,
  q as EnumResultType,
  $ as EnumScaleUpMode,
  ee as EnumTerminatePhase,
  te as EnumTextFilterMode,
  ie as EnumTextResultOrderMode,
  se as EnumTextureDetectionMode
};
/*! Bundled license information:

dm-howler/dist/index.esm.js:
  (*!
   *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.
   *  
   *  howler.js v2.2.3
   *  howlerjs.com
   *
   *  (c) 2013-2020, James Simpson of GoldFire Studios
   *  goldfirestudios.com
   *
   *  MIT License
   *)
  (*!
   *  howler.js v2.2.3
   *  howlerjs.com
   *
   *  (c) 2013-2020, James Simpson of GoldFire Studios
   *  goldfirestudios.com
   *
   *  MIT License
   *)

dynamsoft-camera-enhancer/dist/dce.esm.js:
  (*!
   * Dynamsoft JavaScript Library
   * @product Dynamsoft Camera Enhancer JS Edition
   * @website https://www.dynamsoft.com
   * @copyright Copyright 2024, Dynamsoft Corporation
   * @author Dynamsoft
   * @version 3.3.10 (js 20240130)
   * @fileoverview Dynamsoft JavaScript Library for Camera Enhancer
   * More info on DCE JS: https://www.dynamsoft.com/camera-enhancer/docs/programming/javascript/?ver=latest
   *)

dynamsoft-javascript-barcode/dist/dbr.pure.esm.js:
  (*!
   * Dynamsoft JavaScript Library
   * @product Dynamsoft Barcode Reader JS Edition
   * @website http://www.dynamsoft.com
   * @copyright Copyright 2024, Dynamsoft Corporation
   * @author Dynamsoft
   * @version 9.6.42 (js 20240426)
   * @fileoverview Dynamsoft JavaScript Library for Barcode Reader
   * More info on DBR JS: https://www.dynamsoft.com/barcode-reader/sdk-javascript/
   *)
*/
//# sourceMappingURL=dynamsoft-javascript-barcode.js.map
